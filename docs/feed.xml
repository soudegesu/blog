<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="https://www.soudegesu.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.soudegesu.com/" rel="alternate" type="text/html" /><updated>2018-04-24T21:03:18+09:00</updated><id>https://www.soudegesu.com/</id><title type="html">そうなんでげす</title><subtitle>soudegesuのtechブログ。普段仕事では使わない技術を中心に書いていくので入門系記事が多くなると思っていたけど、書き始めたらいい感じにいろいろまぜこぜになってきました。とりあえず、書きたくなったらいろいろ書きます。</subtitle><author><name>soudegesu</name></author><entry><title type="html">MySQL/PostgreSQLの脆弱性が発表された時に、RDS Aurora使いはどう対処すべきか</title><link href="https://www.soudegesu.com/aws/aurora-security/" rel="alternate" type="text/html" title="MySQL/PostgreSQLの脆弱性が発表された時に、RDS Aurora使いはどう対処すべきか" /><published>2018-04-24T00:00:00+09:00</published><updated>2018-04-24T00:00:00+09:00</updated><id>https://www.soudegesu.com/aws/aurora-security</id><content type="html" xml:base="https://www.soudegesu.com/aws/aurora-security/">&lt;p&gt;アプリケーションの脆弱性対応は調査にも時間がかかりますし、大変ですよね。RDS Auroraのようなマネージドサービスの場合、互換性のあるデータベースエンジン(MySQLやPostrgeSQL)の脆弱性が発表されたら、どうしたらよいのでしょうか。少し気になったので調べてみました。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#経緯セキュリティバスターズからの依頼&quot; id=&quot;markdown-toc-経緯セキュリティバスターズからの依頼&quot;&gt;[経緯]セキュリティバスターズからの依頼&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#auroraの仕組み&quot; id=&quot;markdown-toc-auroraの仕組み&quot;&gt;Auroraの仕組み&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#サポートに聞いてみよう&quot; id=&quot;markdown-toc-サポートに聞いてみよう&quot;&gt;サポートに聞いてみよう&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#latest-bulletins-を見てみよう&quot; id=&quot;markdown-toc-latest-bulletins-を見てみよう&quot;&gt;Latest Bulletins を見てみよう&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考にさせていただいたサイト&quot; id=&quot;markdown-toc-参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;経緯セキュリティバスターズからの依頼&quot;&gt;[経緯]セキュリティバスターズからの依頼&lt;/h2&gt;
&lt;p&gt;そこそこ大きい会社になってくると、セキュリティを専門とする部署があって、
&lt;a href=&quot;http://cve.mitre.org/&quot;&gt;CVE&lt;/a&gt; の情報を収集しては&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「こんな脆弱性が発表されたぞ！君たちのプロダクトは大丈夫なのか！？報告したまえ！」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;みたいなやりとりが発生します。情報を展開してくれるのは大変ありがたいのですが、やりたまえって、なんかそういうエージェント仕込むやつでもいいから少しは手伝ってくだされ。&lt;/p&gt;

&lt;p&gt;例のごとく、&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「MySQLの脆弱性が発表されたぞ！これな！」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;というお達しと共に&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CVE-2018-XXXX
CVE-2018-XXXX
CVE-2018-XXXX
(以下略)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;対象と思しきCVEのリストが展開されるのです。&lt;/p&gt;

&lt;p&gt;純粋なMySQL/PostgreSQLでないにせよ、OSSのデータベースエンジンに互換性のあるAuroraを使用している場合、我々は公表された脆弱性にどう対処するのが良いのか？とふと思ったわけです。&lt;/p&gt;

&lt;p&gt;なお、私の使っているAuroraのバージョンは &lt;code class=&quot;highlighter-rouge&quot;&gt;1.15.1&lt;/code&gt; 、互換のあるMySQLのバージョンは &lt;code class=&quot;highlighter-rouge&quot;&gt;5.6.10-log&lt;/code&gt; でした。&lt;/p&gt;

&lt;h2 id=&quot;auroraの仕組み&quot;&gt;Auroraの仕組み&lt;/h2&gt;

&lt;p&gt;そもそも「互換性がある」 からと言って、内部的な仕組みは違うので、一概に言えないのが難しい所です。&lt;/p&gt;

&lt;p&gt;例えば、下のスライドを見ると少しわかるのですが、ストレージ部分のアーキテクチャはAurora独自な感があるので、&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-2755&quot;&gt;CVE-2018-2755&lt;/a&gt; みたいなレプリケーションに関連する脆弱性は対象にならないのではないか、と推察したりもできます。&lt;/p&gt;

&lt;div class=&quot;embed-container rich &quot;&gt;&lt;iframe src=&quot;https://www.slideshare.net/slideshow/embed_code/key/m7BMjMqJzXfMzf&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;https://www.slideshare.net/AmazonWebServicesJapan/amazon-aurora-aurora&quot; title=&quot;Amazon Aurora - Auroraの止まらない進化とその中身&quot; target=&quot;_blank&quot;&gt;Amazon Aurora - Auroraの止まらない進化とその中身&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;https://www.slideshare.net/AmazonWebServicesJapan&quot; target=&quot;_blank&quot;&gt;Amazon Web Services Japan&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;

&lt;/div&gt;

&lt;h2 id=&quot;サポートに聞いてみよう&quot;&gt;サポートに聞いてみよう&lt;/h2&gt;

&lt;p&gt;ただ、推察の域を出ないので、AWSのサポートに聞いてみました。&lt;/p&gt;

&lt;p&gt;結果、結論を簡単にまとめると、&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MySQLのバージョンに存在する脆弱性は一概にAuroraにもあるとは限らない&lt;/li&gt;
  &lt;li&gt;AWSのセキュリティ適用状況は &lt;a href=&quot;https://aws.amazon.com/security/security-bulletins/&quot;&gt;Latest Bulletins&lt;/a&gt; を確認して欲しい&lt;/li&gt;
  &lt;li&gt;インスタンスへのセキュリティパッチの適用状況についてはユーザが確認することはできない&lt;/li&gt;
  &lt;li&gt;メンテナンスウィンドウにて必須のパッチの適用がスケジューリングされ、時限的に適用される(緊急の場合にはその限りではない)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;マネージドサービスだし、「まかせておけ」ということか。&lt;/p&gt;

&lt;h2 id=&quot;latest-bulletins-を見てみよう&quot;&gt;Latest Bulletins を見てみよう&lt;/h2&gt;

&lt;p&gt;過去にどのような対応があったかを見てみます。
&lt;a href=&quot;https://aws.amazon.com/security/security-bulletins/&quot;&gt;Latest Bulletins&lt;/a&gt; はRDSだけでなく、
他のAWSサービス全般のセキュリティアップデートが表示されます。&lt;/p&gt;

&lt;p&gt;その中から、過去のRDSの対応した脆弱性を探してみます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/security/security-bulletins/amazon-rds-security-advisory-cve-2016-6663-cve-2016-6664/&quot;&gt;Amazon RDS Security Advisory (CVE-2016-6663 and CVE-2016-6664)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/security/security-bulletins/amazon-rds-mysql-security-advisory-cve-2016-6662/&quot;&gt;Amazon RDS - MySQL Security Advisory (CVE-2016-6662)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/security/security-bulletins/cve-2014-2478/&quot;&gt;Amazon RDS for Oracle Security Advisory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/security/security-bulletins/mysql-5-5-and-5-6-security-advisory/&quot;&gt;Amazon RDS – MySQL Security Advisory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Auroraのものは見つかりませんでした。&lt;/p&gt;

&lt;p&gt;CVEの脆弱性とリンクされている上の2つを確認してみると、CVEがアップデートされてから半年後くらいに対応した感じでしょうか。
AWSサービス単位でまとめられているわけでもないので、とりあえず、この情報だけでは脆弱性対処の早い/遅いの判断もできなさそうです。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回はRDS Auroraのセキュリティへの対応を調べてみました。
結論を言うと、&lt;strong&gt;ユーザはAWS側におまかせする形になる&lt;/strong&gt; ので、ブラックボックスになってしまいます。&lt;/p&gt;

&lt;p&gt;もし特定の脆弱性が気になるようなら、サポートセンター経由で個別に相談するのもよいでしょうし、
MySQLエンジンのバージョンを上げれそうであれば、それで対処してしまう、という割り切りもありかな、とぼんやり思いました。&lt;/p&gt;

&lt;p&gt;逆に、脆弱性と思しき事象がある場合には、メールにて報告をする窓口も設けられていたので(調査のお手伝いをする必要がありますが)、がっぷりおつで対峙するのも手かもしれませんね。&lt;/p&gt;

&lt;h2 id=&quot;参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/blogs/database/introducing-the-aurora-storage-engine/&quot;&gt;Introducing the Aurora Storage Engine&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/AmazonWebServicesJapan/amazon-aurora-aurora&quot;&gt;Amazon Aurora - Auroraの止まらない進化とその中身&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: center&quot;&gt;
&lt;a target=&quot;_blank&quot; href=&quot;https://www.amazon.co.jp/gp/product/486594043X/ref=as_li_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=1211&amp;amp;creativeASIN=486594043X&amp;amp;linkCode=as2&amp;amp;tag=soudegesu-22&amp;amp;linkId=aa4c69d72db754bc626b9aa59c0d415a&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;amp;MarketPlace=JP&amp;amp;ASIN=486594043X&amp;amp;ServiceVersion=20070822&amp;amp;ID=AsinImage&amp;amp;WS=1&amp;amp;Format=_SL250_&amp;amp;tag=soudegesu-22&quot; /&gt;&lt;/a&gt;&lt;img src=&quot;//ir-jp.amazon-adsystem.com/e/ir?t=soudegesu-22&amp;amp;l=am2&amp;amp;o=9&amp;amp;a=486594043X&quot; width=&quot;1&quot; height=&quot;1&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;border:none !important; margin:0px !important;&quot; /&gt;
&lt;/div&gt;</content><author><name>soudegesu</name></author><category term="aurora" /><summary type="html">アプリケーションの脆弱性対応は調査にも時間がかかりますし、大変ですよね。RDS Auroraのようなマネージドサービスの場合、互換性のあるデータベースエンジン(MySQLやPostrgeSQL)の脆弱性が発表されたら、どうしたらよいのでしょうか。少し気になったので調べてみました。</summary></entry><entry><title type="html">AWS LambdaでCasperJSを実行してファイルアップロードを自動化する</title><link href="https://www.soudegesu.com/aws/casperjs-on-lambda/" rel="alternate" type="text/html" title="AWS LambdaでCasperJSを実行してファイルアップロードを自動化する" /><published>2018-04-23T00:00:00+09:00</published><updated>2018-04-23T00:00:00+09:00</updated><id>https://www.soudegesu.com/aws/casperjs-on-lambda</id><content type="html" xml:base="https://www.soudegesu.com/aws/casperjs-on-lambda/">&lt;p&gt;AWS上のデータを別サービスに連携するために、AWS LambdaからCasperJSを使ってファイル配置を自動化する仕組みを作ってみました。
APIでデータをPOSTできれば簡単なのですが、今回はGUI上からファイルをアップロードしないといけないため、技術の無駄遣いをしてみます。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#日次でファイルをアップロードしたい&quot; id=&quot;markdown-toc-日次でファイルをアップロードしたい&quot;&gt;日次でファイルをアップロードしたい&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#casperjsとは&quot; id=&quot;markdown-toc-casperjsとは&quot;&gt;CasperJSとは&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#lambda--casperjs-で実現してみよう&quot; id=&quot;markdown-toc-lambda--casperjs-で実現してみよう&quot;&gt;Lambda + CasperJS で実現してみよう&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#実装時のポイント&quot; id=&quot;markdown-toc-実装時のポイント&quot;&gt;実装時のポイント&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#lambdaに割り当てるリソースは大きめにタイムアウトは長く設定する&quot; id=&quot;markdown-toc-lambdaに割り当てるリソースは大きめにタイムアウトは長く設定する&quot;&gt;Lambdaに割り当てるリソースは大きめに、タイムアウトは長く設定する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#aws-lambdaにphantomjsのパスを通す&quot; id=&quot;markdown-toc-aws-lambdaにphantomjsのパスを通す&quot;&gt;AWS LambdaにPhantomJSのパスを通す&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#s3オブジェクトを一度lambdaのコンテナ上にダウンロードする&quot; id=&quot;markdown-toc-s3オブジェクトを一度lambdaのコンテナ上にダウンロードする&quot;&gt;S3オブジェクトを一度Lambdaのコンテナ上にダウンロードする&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#lambda実行の最後にs3バケットへ画面キャプチャをアップロードする&quot; id=&quot;markdown-toc-lambda実行の最後にs3バケットへ画面キャプチャをアップロードする&quot;&gt;Lambda実行の最後にS3バケットへ画面キャプチャをアップロードする&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ブラウザの言語設定を英語にした&quot; id=&quot;markdown-toc-ブラウザの言語設定を英語にした&quot;&gt;ブラウザの言語設定を英語にした&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考にさせていただいたサイト&quot; id=&quot;markdown-toc-参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;日次でファイルをアップロードしたい&quot;&gt;日次でファイルをアップロードしたい&lt;/h2&gt;

&lt;p&gt;ことの発端は以前書いた記事 「&lt;a href=&quot;/aws/s3-cross-account/&quot;&gt;クロスアカウントで共有されたS3バケットはAWSコンソール上から参照可能なのか&lt;/a&gt;」 にて、
&lt;strong&gt;S3のバケット共有の機能を使ってファイルの提供をしようと試みた&lt;/strong&gt; のですが、社内のセキュリティ統制的にNGを喰らってしまいましたので、
指定のファイルストレージサービスを経由してファイルの授受を行う必要が出てきました。&lt;/p&gt;

&lt;p&gt;そのファイルストレージサービスというのが若干レガシーなシステムで、APIを使ったファイルのアップロードができません。
そのため、ヘッドレスブラウザでのGUI操作ができるライブラリを使用してファイルアップロードをしようと考えた次第です。&lt;/p&gt;

&lt;p&gt;これを実装しないと、私が毎朝システムにログインしてファイルをアップロードするという苦行が発生するため、是が非でも作る必要がありました。&lt;/p&gt;

&lt;p&gt;退屈なことはプログラムにやらせましょう。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
&lt;a target=&quot;_blank&quot; href=&quot;https://www.amazon.co.jp/gp/product/487311778X/ref=as_li_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=1211&amp;amp;creativeASIN=487311778X&amp;amp;linkCode=as2&amp;amp;tag=soudegesu-22&amp;amp;linkId=22f6b91a2296dc4b4344bbc4b08fc5dd&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;amp;MarketPlace=JP&amp;amp;ASIN=487311778X&amp;amp;ServiceVersion=20070822&amp;amp;ID=AsinImage&amp;amp;WS=1&amp;amp;Format=_SL160_&amp;amp;tag=soudegesu-22&quot; /&gt;&lt;/a&gt;&lt;img src=&quot;//ir-jp.amazon-adsystem.com/e/ir?t=soudegesu-22&amp;amp;l=am2&amp;amp;o=9&amp;amp;a=487311778X&quot; width=&quot;1&quot; height=&quot;1&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;border:none !important; margin:0px !important;&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;casperjsとは&quot;&gt;CasperJSとは&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://casperjs.org/&quot;&gt;CasperJS&lt;/a&gt; は &lt;a href=&quot;http://phantomjs.org/&quot;&gt;PhantomJS&lt;/a&gt; のラッパーライブラリです。
PhantomJS 自体はwebkitをベースとしたヘッドレスブラウザです。
実ブラウザを起動するSeleniumよりも高速に動作するので、GUIを持つ必要のない処理（例えばGUIの自動テストや、今回のような機械的な処理)に向いています。
昨年頃に &lt;a href=&quot;https://developers.google.com/web/updates/2017/04/headless-chrome?hl=ja&quot;&gt;Chromeもヘッドレスで起動できる&lt;/a&gt; ようになっているため、
PhantomJSでなくても良いのですが、過去にPhantomJSを使った経験があったため、再びこれを採用しています。&lt;/p&gt;

&lt;p&gt;ラッパーであるCasperJSを使う利点は、ブラウザ操作のユーティリティが揃っていることです。
セレクタに対するwaitや、イベントの発火、データ入力等のコードをシンプルに書くことができます。&lt;/p&gt;

&lt;p&gt;というか、PhantomJS単体だと自前定義のfunctionが多くなるためオススメできません。&lt;/p&gt;

&lt;h2 id=&quot;lambda--casperjs-で実現してみよう&quot;&gt;Lambda + CasperJS で実現してみよう&lt;/h2&gt;

&lt;p&gt;早速実装してみましょう。今回作成したプログラムは &lt;a href=&quot;https://github.com/soudegesu/casper-lambda-test&quot;&gt;こちら&lt;/a&gt; です。
なお、このプログラム自体は &lt;a href=&quot;https://github.com/narainsagar/node-casperjs-aws-lambda&quot;&gt;node-casperjs-aws-lambda&lt;/a&gt; を参考にしています。&lt;/p&gt;

&lt;p&gt;今回実装したアーキテクチャはざっくり以下のようなイメージです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180423/casperjs.png&quot; alt=&quot;casper_architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;実行環境やライブラリは以下になります。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Node 6.10&lt;/li&gt;
  &lt;li&gt;CasperJS 1.1.4&lt;/li&gt;
  &lt;li&gt;PhantomJS 2.1.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また、処理の流れは以下になります。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;LambdaがETL処理をする&lt;/li&gt;
  &lt;li&gt;ETL処理終了後にS3にファイルをアップロード&lt;/li&gt;
  &lt;li&gt;BucketのPUTイベントを基にファイルアップロード用のLambdaが実行される&lt;/li&gt;
  &lt;li&gt;LambdaでCasperJSが動き、他サービスにファイルをアップロードする&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;実装時のポイント&quot;&gt;実装時のポイント&lt;/h2&gt;

&lt;h3 id=&quot;lambdaに割り当てるリソースは大きめにタイムアウトは長く設定する&quot;&gt;Lambdaに割り当てるリソースは大きめに、タイムアウトは長く設定する&lt;/h3&gt;
&lt;p&gt;ヘッドレスとは言え、CasperJSを実行するために、Lambdaに割り当てるメモリは大きめにした方が良いです。&lt;/p&gt;

&lt;p&gt;加えて、Lambdaのタイムアウト値は最大値の5分に設定しておきましょう。もちろん、これらは実装する処理の重さに依存します。&lt;/p&gt;

&lt;h3 id=&quot;aws-lambdaにphantomjsのパスを通す&quot;&gt;AWS LambdaにPhantomJSのパスを通す&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;node_module&lt;/code&gt; 内のPhantomJSはLambda上ではいい感じに見てくれなかったので、&lt;a href=&quot;http://phantomjs.org/download.html&quot;&gt;PhantomJSのバイナリをダウンロード&lt;/a&gt;して直接パスを通してあげました。&lt;/p&gt;

&lt;p&gt;余談ですが、AWS Lambdaの環境変数一覧は &lt;a href=&quot;https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/current-supported-versions.html&quot;&gt;ここ&lt;/a&gt; に纏められています。はじめて知りました。&lt;/p&gt;

&lt;h3 id=&quot;s3オブジェクトを一度lambdaのコンテナ上にダウンロードする&quot;&gt;S3オブジェクトを一度Lambdaのコンテナ上にダウンロードする&lt;/h3&gt;

&lt;p&gt;S3のPUTイベントをトリガーに処理が実行されるのですが、&lt;code class=&quot;highlighter-rouge&quot;&gt;event&lt;/code&gt; オブジェクトにはバケットの情報やオブジェクトキーの情報しかないため、
そこから一度、Lambdaコンテナの &lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp/&lt;/code&gt; 配下とかに一度ダウンロードします。&lt;/p&gt;

&lt;h3 id=&quot;lambda実行の最後にs3バケットへ画面キャプチャをアップロードする&quot;&gt;Lambda実行の最後にS3バケットへ画面キャプチャをアップロードする&lt;/h3&gt;

&lt;p&gt;CasperJSのデバッグはコンソールに情報を出力するよりも &lt;code class=&quot;highlighter-rouge&quot;&gt;caputure&lt;/code&gt; 関数を呼び出して、その瞬間の画面キャプチャを取得する方が捗ります。
ただ、Lambda上で実行している場合には、Lambdaの処理が終了するとコンテナも終了するため、処理の最後に任意のS3にアップロードしてあげます。&lt;/p&gt;

&lt;p&gt;なお、キャプチャファイルはカレントディレクトリ( &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/task&lt;/code&gt; 配下)に出力しようとすると、書き込み権限がないエラーになってしまいましたので、 &lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp/&lt;/code&gt; に吐き出しています。&lt;/p&gt;

&lt;p&gt;また、キャプチャーした画像ファイルは大抵複数できあがるので、&lt;code class=&quot;highlighter-rouge&quot;&gt;aws-sdk&lt;/code&gt; でS3アップロードする処理は &lt;code class=&quot;highlighter-rouge&quot;&gt;Promisse&lt;/code&gt; を使って書きました。&lt;/p&gt;

&lt;h3 id=&quot;ブラウザの言語設定を英語にした&quot;&gt;ブラウザの言語設定を英語にした&lt;/h3&gt;

&lt;p&gt;CasperJSで操作するWebコンテンツがi18n対応されていたため、ヘッドレスブラウザの設定を英語にしました。
&lt;strong&gt;CSSセレクタではなくてエレメント内のテキスト情報で要素を引きたい&lt;/strong&gt; ことが発生した場合に、マルチバイト文字だと引っかからなかったからです。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Change browser lang
casper.on('started', function () {
    this.page.customHeaders = {
        &quot;Accept-Language&quot;: &quot;en-US&quot;
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;ランタイムに依存しない&lt;/strong&gt; という意味でも設定しておいた方が良いと思います。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;今回はAWS Lambda上でCasperJSを実行することで、S3上のファイルを別のストレージサービスへアップロードすることができました。
CasperJSからPhantomJSを呼び出せるようにPATHに追加したり、キャプチャ画像をアップロードするためのバケットを準備したり、
下準備に若干時間がかかりますが、一度作れば動きが理解できると思います。&lt;/p&gt;

&lt;p&gt;Lambdaのタイムアウト時間の最大値である5分以内に処理を終了させる必要があるため、最初はタイムアウトしないか心配でした。
しかし、メモリも大きめに割り当てて上げると実行自体は数十秒くらいで終了したので、ヘッドレスブラウザ最強です。
CasperJSのコードも短かったのが良かったのかもしれません。&lt;/p&gt;

&lt;p&gt;と、これを書きながら、「CasperJSのコードを複数のLambdaで分担してGUIのテストできたらかっこいいな」と感じました。&lt;/p&gt;

&lt;h2 id=&quot;参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://casperjs.org/&quot;&gt;CasperJS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://phantomjs.org/&quot;&gt;PhantomJS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/narainsagar/node-casperjs-aws-lambda&quot;&gt;node-casperjs-aws-lambda&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
&lt;a target=&quot;_blank&quot; href=&quot;https://www.amazon.co.jp/gp/offer-listing/4883379930/ref=as_li_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=1211&amp;amp;creativeASIN=4883379930&amp;amp;linkCode=am2&amp;amp;tag=soudegesu-22&amp;amp;linkId=ae79fa81d72604fbe4a1f4f71e97c369&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;amp;MarketPlace=JP&amp;amp;ASIN=4883379930&amp;amp;ServiceVersion=20070822&amp;amp;ID=AsinImage&amp;amp;WS=1&amp;amp;Format=_SL250_&amp;amp;tag=soudegesu-22&quot; /&gt;&lt;/a&gt;&lt;img src=&quot;//ir-jp.amazon-adsystem.com/e/ir?t=soudegesu-22&amp;amp;l=am2&amp;amp;o=9&amp;amp;a=4883379930&quot; width=&quot;1&quot; height=&quot;1&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;border:none !important; margin:0px !important;&quot; /&gt;
&lt;/div&gt;</content><author><name>soudegesu</name></author><category term="aws" /><category term="lambda" /><category term="casperjs" /><summary type="html">AWS上のデータを別サービスに連携するために、AWS LambdaからCasperJSを使ってファイル配置を自動化する仕組みを作ってみました。 APIでデータをPOSTできれば簡単なのですが、今回はGUI上からファイルをアップロードしないといけないため、技術の無駄遣いをしてみます。</summary></entry><entry><title type="html">Pythonで日付文字列からのdatetime変換やタイムゾーンの変更などをいい加減覚えたい</title><link href="https://www.soudegesu.com/python/python-datetime/" rel="alternate" type="text/html" title="Pythonで日付文字列からのdatetime変換やタイムゾーンの変更などをいい加減覚えたい" /><published>2018-04-22T00:00:00+09:00</published><updated>2018-04-22T00:00:00+09:00</updated><id>https://www.soudegesu.com/python/python-datetime</id><content type="html" xml:base="https://www.soudegesu.com/python/python-datetime/">&lt;p&gt;仕事がらpythonを使って、データのコンバータを作成することも度々あるのですが、&lt;strong&gt;pythonのdatetimeを使った文字列から日時への変換&lt;/strong&gt; や &lt;strong&gt;タイムゾーンの変更&lt;/strong&gt; を毎回ネットで調べているので、いい加減覚えないと業務効率上差し支えそうです。&lt;/p&gt;

&lt;p&gt;今回は自分の備忘録的な意味も込めて書こうと思います。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#環境情報&quot; id=&quot;markdown-toc-環境情報&quot;&gt;環境情報&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#頻繁に使う変換&quot; id=&quot;markdown-toc-頻繁に使う変換&quot;&gt;頻繁に使う変換&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#epochtimeからdatetime&quot; id=&quot;markdown-toc-epochtimeからdatetime&quot;&gt;epochtimeからdatetime&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#epochtimeからdatetime-1&quot; id=&quot;markdown-toc-epochtimeからdatetime-1&quot;&gt;epochtimeからdatetime&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#ミリ秒を含むepochtimeからdatetime&quot; id=&quot;markdown-toc-ミリ秒を含むepochtimeからdatetime&quot;&gt;ミリ秒を含むepochtimeからdatetime&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#エポックミリ秒からdatetime&quot; id=&quot;markdown-toc-エポックミリ秒からdatetime&quot;&gt;エポックミリ秒からdatetime&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#文字列からdatetime&quot; id=&quot;markdown-toc-文字列からdatetime&quot;&gt;文字列からdatetime&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#タイムゾーンあり日付文字列からdatetime&quot; id=&quot;markdown-toc-タイムゾーンあり日付文字列からdatetime&quot;&gt;タイムゾーンあり日付文字列からdatetime&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#タイムゾーンなし日付文字列からdatetime&quot; id=&quot;markdown-toc-タイムゾーンなし日付文字列からdatetime&quot;&gt;タイムゾーンなし日付文字列からdatetime&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#日時データを扱う上で注意すべきこと&quot; id=&quot;markdown-toc-日時データを扱う上で注意すべきこと&quot;&gt;日時データを扱う上で注意すべきこと&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#naiveとaware&quot; id=&quot;markdown-toc-naiveとaware&quot;&gt;naiveとaware&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#マシン上のタイムゾーンで処理しないように注意する&quot; id=&quot;markdown-toc-マシン上のタイムゾーンで処理しないように注意する&quot;&gt;マシン上のタイムゾーンで処理しないように注意する&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考にさせていただいたサイト&quot; id=&quot;markdown-toc-参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;環境情報&quot;&gt;環境情報&lt;/h2&gt;

&lt;p&gt;今回のPythonの実行環境は以下になります。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;python 3.6&lt;/li&gt;
  &lt;li&gt;pytz&lt;/li&gt;
  &lt;li&gt;jupyter notebook&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;頻繁に使う変換&quot;&gt;頻繁に使う変換&lt;/h2&gt;

&lt;p&gt;データのクレンジング作業などで時系列データを取り扱う場合には、特定のミドルウェアや他人のコンバータが出力するデータ仕様を調査した上で加工処理を施すことが多いです。&lt;/p&gt;

&lt;p&gt;Pythonでは日付時刻の処理を行う場合に &lt;code class=&quot;highlighter-rouge&quot;&gt;datetime&lt;/code&gt; や &lt;code class=&quot;highlighter-rouge&quot;&gt;date&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;time&lt;/code&gt; などの型を使って処理をしますが、今回は &lt;code class=&quot;highlighter-rouge&quot;&gt;datetime&lt;/code&gt; を使います。&lt;/p&gt;

&lt;h3 id=&quot;epochtimeからdatetime&quot;&gt;epochtimeからdatetime&lt;/h3&gt;
&lt;p&gt;epochtimeを表す &lt;code class=&quot;highlighter-rouge&quot;&gt;数値型&lt;/code&gt; から &lt;code class=&quot;highlighter-rouge&quot;&gt;datetime&lt;/code&gt; に変換します。&lt;/p&gt;

&lt;p&gt;epochtimeはUnix時間とも言われますが、世界標準時の1970年1月1日午前0時0分0秒からの経過秒数を整数値で表したものです。
詳細はwikipediaを見た方が早いと思いますので、 &lt;a href=&quot;https://ja.wikipedia.org/wiki/UNIX%E6%99%82%E9%96%93&quot;&gt;こちら&lt;/a&gt; をみてください。&lt;/p&gt;

&lt;p&gt;UTCからの経過秒数を表現していることから、その数字からタイムゾーン付きのデータに変換することは容易です。&lt;/p&gt;

&lt;p&gt;強いて言えば、epochtimeの数値データが &lt;strong&gt;エポック秒&lt;/strong&gt; なのか &lt;strong&gt;エポックミリ秒&lt;/strong&gt; なのかの確認をしておくと良いでしょう。
桁数を見るか、関数に実データを放り込んで判別することが多いです。&lt;/p&gt;

&lt;p&gt;datetime型の &lt;code class=&quot;highlighter-rouge&quot;&gt;fromtimestamp&lt;/code&gt; 関数を使えば記述もシンプルに済ませることができます。&lt;/p&gt;

&lt;h4 id=&quot;epochtimeからdatetime-1&quot;&gt;epochtimeからdatetime&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fromtimestamp&lt;/code&gt; 関数を使った変換のサンプルは以下になります。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import datetime

e = 1524349374
dt = datetime.datetime.fromtimestamp(e)
print(dt)

# &amp;gt;&amp;gt; 2018-04-22 07:22:54
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ミリ秒を含むepochtimeからdatetime&quot;&gt;ミリ秒を含むepochtimeからdatetime&lt;/h4&gt;

&lt;p&gt;少数点以下にミリ秒を含んでいても問題なく変換できます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# epochtimeからdatetime(ミリ秒含む)
import datetime

mills = 1524349374.099776
dt2 = datetime.datetime.fromtimestamp(mills)
print(dt2)

# &amp;gt;&amp;gt; 2018-04-22 07:22:54.099776
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;エポックミリ秒からdatetime&quot;&gt;エポックミリ秒からdatetime&lt;/h4&gt;

&lt;p&gt;整数部分でミリ秒部分が表現されている(エポックミリ秒表記)場合には、何桁までがミリ秒を表しているのか確認した後、割ってあげます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# epochmillitimeからdatetime
import datetime

mills = 1524349374099
dt3 = datetime.datetime.fromtimestamp(mills / 1000)
print(dt3)

# &amp;gt;&amp;gt; 2018-04-22 07:22:54.099000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;文字列からdatetime&quot;&gt;文字列からdatetime&lt;/h3&gt;

&lt;p&gt;次に文字列からdatetimeに変換します。&lt;/p&gt;

&lt;h4 id=&quot;タイムゾーンあり日付文字列からdatetime&quot;&gt;タイムゾーンあり日付文字列からdatetime&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;strptime&lt;/code&gt; 関数を使えば簡単に変換できます。
ミリ秒は &lt;code class=&quot;highlighter-rouge&quot;&gt;%f&lt;/code&gt; 、 タイムゾーンは &lt;code class=&quot;highlighter-rouge&quot;&gt;%z&lt;/code&gt; を使えばパースしてくれます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# タイムゾーンあり
import datetime

utc_date_str = '2018-04-01 20:10:56.123+0900'
dt = datetime.datetime.strptime(utc_date_str, '%Y-%m-%d %H:%M:%S.%f%z')

print(dt)
# &amp;gt;&amp;gt; 2018-04-01 20:10:56.123000+09:00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;タイムゾーンなし日付文字列からdatetime&quot;&gt;タイムゾーンなし日付文字列からdatetime&lt;/h4&gt;

&lt;p&gt;厄介なのが、 &lt;strong&gt;タイムゾーンのない日付文字列をdatetimeに変換する&lt;/strong&gt; 場合です。
&lt;strong&gt;日付文字列がどのタイムゾーンのデータを表しているか&lt;/strong&gt; を調べる必要があります。
少し邪道感ありますが、データ仕様（タイムゾーンが何か）を確認した後に文字列結合してしまうのが楽ちんです。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# タイムゾーンなし日付文字列(文字列結合)
import datetime

utc_date_str = '2018-04-01 20:10:56'
# JSTとして取扱う
dt = datetime.datetime.strptime(utc_date_str + '+0900', '%Y-%m-%d %H:%M:%S%z')

print(dt)
print(dt.tzinfo)
# &amp;gt;&amp;gt; 2018-04-01 20:10:56+09:00
# &amp;gt;&amp;gt; UTC+09:00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;別パターンは &lt;code class=&quot;highlighter-rouge&quot;&gt;dateutil&lt;/code&gt; を使うパターンも書いておきます。
&lt;code class=&quot;highlighter-rouge&quot;&gt;dateutil&lt;/code&gt; の &lt;code class=&quot;highlighter-rouge&quot;&gt;parse&lt;/code&gt; 関数を使用する際に &lt;code class=&quot;highlighter-rouge&quot;&gt;tzinfos&lt;/code&gt; を引数に与えることで指定のtimezoneで処理をしてくれる書き方です。
先程の例と比べて、パッと見でどこのタイムゾーンかが識別しやすくなる、という利点があります。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# タイムゾーンなし日付文字列(dateutilを使う)
import datetime
from dateutil.parser import parse
from dateutil.tz import gettz

tzinfos = {'JST' : gettz('Asia/Tokyo')}
date_str = '2018-04-01 20:10:56'
str_to_dt = parse(date_str + ' JST', tzinfos=tzinfos)
print(str_to_dt)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;日時データを扱う上で注意すべきこと&quot;&gt;日時データを扱う上で注意すべきこと&lt;/h2&gt;
&lt;h3 id=&quot;naiveとaware&quot;&gt;naiveとaware&lt;/h3&gt;

&lt;p&gt;そもそもPythonで日時データを扱う場合には、&lt;strong&gt;naive&lt;/strong&gt; と &lt;strong&gt;aware&lt;/strong&gt; の2種類のオブジェクトがあることに注意が必要です。&lt;/p&gt;

&lt;p&gt;以下、Pythonの公式ドキュメントから引用します。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;aware オブジェクト&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;aware オブジェクトは他の aware オブジェクトとの相対関係を把握出来るように、
タイムゾーンや夏時間の情報のような、アルゴリズム的で政治的な適用可能な時間調節に関する知識を持っています。
aware オブジェクトは解釈の余地のない特定の実時刻を表現するのに利用されます。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;naive オブジェクト&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;naive オブジェクトには他の日付時刻オブジェクトとの相対関係を把握するのに足る情報が含まれません。
あるプログラム内の数字がメートルを表わしているのか、マイルなのか、それとも質量なのかがプログラムによって異なるように、
naive オブジェクトが協定世界時 (UTC) なのか、現地時間なのか、それとも他のタイムゾーンなのかはそのプログラムに依存します。
Naive オブジェクトはいくつかの現実的な側面を無視してしまうというコストを無視すれば、簡単に理解でき、うまく利用することができます。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;つまり、タイムゾーンに依存したデータを扱いたい場合には &lt;code class=&quot;highlighter-rouge&quot;&gt;aware&lt;/code&gt; オブジェクトが必要なことを意味します。&lt;/p&gt;

&lt;p&gt;しかし厄介なのが、型とaware/naiveオブジェクトの関係です。型に対して利用するオブジェクトが一意に決まりません。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;型&lt;/td&gt;
      &lt;td&gt;オブジェクト&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tfoot&gt;
    &lt;tr&gt;
      &lt;td&gt;date&lt;/td&gt;
      &lt;td&gt;naive&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;time&lt;/td&gt;
      &lt;td&gt;naive または aware&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;datetime&lt;/td&gt;
      &lt;td&gt;naive または aware&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tfoot&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;time&lt;/code&gt; 型と &lt;code class=&quot;highlighter-rouge&quot;&gt;datetime&lt;/code&gt; 型がそれぞれ、 &lt;code class=&quot;highlighter-rouge&quot;&gt;aware&lt;/code&gt; と &lt;code class=&quot;highlighter-rouge&quot;&gt;naive&lt;/code&gt; かは以下で確認できます。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;オブジェクト&lt;/td&gt;
      &lt;td&gt;awareになる条件&lt;/td&gt;
      &lt;td&gt;naiveになる条件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tfoot&gt;
    &lt;tr&gt;
      &lt;td&gt;time&lt;/td&gt;
      &lt;td&gt;オブジェクト tの &lt;code class=&quot;highlighter-rouge&quot;&gt;t.tzinfo&lt;/code&gt; が None でなく &lt;code class=&quot;highlighter-rouge&quot;&gt;t.tzinfo.utcoffset(None)&lt;/code&gt; が None を返さない場合&lt;/td&gt;
      &lt;td&gt;aware以外の場合&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;datetime&lt;/td&gt;
      &lt;td&gt;オブジェクト dの &lt;code class=&quot;highlighter-rouge&quot;&gt;d.tzinfo&lt;/code&gt; が None でなく &lt;code class=&quot;highlighter-rouge&quot;&gt;d.tzinfo.utcoffset(d)&lt;/code&gt; が None を返さない場合&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;d.tzinfo&lt;/code&gt; が None であるか &lt;code class=&quot;highlighter-rouge&quot;&gt;d.tzinfo&lt;/code&gt; が None でないが &lt;code class=&quot;highlighter-rouge&quot;&gt;d.tzinfo.utcoffset(d)&lt;/code&gt; が None を返す場合&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tfoot&gt;
&lt;/table&gt;

&lt;h3 id=&quot;マシン上のタイムゾーンで処理しないように注意する&quot;&gt;マシン上のタイムゾーンで処理しないように注意する&lt;/h3&gt;

&lt;p&gt;awareとnaiveに留意せずにタイムゾーン変換の処理を書くと、動作環境によって得られる結果が変わってしまうため、注意が必要です。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 文字列から日付(実行マシン上のタイムゾーンに引きずられる)
import datetime
from pytz import timezone
import pytz

# タイムゾーンなし文字列からdatetimeに変換する
date_str = '2018-04-01 20:10:56'
# この処理で得られるstr_to_dtはnaive
str_to_dt = datetime.datetime.strptime(date_str, '%Y-%m-%d %H:%M:%S')
print(&quot;Str to dt&quot;)
print(str_to_dt)                      # 2018-04-01 20:10:56
print(str_to_dt.timestamp())          # 1522581056.0
print(str_to_dt.tzname())             # None

# 以下、naiveな時刻をベースに演算すると、ずれる
utc = timezone('UTC')
utc_dt = str_to_dt.astimezone(utc)
print(&quot;UTC dt&quot;)
print(utc_dt)                         # 2018-04-01 11:10:56+00:00
print(utc_dt.timestamp())             # 1522581056.0
print(utc_dt.tzname())                # UTC
print(utc_dt.tzinfo.utcoffset(utc_dt))# 0:00:00

jst = timezone('Asia/Tokyo');
jst_dt = str_to_dt.astimezone(jst);
print(&quot;JST dt&quot;)
print(jst_dt)                         # 2018-04-01 20:10:56+09:00
print(jst_dt.timestamp())             # 1522581056.0
print(jst_dt.tzname())                # JST
print(jst_dt.tzinfo.utcoffset(jst_dt))# 9:00:00

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;この例ではタイムゾーンなしの文字列からdatetime型の &lt;code class=&quot;highlighter-rouge&quot;&gt;str_to_dt&lt;/code&gt; を作成するのですが、
そこから &lt;code class=&quot;highlighter-rouge&quot;&gt;astimezone&lt;/code&gt; 関数を使って任意のタイムゾーンへ変換しようとする際に、
実行環境上のタイムゾーンから、変換先のタイムゾーンへの相対的な計算が行われます。&lt;/p&gt;

&lt;p&gt;そのため、パブリッククラウドで複数リージョンを使っている場合などには、
プログラムの展開先によって振る舞いが異なる可能性があるため、注意が必要でしょう。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回はPythonで日付文字列からdatetime型に変換するときの方法を書きました。&lt;/p&gt;

&lt;p&gt;日付文字列を変換する場合には &lt;strong&gt;文字列の中にタイムゾーン情報が含まれているか&lt;/strong&gt; を気をつけて処理をすると良いです。&lt;/p&gt;

&lt;p&gt;得られるオブジェクトが &lt;code class=&quot;highlighter-rouge&quot;&gt;aware&lt;/code&gt; か &lt;code class=&quot;highlighter-rouge&quot;&gt;naive&lt;/code&gt; なのかを意識した上でタイムゾーン変換の処理を行わないと、うっかり手痛い変換ミスになってしまうので注意が必要だからです。&lt;/p&gt;

&lt;p&gt;私の場合、基本的には「データ仕様を確認して、タイムゾーンあり文字列として変換してしまう」方で処理をしようと思いました。&lt;/p&gt;

&lt;h2 id=&quot;参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.jp/3/library/datetime.html&quot;&gt;Python docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: center&quot;&gt;
&lt;a target=&quot;_blank&quot; href=&quot;https://www.amazon.co.jp/gp/offer-listing/479738946X/ref=as_li_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=1211&amp;amp;creativeASIN=479738946X&amp;amp;linkCode=am2&amp;amp;tag=soudegesu-22&amp;amp;linkId=4d6041eaf55821514ce2f3c16f0b9a5c&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;amp;MarketPlace=JP&amp;amp;ASIN=479738946X&amp;amp;ServiceVersion=20070822&amp;amp;ID=AsinImage&amp;amp;WS=1&amp;amp;Format=_SL250_&amp;amp;tag=soudegesu-22&quot; /&gt;&lt;/a&gt;&lt;img src=&quot;//ir-jp.amazon-adsystem.com/e/ir?t=soudegesu-22&amp;amp;l=am2&amp;amp;o=9&amp;amp;a=479738946X&quot; width=&quot;1&quot; height=&quot;1&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;border:none !important; margin:0px !important;&quot; /&gt;
&lt;/div&gt;</content><author><name>soudegesu</name></author><category term="python" /><summary type="html">仕事がらpythonを使って、データのコンバータを作成することも度々あるのですが、pythonのdatetimeを使った文字列から日時への変換 や タイムゾーンの変更 を毎回ネットで調べているので、いい加減覚えないと業務効率上差し支えそうです。</summary></entry><entry><title type="html">継続的デリバリのためにfeatureのリリースと改善系アイテムのリリースは分けよう</title><link href="https://www.soudegesu.com/continuous-delivery/separate-improvement-and-feature/" rel="alternate" type="text/html" title="継続的デリバリのためにfeatureのリリースと改善系アイテムのリリースは分けよう" /><published>2018-04-16T00:00:00+09:00</published><updated>2018-04-16T00:00:00+09:00</updated><id>https://www.soudegesu.com/continuous-delivery/separate-improvement-and-feature</id><content type="html" xml:base="https://www.soudegesu.com/continuous-delivery/separate-improvement-and-feature/">&lt;p&gt;&lt;a href=&quot;http://www.ryuzee.com/contents/blog/4241&quot;&gt;継続的デリバリ(Continuous Delivery)&lt;/a&gt;はITの現場で一般的なものと浸透してきました。
継続的デリバリを実現するためには、継続的インテグレーションの仕組みと
再現性のあるデプロイメントパイプライン基盤の整備が必要です。
これにより出荷可能なプロダクトを頻繁にリリースすることが可能になります。
今回は頻繁にリリース可能な環境下において、より安全にサービスをデリバリするための個人的な考えをまとめたものです。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#デプロイの失敗を考える&quot; id=&quot;markdown-toc-デプロイの失敗を考える&quot;&gt;デプロイの失敗を考える&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#decoupling-deployment-from-releaseデプロイとリリースは分離しよう&quot; id=&quot;markdown-toc-decoupling-deployment-from-releaseデプロイとリリースは分離しよう&quot;&gt;Decoupling deployment from release(デプロイとリリースは分離しよう)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#失敗した時の被ダメージ&quot; id=&quot;markdown-toc-失敗した時の被ダメージ&quot;&gt;失敗した時の「被ダメージ」&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#失敗したときの被ダメージを軽減する&quot; id=&quot;markdown-toc-失敗したときの被ダメージを軽減する&quot;&gt;失敗したときの被ダメージを「軽減」する&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#一度にリリースする量を減らす&quot; id=&quot;markdown-toc-一度にリリースする量を減らす&quot;&gt;一度にリリースする量を減らす&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#decoupling-improvement-from-feature改善とフィーチャーは分離しよう&quot; id=&quot;markdown-toc-decoupling-improvement-from-feature改善とフィーチャーは分離しよう&quot;&gt;Decoupling improvement from feature(改善とフィーチャーは分離しよう)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#失敗リスクを細分化する&quot; id=&quot;markdown-toc-失敗リスクを細分化する&quot;&gt;失敗リスクを細分化する&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;デプロイの失敗を考える&quot;&gt;デプロイの失敗を考える&lt;/h2&gt;
&lt;h3 id=&quot;decoupling-deployment-from-releaseデプロイとリリースは分離しよう&quot;&gt;Decoupling deployment from release(デプロイとリリースは分離しよう)&lt;/h3&gt;

&lt;p&gt;かつて、Technology Readerのtechniquesに &lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/decoupling-deployment-from-release&quot;&gt;Decoupling deployment from release&lt;/a&gt; というものが紹介されていました。
これは、ITの現場で「商用作業」または「本番リリース」と言われている作業を2つのプロセスに分割して行うことを提案しています。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;商用環境へのシステムの展開(デプロイ)&lt;/li&gt;
  &lt;li&gt;デプロイされたシステムをサービスインさせる(リリース)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;デプロイしてもエンドユーザに成果物は提供されません。リリースして初めて利用可能になります。
つまり、リリースしない限りはビジネスに与える影響がないのです。デプロイ後に成果物の動作確認をし、問題があれば切り戻せば良いのです。&lt;/p&gt;

&lt;p&gt;これはビジネス上のリスクを軽減するための方法としてとても画期的な発想で、私もプロダクト開発に携わる時には可能な限り &lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/decoupling-deployment-from-release&quot;&gt;Decoupling deployment from release&lt;/a&gt; ができるシステム構成やデプロイメント基盤の構築を心がけています。&lt;/p&gt;

&lt;p&gt;チームのメンバーにも「デプロイ」と「リリース」という単語を明確に意味を分けて使うようにお願いしているし、彼らも納得してそうしてくれているので有り難い限りです。&lt;/p&gt;

&lt;p&gt;エンジニアが「自分の行っている行為がビジネスラインに与える影響」を意識するのはとても良いことで、
単にビジネスインパクトといっても、&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「新しいfeatureを提供する」というポジティブなビジネスインパクト&lt;/strong&gt; もあれば、&lt;br /&gt;
&lt;strong&gt;「システム障害」「セキュリティインシデント」のようなネガティブなビジネスインパクト&lt;/strong&gt; もありますから、&lt;/p&gt;

&lt;p&gt;ポジティブなものは「どうやって最大化するか」を、ネガティブなものは「どうやって最小化するか」を
考えながら仕事をするのはエンジニア冥利に尽きるわけです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/decoupling-deployment-from-release&quot;&gt;Decoupling deployment from release&lt;/a&gt; はどちらかと言えば後者の、ネガティブなビジネスインパクトを軽減するためのテクニックに分類できると私は理解しています。&lt;/p&gt;

&lt;h3 id=&quot;失敗した時の被ダメージ&quot;&gt;失敗した時の「被ダメージ」&lt;/h3&gt;
&lt;p&gt;仮にデプロイ後の動作確認で何らか問題が見つかったとします。&lt;br /&gt;
その場合、サービスされているシステムはそのままに、デプロイしたリソースを切り戻すことになるでしょう。&lt;br /&gt;
問題が発生したリソースは撤収され、ビジネスにネガティブなインパクトを与えることはありませんでした。&lt;/p&gt;

&lt;p&gt;あー良かった良かった。&lt;/p&gt;

&lt;p&gt;…本当にそうなのでしょうか？&lt;/p&gt;

&lt;p&gt;もし、今回リリースする成果物のfeatureが&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;プレスリリースを打っていたら？&lt;/li&gt;
  &lt;li&gt;法人のお客様に約束をしていたら？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;どうなるでしょうか。&lt;/p&gt;

&lt;p&gt;そうですね。プロダクトにおける重要なマイルストーンを含む場合、「新しいfeatureを提供する」というポジティブなビジネスインパクトを妨げる &lt;strong&gt;機会損失&lt;/strong&gt; というネガティブなビジネスインパクトを与えているはずです。&lt;/p&gt;

&lt;p&gt;優れたアジャイル開発チームであれば「&lt;a href=&quot;https://matome.naver.jp/odai/2133468389280396901&quot;&gt;顧客が本当に必要だったもの&lt;/a&gt;」
を肌でも感じていますが、&lt;strong&gt;取り組むべき価値のあるfeatureから順次提供している&lt;/strong&gt; はずです。この観点を踏まえると、「マイルストン通りfeatureを提供できないこと」は「重度のシステム障害が起こる」よりはマシですが、問題に変わりはありません。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
&lt;a target=&quot;_blank&quot; href=&quot;https://www.amazon.co.jp/gp/offer-listing/4873117321/ref=as_li_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=1211&amp;amp;creativeASIN=4873117321&amp;amp;linkCode=am2&amp;amp;tag=soudegesu-22&amp;amp;linkId=ca20d76273c1a09d878e5bd16acf1f2e&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;amp;MarketPlace=JP&amp;amp;ASIN=4873117321&amp;amp;ServiceVersion=20070822&amp;amp;ID=AsinImage&amp;amp;WS=1&amp;amp;Format=_SL250_&amp;amp;tag=soudegesu-22&quot; /&gt;&lt;/a&gt;&lt;img src=&quot;//ir-jp.amazon-adsystem.com/e/ir?t=soudegesu-22&amp;amp;l=am2&amp;amp;o=9&amp;amp;a=4873117321&quot; width=&quot;1&quot; height=&quot;1&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;border:none !important; margin:0px !important;&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;失敗したときの被ダメージを軽減する&quot;&gt;失敗したときの被ダメージを「軽減」する&lt;/h2&gt;

&lt;p&gt;結局、エンジニアは自分の置かれた環境と判断材料を基にして &lt;strong&gt;リスクの発生のしやすさ&lt;/strong&gt; と &lt;strong&gt;顕在化した時の被ダメージ&lt;/strong&gt; を頭の片隅において仕事をしているのです。
先程の例は更に突き詰めていくと、 &lt;strong&gt;「デプロイ作業の工数が無駄になった」&lt;/strong&gt; とか、会社によっては &lt;strong&gt;「障害報告の工数が発生した」&lt;/strong&gt; みたいな人件費の話も出てきて、&lt;strong&gt;失敗による被ダメージは「軽減する」ことしかできない&lt;/strong&gt; ことが伺えます。&lt;/p&gt;

&lt;p&gt;ではダメージを軽減するにはどうするか。いくつかのヒントを以下に書きます。&lt;/p&gt;

&lt;h3 id=&quot;一度にリリースする量を減らす&quot;&gt;一度にリリースする量を減らす&lt;/h3&gt;

&lt;p&gt;1回にリリースする成果物の量(バッチサイズ)を減らすことです。featureを2つも3つも入れないことです。
例えば、3つのfeatureのうち1つ問題があったら、もれなく3つ分の機会損失が発生します。
そのため、リリース可能な1つずつのfeatureをシリアルに提供し、シリアルになる分、短いサイクルで提供するのです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180416/separate.png&quot; alt=&quot;separate&quot; /&gt;&lt;/p&gt;

&lt;p&gt;これはDevOps界隈でもフィードバックループを循環させる方法としてよく聞きます。&lt;/p&gt;

&lt;h3 id=&quot;decoupling-improvement-from-feature改善とフィーチャーは分離しよう&quot;&gt;Decoupling improvement from feature(改善とフィーチャーは分離しよう)&lt;/h3&gt;

&lt;p&gt;バッチサイズを調整するという観点で、リリースされる成果物の性質にも目を向けてみます。
「&lt;strong&gt;その成果物自体にビジネスインパクトがあるかどうか&lt;/strong&gt;」 という判断軸で分割してみましょう。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ポジティブなビジネスインパクトを与える
    &lt;ul&gt;
      &lt;li&gt;プロダクトにおけるfeature&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;直接的なビジネスインパクトをもたらさない
    &lt;ul&gt;
      &lt;li&gt;セキュリティパッチ適用&lt;/li&gt;
      &lt;li&gt;ライブラリバージョンアップ&lt;/li&gt;
      &lt;li&gt;OS差し替え&lt;/li&gt;
      &lt;li&gt;システム構成変更&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ここで言いたいのは、「いわゆる&lt;strong&gt;feature&lt;/strong&gt;と、いわゆる&lt;strong&gt;システム改善&lt;/strong&gt;はリリースタイミングを分割した方が良い」ということです。
なぜならば、システム改善のデプロイに失敗して切り戻したとしても、既に提供されているfeatureには影響を出さずに済むからです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180416/os_patch.png&quot; alt=&quot;os_patch&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;失敗リスクを細分化する&quot;&gt;失敗リスクを細分化する&lt;/h2&gt;

&lt;p&gt;Decoupling improvement from feature のような考え方でリリース物に色分けをすると、リスクの分散構造が理解しやすくなるという副産物があります。
例えば、 &lt;strong&gt;feature開発のために、ライブラリをこっそりバージョンアップしてしまう現象&lt;/strong&gt; は現場でよく見かけます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180416/feature_stone.png&quot; alt=&quot;feature_stone&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ライブラリのバージョンアップ自体は改善アイテムに分類することができ、 &lt;strong&gt;個別のタイミングでデプロイすべき&lt;/strong&gt; なのです。
(時系列的にはfeatureの前にデプロイされているべきです)&lt;/p&gt;

&lt;p&gt;デプロイを分割することによって、featureのリリースを行う時点では、既にライブラリのバージョンアップやDBマイグレーションは成功しているので、これらの失敗リスクを加味する必要がなくなります。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;継続的デリバリを安定して行うための考え方をまとめました。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;デプロイとリリースのプロセスは分ける&lt;/li&gt;
  &lt;li&gt;一回のリリース物のサイズを小さくする&lt;/li&gt;
  &lt;li&gt;「直接的なビジネスインパクトがあるかどうか」という判断軸でリリース物を分割するのもアリ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小さな変化を積み重ねることで、最終的には大きな変更を成し遂げることができると考えています。&lt;/p&gt;

&lt;p&gt;今後の個人的なタスクとしては &lt;code class=&quot;highlighter-rouge&quot;&gt;Springbootの1.5→2.x系へのバージョンアップ&lt;/code&gt; や、&lt;code class=&quot;highlighter-rouge&quot;&gt;Amazon Linux → Amazon Linux2&lt;/code&gt;への移行、&lt;code class=&quot;highlighter-rouge&quot;&gt;Java 11以降へのマイグレーション&lt;/code&gt; といったイベントが目白押しなので、意識しながら作業していきたいです。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
&lt;a target=&quot;_blank&quot; href=&quot;https://www.amazon.co.jp/gp/offer-listing/4873118352/ref=as_li_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=1211&amp;amp;creativeASIN=4873118352&amp;amp;linkCode=am2&amp;amp;tag=soudegesu-22&amp;amp;linkId=e1b8ecca6e0185cd2701dc949c301805&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;amp;MarketPlace=JP&amp;amp;ASIN=4873118352&amp;amp;ServiceVersion=20070822&amp;amp;ID=AsinImage&amp;amp;WS=1&amp;amp;Format=_SL250_&amp;amp;tag=soudegesu-22&quot; /&gt;&lt;/a&gt;&lt;img src=&quot;//ir-jp.amazon-adsystem.com/e/ir?t=soudegesu-22&amp;amp;l=am2&amp;amp;o=9&amp;amp;a=4873118352&quot; width=&quot;1&quot; height=&quot;1&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;border:none !important; margin:0px !important;&quot; /&gt;
&lt;/div&gt;</content><author><name>soudegesu</name></author><category term="continuous-delivery" /><category term="agile" /><summary type="html">継続的デリバリ(Continuous Delivery)はITの現場で一般的なものと浸透してきました。 継続的デリバリを実現するためには、継続的インテグレーションの仕組みと 再現性のあるデプロイメントパイプライン基盤の整備が必要です。 これにより出荷可能なプロダクトを頻繁にリリースすることが可能になります。 今回は頻繁にリリース可能な環境下において、より安全にサービスをデリバリするための個人的な考えをまとめたものです。</summary></entry><entry><title type="html">クロスアカウントで共有されたS3バケットはAWSコンソール上から参照可能なのか</title><link href="https://www.soudegesu.com/aws/s3-cross-account/" rel="alternate" type="text/html" title="クロスアカウントで共有されたS3バケットはAWSコンソール上から参照可能なのか" /><published>2018-04-13T00:00:00+09:00</published><updated>2018-04-13T00:00:00+09:00</updated><id>https://www.soudegesu.com/aws/s3-cross-account</id><content type="html" xml:base="https://www.soudegesu.com/aws/s3-cross-account/">&lt;p&gt;AWS S3はバケットポリシーを設定することで、クロスアカウントでのバケット共有ができます。
設定により、複数のアカウントからバケットに対して操作を行うことができるため、大変便利な機能です。
しかし、バケットのオーナーアカウントではAWSコンソール上でバケットを確認できるのですが、
共有された側ではS3バケットのコンソールにバケットが表示されません。
今回はなんとかして閲覧する方法はないものかと試行錯誤してみました。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#やりたいこと&quot; id=&quot;markdown-toc-やりたいこと&quot;&gt;やりたいこと&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#s3をファイルストレージサービス的にファイル共有に使いたい&quot; id=&quot;markdown-toc-s3をファイルストレージサービス的にファイル共有に使いたい&quot;&gt;S3をファイルストレージサービス的にファイル共有に使いたい&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#でもバケットのあるawsアカウントにログインさせたくない&quot; id=&quot;markdown-toc-でもバケットのあるawsアカウントにログインさせたくない&quot;&gt;でもバケットのあるAWSアカウントにログインさせたくない&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#課題&quot; id=&quot;markdown-toc-課題&quot;&gt;課題&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ユーザはブラウザしか使えない&quot; id=&quot;markdown-toc-ユーザはブラウザしか使えない&quot;&gt;ユーザはブラウザしか使えない&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#コンソール上のバケットリストはバケットのオーナーアカウント側でしか見れない&quot; id=&quot;markdown-toc-コンソール上のバケットリストはバケットのオーナーアカウント側でしか見れない&quot;&gt;コンソール上のバケットリストはバケットのオーナーアカウント側でしか見れない&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#案1-バケットのurlを直接叩かせる非公式&quot; id=&quot;markdown-toc-案1-バケットのurlを直接叩かせる非公式&quot;&gt;案1 バケットのURLを直接叩かせる[非公式]&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#案2-switch-roleを使う正攻法&quot; id=&quot;markdown-toc-案2-switch-roleを使う正攻法&quot;&gt;案2 Switch Roleを使う[正攻法]&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;やりたいこと&quot;&gt;やりたいこと&lt;/h2&gt;
&lt;h3 id=&quot;s3をファイルストレージサービス的にファイル共有に使いたい&quot;&gt;S3をファイルストレージサービス的にファイル共有に使いたい&lt;/h3&gt;

&lt;p&gt;今回やろうとしていたことを簡単に説明します。
以下の図にまとめました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180413/share_bucket.png&quot; alt=&quot;share_bucket&quot; /&gt;&lt;/p&gt;

&lt;p&gt;既に本番環境で稼働しているサービスがあり(アカウントA)、
アカウントA内にあるS3バケットにストアしているデータを他部門に提供する必要が出てきました。&lt;/p&gt;

&lt;h3 id=&quot;でもバケットのあるawsアカウントにログインさせたくない&quot;&gt;でもバケットのあるAWSアカウントにログインさせたくない&lt;/h3&gt;
&lt;p&gt;普通に考えれば、アカウントAで他部門向けのIAM GroupとIAM Userを作成する、というのが簡易な解になるのですが、少し事情があります。
アカウントA自体が社内のセキュリティレベルが高めに規定されているため、他部門のIAM UserをアカウントAの中に作るのが難しいのです。
そのため、 他部門向けの &lt;strong&gt;別のAWSアカウントBを作成し、アカウントBに対して対象のバケットのみを共有するようにすれば要求が充足されるのではないか&lt;/strong&gt;、という話になり、その方法を中心に検討をすることになりました。&lt;/p&gt;

&lt;h2 id=&quot;課題&quot;&gt;課題&lt;/h2&gt;
&lt;h3 id=&quot;ユーザはブラウザしか使えない&quot;&gt;ユーザはブラウザしか使えない&lt;/h3&gt;

&lt;p&gt;今回のケースでは他部門の人間がエンジニアではないため、&lt;strong&gt;ブラウザでのファイルダウンロードしかできない&lt;/strong&gt; という制約がありました。 
AWS CLIのインストールも嫌がられてしまったため、 &lt;strong&gt;「AWSのS3コンソールからファイルを見せる」&lt;/strong&gt; 必要がありました。&lt;/p&gt;

&lt;h3 id=&quot;コンソール上のバケットリストはバケットのオーナーアカウント側でしか見れない&quot;&gt;コンソール上のバケットリストはバケットのオーナーアカウント側でしか見れない&lt;/h3&gt;

&lt;p&gt;アカウントAで &lt;code class=&quot;highlighter-rouge&quot;&gt;soudegesu-bucket-foo&lt;/code&gt; というS3バケットを作成し、以下のようにバケットポリシーを作成することで
アカウントBにバケット共有の設定をしました。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;Version&quot;: &quot;2012-10-17&quot;,
    &quot;Statement&quot;: [
        {
            &quot;Sid&quot;: &quot;GetObject&quot;,
            &quot;Action&quot;: [
                &quot;s3:GetObject&quot;
            ],
            &quot;Effect&quot;: &quot;Allow&quot;,
            &quot;Resource&quot;: &quot;arn:aws:s3:::soudegesu-bucket-foo/*&quot;,
            &quot;Principal&quot;: {
                &quot;AWS&quot;: [
                    &quot;アカウントBのAWSアカウントID&quot;
                ]
            }
        },
        {
            &quot;Sid&quot;: &quot;ListBucket&quot;,
            &quot;Action&quot;: [
                &quot;s3:ListBucket&quot;
            ],
            &quot;Effect&quot;: &quot;Allow&quot;,
            &quot;Resource&quot;: &quot;arn:aws:s3:::soudegesu-bucket-foo&quot;,
            &quot;Principal&quot;: {
                &quot;AWS&quot;: [
                    &quot;アカウントBのAWSアカウントID&quot;
                ]
            }
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;アカウントAのS3コンソールからは共有対象のバケットを確認できるのですが、&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180413/account_a_bucket_list.png&quot; alt=&quot;account_a_bucket_list&quot; /&gt;&lt;/p&gt;

&lt;p&gt;アカウントBでのS3コンソールから共有されたバケットを確認できないのです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180413/account_b_bucket_list.png&quot; alt=&quot;account_b_bucket_list&quot; /&gt;&lt;/p&gt;

&lt;p&gt;実は &lt;strong&gt;S3のバケットリストはバケットを作成したオーナー側にしか表示されない&lt;/strong&gt; というAWSのS3の仕様があります。
これは AWS CLIでも同様で、 &lt;code class=&quot;highlighter-rouge&quot;&gt;aws s3 ls&lt;/code&gt; コマンドを実行しても、自分のアカウントで作成されたバケットの一覧しか取得できません。&lt;/p&gt;

&lt;p&gt;なんてこったい。&lt;/p&gt;

&lt;h3 id=&quot;案1-バケットのurlを直接叩かせる非公式&quot;&gt;案1 バケットのURLを直接叩かせる[非公式]&lt;/h3&gt;

&lt;p&gt;一瞬「やばい」と思いましたが、どうにかなりそうな方法が見つかりました。
それは &lt;strong&gt;共有バケットのURLを直接をブラウザに入力する&lt;/strong&gt; という方法です。&lt;/p&gt;

&lt;p&gt;AWSコンソール上のS3のURLのルールは以下のようになっていて、
AWSコンソールにログインしたセッション上で直叩きするとブラウザ上で表示することができます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://s3.console.aws.amazon.com/s3/buckets/{バケット名}/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;今回の例で言えば、AWSアカウントBにログインした状態で下のURLを直叩きします。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://s3.console.aws.amazon.com/s3/buckets/soudegesu-bucket-foo/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180413/find_bucket_b.png&quot; alt=&quot;find_bucket&quot; /&gt;&lt;/p&gt;

&lt;p&gt;見えました。やったぜ。&lt;/p&gt;

&lt;p&gt;ただし、この方法は現時点(2018年4月現在)でのS3コンソールの仕様ということらしく、公式でサポートされている仕様ではありません。
一応AWSのサポートにも聞いてみましたが、結果的に見えているけど、今後変わるかもしれない、ということでした。&lt;/p&gt;

&lt;h3 id=&quot;案2-switch-roleを使う正攻法&quot;&gt;案2 Switch Roleを使う[正攻法]&lt;/h3&gt;

&lt;p&gt;結局、マルチアカウント間でコンソール上でいい感じに見せたい場合の正攻法はSwitch Roleになりそうです。
Switch Roleを使ったアカウントの切り替えは記事にされている方がいっぱいいらっしゃるのでそちらを参考にいただいた方が良いです。&lt;/p&gt;

&lt;p&gt;参考までにいくつかリンクを貼っておきます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://qiita.com/yoshidashingo/items/d13a9b17f111d5d91a2e&quot;&gt;Swith Roleで複数のAWSアカウント間を切替える&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ja_jp/IAM/latest/UserGuide/id_roles_use_switch-role-console.html&quot;&gt;ロールの切り替え（AWS マネジメントコンソール）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;「クロスアカウントで共有されたS3バケットはAWSコンソール上から閲覧可能なのか」&lt;/strong&gt; というタイトルで今回書きましたが、
結論を言うと&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可能&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;しかし、以下の条件を知っておく必要がありそうです。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;共有されたバケットがS3コンソールのバケット一覧で参照可能なのは&lt;strong&gt;バケットのオーナーアカウント&lt;/strong&gt;のみ&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;バケットのURLを直接入力する&lt;/strong&gt;ことで、共有先のアカウントでもブラウザ上で確認ができる&lt;/li&gt;
  &lt;li&gt;ただし、URL直接入力の方法は公式サポートされていないので、真面目にやるならSwitch Roleで対応する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回はURLを直接入力する方法で大丈夫そうだったので、よかったよかった。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
&lt;a target=&quot;_blank&quot; href=&quot;https://www.amazon.co.jp/gp/offer-listing/4797392568/ref=as_li_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=1211&amp;amp;creativeASIN=4797392568&amp;amp;linkCode=am2&amp;amp;tag=soudegesu-22&amp;amp;linkId=2317c39300679077409ccb55e8076219&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;amp;MarketPlace=JP&amp;amp;ASIN=4797392568&amp;amp;ServiceVersion=20070822&amp;amp;ID=AsinImage&amp;amp;WS=1&amp;amp;Format=_SL250_&amp;amp;tag=soudegesu-22&quot; /&gt;&lt;/a&gt;&lt;img src=&quot;//ir-jp.amazon-adsystem.com/e/ir?t=soudegesu-22&amp;amp;l=am2&amp;amp;o=9&amp;amp;a=4797392568&quot; width=&quot;1&quot; height=&quot;1&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;border:none !important; margin:0px !important;&quot; /&gt;
&lt;/div&gt;</content><author><name>soudegesu</name></author><category term="aws" /><category term="s3" /><summary type="html">AWS S3はバケットポリシーを設定することで、クロスアカウントでのバケット共有ができます。 設定により、複数のアカウントからバケットに対して操作を行うことができるため、大変便利な機能です。 しかし、バケットのオーナーアカウントではAWSコンソール上でバケットを確認できるのですが、 共有された側ではS3バケットのコンソールにバケットが表示されません。 今回はなんとかして閲覧する方法はないものかと試行錯誤してみました。</summary></entry><entry><title type="html">AWS LambdaのコードをTerraformでデプロイする</title><link href="https://www.soudegesu.com/aws/deploy-lambda-with-terraform/" rel="alternate" type="text/html" title="AWS LambdaのコードをTerraformでデプロイする" /><published>2018-04-11T00:00:00+09:00</published><updated>2018-04-11T00:00:00+09:00</updated><id>https://www.soudegesu.com/aws/deploy-lambda-with-terraform</id><content type="html" xml:base="https://www.soudegesu.com/aws/deploy-lambda-with-terraform/">&lt;p&gt;今更感もありますが、今日はTerraformでのAWS Lambdaのコード化について書きます。
AWS Lambdaは &lt;a href=&quot;https://aws.amazon.com/jp/cloud9/&quot;&gt;Cloud9&lt;/a&gt; がコンソール上に組み込まれたこともあり、開発がさらに容易になりました。
ブラウザエディタは &lt;strong&gt;そのままwebにつながる&lt;/strong&gt; というのが最大の強みですが、まだまだ手元のリポジトリでコードを管理している手前、AWSのサービスだけで完結できていないのが現状です。
今回はAWS LambdaのコードをTerraformを使ってデプロイする方法を説明しようと思います。&lt;/p&gt;

&lt;p&gt;↓ちなみに下が組み込まれたCloud9&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180411/cloud9_lambda.png&quot; alt=&quot;cloud9_lambda&quot; /&gt;&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#terraformでaws-lambdaをデプロイしたい&quot; id=&quot;markdown-toc-terraformでaws-lambdaをデプロイしたい&quot;&gt;TerraformでAWS Lambdaをデプロイしたい&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#やってみる&quot; id=&quot;markdown-toc-やってみる&quot;&gt;やってみる&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#コードのエントリータイプはzipにしよう&quot; id=&quot;markdown-toc-コードのエントリータイプはzipにしよう&quot;&gt;コードのエントリータイプはzipにしよう&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#シェルでzip圧縮したいソース一式を作成する&quot; id=&quot;markdown-toc-シェルでzip圧縮したいソース一式を作成する&quot;&gt;シェルでzip圧縮したいソース一式を作成する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#terraformでzip圧縮デプロイ&quot; id=&quot;markdown-toc-terraformでzip圧縮デプロイ&quot;&gt;Terraformでzip圧縮&amp;amp;デプロイ&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ビルドデプロイをつなげる&quot; id=&quot;markdown-toc-ビルドデプロイをつなげる&quot;&gt;ビルド&amp;amp;デプロイをつなげる&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考にさせていただいたサイト&quot; id=&quot;markdown-toc-参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;terraformでaws-lambdaをデプロイしたい&quot;&gt;TerraformでAWS Lambdaをデプロイしたい&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Infrastructure as Code&lt;/code&gt; はクラウド界隈でバズってだいぶ時間も立っていますので、あまりここでは触れません。
必要に応じて界隈の方のブログや以下の書籍を読んでください。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: center&quot;&gt;
&lt;a target=&quot;_blank&quot; href=&quot;https://www.amazon.co.jp/gp/offer-listing/4873117968/ref=as_li_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=1211&amp;amp;creativeASIN=4873117968&amp;amp;linkCode=am2&amp;amp;tag=soudegesu-22&amp;amp;linkId=e5283797d3bbc22eb4a74f9cee8af948&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;amp;MarketPlace=JP&amp;amp;ASIN=4873117968&amp;amp;ServiceVersion=20070822&amp;amp;ID=AsinImage&amp;amp;WS=1&amp;amp;Format=_SL250_&amp;amp;tag=soudegesu-22&quot; /&gt;&lt;/a&gt;&lt;img src=&quot;//ir-jp.amazon-adsystem.com/e/ir?t=soudegesu-22&amp;amp;l=am2&amp;amp;o=9&amp;amp;a=4873117968&quot; width=&quot;1&quot; height=&quot;1&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;border:none !important; margin:0px !important;&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;AWS Lambdaがサービスとして登場した頃は、簡易なバッチ的な仕組みとしての用途が多く、作り捨てなコードが多かったです。
その後、連携可能な他のAWSサービスも増えて、VPC内に立ち上げることも可能になり(起動時間はかなり遅いですけど)、用途の幅に広がりが出てきました。
そんな &lt;strong&gt;「まぁ、Lambdaでいっか」&lt;/strong&gt; ケースが増えると同時に、一度デプロイしたLambdaのコードを修正して再デプロイするというケースも増えてきました。&lt;/p&gt;

&lt;p&gt;業務上 &lt;code class=&quot;highlighter-rouge&quot;&gt;Terraform&lt;/code&gt; を使ってAWSリソースをコード化しているので、Lambdaもその管理の対象にしようと思ったのが契機です。&lt;/p&gt;

&lt;h2 id=&quot;やってみる&quot;&gt;やってみる&lt;/h2&gt;

&lt;p&gt;実際にLambdaをTerraformでデプロイするコード化してみました。
コードサンプルは &lt;a href=&quot;https://github.com/soudegesu/terraform-lambda-practice&quot;&gt;こちら&lt;/a&gt; にあります。&lt;/p&gt;

&lt;p&gt;簡単にリポジトリの説明をしておきます。&lt;/p&gt;

&lt;p&gt;デプロイ用のマシンに必要なライブラリ等は以下になります。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Terraform&lt;/li&gt;
  &lt;li&gt;Python 3.6&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;またディレクトリ構成はこんな感じです。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── Makefile
├── README.md
├── build.sh
├── lambda-src
│   ├── __init__.py
│   └── main.py
├── requirements.txt
└── terraform
    ├── backend.tf
    ├── dev.tfvars
    ├── lambda.tf
    ├── provider.tf
    └── variables.tf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lambda-src&lt;/code&gt; ディレクトリにはLambdaで実行するPythonコード、 &lt;code class=&quot;highlighter-rouge&quot;&gt;terraform&lt;/code&gt; ディレクトリにはLmabdaのデプロイに使用するterraformの設定が格納されています。
めんどい前処理の類はシェル(&lt;code class=&quot;highlighter-rouge&quot;&gt;build.sh&lt;/code&gt;)でラップしてあって、開発者は &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; のサブコマンドだけ意識しておけば良い、という作りにしています。
この方法自体は我流なので、よりスマートな方法はあると思います。&lt;/p&gt;

&lt;p&gt;以降は実装する上でのポイントだけ記載していきます。&lt;/p&gt;

&lt;h3 id=&quot;コードのエントリータイプはzipにしよう&quot;&gt;コードのエントリータイプはzipにしよう&lt;/h3&gt;

&lt;p&gt;Lambdaにソースコードを適用する方法は3種類存在します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180411/type_of_code_entry.png&quot; alt=&quot;code_entry_type&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Edit Code Inline
    &lt;ul&gt;
      &lt;li&gt;ブラウザ上のエディタに直接書く方法。デプロイ後のコードを突貫で修正したりする時によく使う。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Upload a .ZIP file
    &lt;ul&gt;
      &lt;li&gt;zipファイルでアップロードする方法。今回はこれを採用する。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Uplaod a file from Amazon S3
    &lt;ul&gt;
      &lt;li&gt;S3からファイルを読み込む方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;個人的には2番目の &lt;strong&gt;zipファイルでアップロードする方法&lt;/strong&gt; をオススメします。&lt;/p&gt;

&lt;p&gt;理由としては以下&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;依存モジュールを含めてアップロードできる&lt;/li&gt;
  &lt;li&gt;わざわざS3を積極的に経由するケースが思いつかない。(Lambdaに対して直接操作できない時とか？)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;シェルでzip圧縮したいソース一式を作成する&quot;&gt;シェルでzip圧縮したいソース一式を作成する&lt;/h3&gt;

&lt;p&gt;シェルを使えば何でもできてしまうので、Terraformで完結させたい方には興ざめかもしれませんが、低コストだったのでこれにしました。
&lt;code class=&quot;highlighter-rouge&quot;&gt;build.sh&lt;/code&gt; の処理を見ていただければわかるのですが、 zip圧縮させたいファイル郡を管理する必要があるので、
専用の &lt;code class=&quot;highlighter-rouge&quot;&gt;workspace&lt;/code&gt; ディレクリを作成し、そこに依存モジュールとソースコードをまるごと放り込みます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;build.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env bash&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;SCRIPT_DIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;dirname &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;WORKSPACE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SCRIPT_DIR&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/workspace
&lt;span class=&quot;nv&quot;&gt;SRC_DIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SCRIPT_DIR&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/lambda-src

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WORKSPACE&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;rm &lt;span class=&quot;nt&quot;&gt;-rf&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WORKSPACE&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fi
&lt;/span&gt;mkdir &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WORKSPACE&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;

pip3 install &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SCRIPT_DIR&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/requirements.txt &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WORKSPACE&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
cp &lt;span class=&quot;nt&quot;&gt;-rf&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SRC_DIR&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WORKSPACE&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;terraformでzip圧縮デプロイ&quot;&gt;Terraformでzip圧縮&amp;amp;デプロイ&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;workspace&lt;/code&gt; ディレクトリのzip圧縮とデプロイを定義します。
terraformで &lt;code class=&quot;highlighter-rouge&quot;&gt;archive_file&lt;/code&gt; というデータリソースを使用することで、指定されたディレクトリをzip圧縮して出力することができます。
加えて、Lambda関数の作成の際に &lt;code class=&quot;highlighter-rouge&quot;&gt;aws_lambda_function&lt;/code&gt; リソースの &lt;code class=&quot;highlighter-rouge&quot;&gt;source_code_hash&lt;/code&gt; プロパティに、zipアーカイブしたデータリソースのbase64エンコードを指定することができるので、これでzipのデプロイコードの完成です。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#####################################
#Lambda
#####################################
resource &quot;aws_lambda_function&quot; &quot;auth_log_monitoring&quot; {
    filename = &quot;../lambda.zip&quot;
    function_name = &quot;do_something&quot;
    role = &quot;arn:aws:iam::${var.account_id}:role/XXXXXXRole&quot;
    handler = &quot;main.lambda_handler&quot;
    source_code_hash = &quot;${data.archive_file.lambda_zip.output_base64sha256}&quot;
    runtime = &quot;python3.6&quot;
    timeout = 150
}

data &quot;archive_file&quot; &quot;lambda_zip&quot; {
    type = &quot;zip&quot;
    source_dir  = &quot;../workspace&quot;
    output_path = &quot;../lambda.zip&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;ビルドデプロイをつなげる&quot;&gt;ビルド&amp;amp;デプロイをつなげる&lt;/h3&gt;
&lt;p&gt;あとは &lt;code class=&quot;highlighter-rouge&quot;&gt;build.sh&lt;/code&gt; でのビルド処理とterraformでのデプロイをつなげてあげればOKです。
今回は &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt; に以下のような定義をして、コマンド一発で処理ができるようにラップしています。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deploy:
	@${CD} &amp;amp;&amp;amp; \
		sh ../build.sh &amp;amp;&amp;amp; \
		terraform workspace select ${ENV} &amp;amp;&amp;amp; \
		terraform apply \
        -var-file=${VARS}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;あとは &lt;code class=&quot;highlighter-rouge&quot;&gt;make deploy&lt;/code&gt; を打てば実行できます。(リポジトリ的にはterraformのリモートバケットの初期化を先に行う必要はあります。)&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;Terraformを使用して、AWS Lambdaのソースコードのデプロイができるようになりました。
実際にはシェルを間にかませてビルドを行なっていますが、シェル内での処理自体はシンプルなので、横展開もしやすくなっています。
1点欠点としては、&lt;strong&gt;ランタイムがpythonの場合にはterraform実行時に毎回ハッシュにdiffが出てしまう&lt;/strong&gt; という点。つまり、毎度デプロイしてしまうという所です。
しかし、今あるコードを正としてデプロイし続けることに問題がなければ、目をつむっても良い欠点なので、今の所気にしていません。
ちなみにランタイムがNodeだとこれはおきませんでした。&lt;/p&gt;

&lt;h2 id=&quot;参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.terraform.io/docs/providers/aws/r/lambda_function.html&quot;&gt;Terraform:aws_lambda_function&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: center&quot;&gt;
&lt;a target=&quot;_blank&quot; href=&quot;https://www.amazon.co.jp/gp/offer-listing/B06XKHGJHP/ref=as_li_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=1211&amp;amp;creativeASIN=B06XKHGJHP&amp;amp;linkCode=am2&amp;amp;tag=soudegesu-22&amp;amp;linkId=c8ab2870b7378967fbf5fd25ce31da6c&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;amp;MarketPlace=JP&amp;amp;ASIN=B06XKHGJHP&amp;amp;ServiceVersion=20070822&amp;amp;ID=AsinImage&amp;amp;WS=1&amp;amp;Format=_SL250_&amp;amp;tag=soudegesu-22&quot; /&gt;&lt;/a&gt;&lt;img src=&quot;//ir-jp.amazon-adsystem.com/e/ir?t=soudegesu-22&amp;amp;l=am2&amp;amp;o=9&amp;amp;a=B06XKHGJHP&quot; width=&quot;1&quot; height=&quot;1&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;border:none !important; margin:0px !important;&quot; /&gt;
&lt;/div&gt;</content><author><name>soudegesu</name></author><category term="aws" /><category term="lambda" /><category term="terraform" /><summary type="html">今更感もありますが、今日はTerraformでのAWS Lambdaのコード化について書きます。 AWS Lambdaは Cloud9 がコンソール上に組み込まれたこともあり、開発がさらに容易になりました。 ブラウザエディタは そのままwebにつながる というのが最大の強みですが、まだまだ手元のリポジトリでコードを管理している手前、AWSのサービスだけで完結できていないのが現状です。 今回はAWS LambdaのコードをTerraformを使ってデプロイする方法を説明しようと思います。</summary></entry><entry><title type="html">Cloudfront+Lambda@Edgeのサーバレス構成で費用を抑えつつ、動的なWEBコンテンツを作ろう[貧テック]</title><link href="https://www.soudegesu.com/aws/hosting-with-cloudfront-lambda-edge-serverless/" rel="alternate" type="text/html" title="Cloudfront+Lambda@Edgeのサーバレス構成で費用を抑えつつ、動的なWEBコンテンツを作ろう[貧テック]" /><published>2018-04-03T00:00:00+09:00</published><updated>2018-04-03T00:00:00+09:00</updated><id>https://www.soudegesu.com/aws/hosting-with-cloudfront-lambda-edge-serverless</id><content type="html" xml:base="https://www.soudegesu.com/aws/hosting-with-cloudfront-lambda-edge-serverless/">&lt;p&gt;このブログ自体は &lt;code class=&quot;highlighter-rouge&quot;&gt;github-pages&lt;/code&gt; と &lt;code class=&quot;highlighter-rouge&quot;&gt;cloudflare&lt;/code&gt; を使って無料でホスティングをしているのですが、稀に &lt;strong&gt;「動的なwebコンテンツを提供したい」&lt;/strong&gt; と思うことがあります。今回はお金を節約しつつ、動的なwebコンテンツを提供する方法を紹介します。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#モチベーション&quot; id=&quot;markdown-toc-モチベーション&quot;&gt;モチベーション&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#動的なwebコンテンツを作りたい&quot; id=&quot;markdown-toc-動的なwebコンテンツを作りたい&quot;&gt;動的なwebコンテンツを作りたい！&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#問題点アクセスが少ない時期はランニングコストが高くつく&quot; id=&quot;markdown-toc-問題点アクセスが少ない時期はランニングコストが高くつく&quot;&gt;問題点：アクセスが少ない時期はランニングコストが高くつく&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#サーバレスで費用を抑えよう&quot; id=&quot;markdown-toc-サーバレスで費用を抑えよう&quot;&gt;サーバレスで費用を抑えよう&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#案1-cloudfront--lambdaedge&quot; id=&quot;markdown-toc-案1-cloudfront--lambdaedge&quot;&gt;案1 Cloudfront + Lambda@Edge&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#案2-api-gateway--lambda&quot; id=&quot;markdown-toc-案2-api-gateway--lambda&quot;&gt;案2 API Gateway + Lambda&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#案3-gcpのgce-f1-micro-インスタンス&quot; id=&quot;markdown-toc-案3-gcpのgce-f1-micro-インスタンス&quot;&gt;案3 GCPのGCE f1-micro インスタンス&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#awsで構築してみる&quot; id=&quot;markdown-toc-awsで構築してみる&quot;&gt;AWSで構築してみる&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#iam-roleの作成&quot; id=&quot;markdown-toc-iam-roleの作成&quot;&gt;IAM Roleの作成&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ドメインを設定する&quot; id=&quot;markdown-toc-ドメインを設定する&quot;&gt;ドメインを設定する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#certification-managerでssl証明書を取得する&quot; id=&quot;markdown-toc-certification-managerでssl証明書を取得する&quot;&gt;Certification ManagerでSSL証明書を取得する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#lambda関数の作成とpublish&quot; id=&quot;markdown-toc-lambda関数の作成とpublish&quot;&gt;Lambda関数の作成とpublish&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#lambdaedgeはcloudfrontのオリジンリクエスト時に実行させる&quot; id=&quot;markdown-toc-lambdaedgeはcloudfrontのオリジンリクエスト時に実行させる&quot;&gt;Lambda@EdgeはCloudfrontのオリジンリクエスト時に実行させる&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#lambdaedgeからcloudfrontへのレスポンス形式に注意する&quot; id=&quot;markdown-toc-lambdaedgeからcloudfrontへのレスポンス形式に注意する&quot;&gt;Lambda@EdgeからCloudfrontへのレスポンス形式に注意する&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cloudfrontで配信する&quot; id=&quot;markdown-toc-cloudfrontで配信する&quot;&gt;Cloudfrontで配信する&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#lambda関数はpublishして使う&quot; id=&quot;markdown-toc-lambda関数はpublishして使う&quot;&gt;Lambda関数はpublishして使う&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#キャシュクリアをする2回目以降のデプロイ時&quot; id=&quot;markdown-toc-キャシュクリアをする2回目以降のデプロイ時&quot;&gt;キャシュクリアをする(2回目以降のデプロイ時)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考にさせていただいたサイト&quot; id=&quot;markdown-toc-参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;モチベーション&quot;&gt;モチベーション&lt;/h2&gt;
&lt;h3 id=&quot;動的なwebコンテンツを作りたい&quot;&gt;動的なwebコンテンツを作りたい！&lt;/h3&gt;
&lt;p&gt;Google Adsense等を使った広告収入で小遣い稼ぎをしたいと思った場合に、
&lt;code class=&quot;highlighter-rouge&quot;&gt;はてなブログ&lt;/code&gt; のような無料ブログサービスや &lt;code class=&quot;highlighter-rouge&quot;&gt;Github Pages&lt;/code&gt; を利用すると、主に静的ファイルでのコンテンツ配信が中心になります。
1ページあたり1記事を作成する必要があり、1ページあたりの作成コストが高くなるデメリットがあるため、
リクエストパラメータないしはパスパラメータを使ってサーバ側で動的なページ生成を行う機構があれば、
ロングテールでのページのクローリングを狙うことができます。
ちなみに、ロングテールをざっくり説明すると、 &lt;strong&gt;単体の検索ボリュームでは少ないけど、複数カテゴリの検索クエリの組み合わせのバリエーションに対応することで、検索ボリュームの総和に対してリーチする&lt;/strong&gt; 方法です。&lt;/p&gt;

&lt;h3 id=&quot;問題点アクセスが少ない時期はランニングコストが高くつく&quot;&gt;問題点：アクセスが少ない時期はランニングコストが高くつく&lt;/h3&gt;
&lt;p&gt;従来、動的なwebコンテンツを作成しようとする場合、&lt;strong&gt;ページ生成プログラムを動かすためのサーバが必要&lt;/strong&gt; でした。
環境調達の方法としては「レンタルサーバを借りる」のが一般的ですが、バンドルされている &lt;a href=&quot;https://ja.wordpress.org/&quot;&gt;WordPress&lt;/a&gt; で要件が充足されないケースがある場合には、&lt;code class=&quot;highlighter-rouge&quot;&gt;VPS&lt;/code&gt; サービスを契約しなければいけません。
VPSサービスは通常のレンタルサーバよりもランニングコストが少しお高めになってしまいます。&lt;/p&gt;

&lt;p&gt;参考までに2種類のサービス料金を記載しますが、コンテンツ配信のための月額料金がボディブローのようにじわじわ効いてくることが容易に想像できます。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;サービス名&lt;/td&gt;
      &lt;td&gt;月額料金(最低スペック)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tfoot&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://vps.sakura.ad.jp/&quot;&gt;さくらのVPS&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;685JPY/month 〜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://vps.gmocloud.com/&quot;&gt;GMOクラウド&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;780JPY/month 〜&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tfoot&gt;
&lt;/table&gt;

&lt;h3 id=&quot;サーバレスで費用を抑えよう&quot;&gt;サーバレスで費用を抑えよう&lt;/h3&gt;
&lt;p&gt;前提として、&lt;strong&gt;プログラミングに関する知識が必要にはなります&lt;/strong&gt; が、パブリッククラウドを使用することでサーバのランニングコストを抑えることができます。
ざっくりですがパブリッククラウドを用いた構成案と勘案要素を以下にまとめました。いずれの案においても、&lt;strong&gt;最低利用料金 + リクエスト量に応じた従量課金&lt;/strong&gt; というコスト構造になるので、VPSよりも割安なのですが、今回は利便性と最低利用料金のバランスが良い &lt;strong&gt;案1 Cloudfront + Lambda@Edge&lt;/strong&gt; を今回採用しました。&lt;/p&gt;

&lt;h4 id=&quot;案1-cloudfront--lambdaedge&quot;&gt;案1 Cloudfront + Lambda@Edge&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;メリット
    &lt;ul&gt;
      &lt;li&gt;サーバレス&lt;/li&gt;
      &lt;li&gt;CDNキャッシュが効く&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;デメリット
    &lt;ul&gt;
      &lt;li&gt;Lambda@Edgeは無料利用枠がない&lt;/li&gt;
      &lt;li&gt;Node 6.10 しか利用できない&lt;/li&gt;
      &lt;li&gt;その他、通常のLambdaよりも&lt;a href=&quot;https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html#limits-lambda-at-edge&quot;&gt;制限事項が多い&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;案2-api-gateway--lambda&quot;&gt;案2 API Gateway + Lambda&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;メリット
    &lt;ul&gt;
      &lt;li&gt;サーバレス&lt;/li&gt;
      &lt;li&gt;Lambdaがサポートしている複数言語での開発が可能&lt;/li&gt;
      &lt;li&gt;CDNキャッシュが効く&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;デメリット
    &lt;ul&gt;
      &lt;li&gt;API Gatewayの最低利用料金がCloudfrontと比べて高い&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;案3-gcpのgce-f1-micro-インスタンス&quot;&gt;案3 GCPのGCE f1-micro インスタンス&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;メリット
    &lt;ul&gt;
      &lt;li&gt;おそらく利用料金が最も安く抑えられる&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;デメリット
    &lt;ul&gt;
      &lt;li&gt;ロケーションが遠いので、レイテンシが気になる&lt;/li&gt;
      &lt;li&gt;Cloud CDN と組み合わせるとf1-microインスタンス料金無料の旨味が消える&lt;/li&gt;
      &lt;li&gt;インスタンスの設定(ランタイムとかSSL証明書のインストールとか)が必要&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;awsで構築してみる&quot;&gt;AWSで構築してみる&lt;/h2&gt;
&lt;p&gt;以降は案1での構築方法を記載していきます。&lt;/p&gt;

&lt;h3 id=&quot;iam-roleの作成&quot;&gt;IAM Roleの作成&lt;/h3&gt;

&lt;p&gt;Lambdaに付与するIAM Roleを作成します。
まず、以下のようなAssume Role Policy を作成します。
 &lt;code class=&quot;highlighter-rouge&quot;&gt;Lambda&lt;/code&gt; と &lt;code class=&quot;highlighter-rouge&quot;&gt;Lambda@Edge&lt;/code&gt; は別ものとして扱われているため、 &lt;code class=&quot;highlighter-rouge&quot;&gt;edgelambda.amazonaws.com&lt;/code&gt; の記載が必要です。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Sid&quot;: &quot;&quot;,
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Principal&quot;: {
        &quot;Service&quot;: [
          &quot;edgelambda.amazonaws.com&quot;,
          &quot;lambda.amazonaws.com&quot;
        ]
      },
      &quot;Action&quot;: &quot;sts:AssumeRole&quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;作成したPolicyと &lt;code class=&quot;highlighter-rouge&quot;&gt;CloudWatchLogsFullAccess&lt;/code&gt; のポリシーをアタッチしたRoleを作成します。
名前はとりあえず &lt;strong&gt;EdgeLambdaForCloudfrontRole&lt;/strong&gt; としましょう。&lt;/p&gt;

&lt;h3 id=&quot;ドメインを設定する&quot;&gt;ドメインを設定する&lt;/h3&gt;
&lt;p&gt;Cloudfrontのディストリビューションのドメインをそのまま使うわけには行かないので、ドメインを設定します。
個人的にはお金を払い、 &lt;code class=&quot;highlighter-rouge&quot;&gt;.com&lt;/code&gt; や &lt;code class=&quot;highlighter-rouge&quot;&gt;.net&lt;/code&gt; のような信頼のあるドメインを確保することをオススメします。
ドメイン料金も抑えたい方は &lt;strong&gt;「ドメイン 無料」&lt;/strong&gt; で検索すればいくらでも無料ドメインサービスが出てくるので、それを活用してください。&lt;/p&gt;

&lt;p&gt;私が取得しているドメインは &lt;a href=&quot;https://www.cloudflare.com/&quot;&gt;Cloudflare&lt;/a&gt; で管理しているので、
Route53で取得しているドメインのサブドメインのHosted Zoneを作成し、NSレコードをCloudflare上に登録してあげます。&lt;/p&gt;

&lt;h3 id=&quot;certification-managerでssl証明書を取得する&quot;&gt;Certification ManagerでSSL証明書を取得する&lt;/h3&gt;

&lt;p&gt;サブドメインの委譲が正しくできていれば(= Route53上の設定値でDNSが引けるようになれば) Certification Manager を用いてSSL証明書を取得しましょう。
SSL証明書の取得に関してはDNS Validationでやり方をオススメします。 詳しくは以前のポスト &lt;a href=&quot;/aws/validate-certification-manager&quot;&gt;AWS Certification ManagerのSSL証明書の検証にはDNS検証を使った方が良い&lt;/a&gt; を見てみてください。
注意点として、&lt;strong&gt;SSL証明書は us-east-1(Virginia)リージョンで取得する必要があります&lt;/strong&gt; 。
これは「Cloudfrontに適用可能なSSL証明書はVirginiaリージョンで発行されたもののみ」という仕様のためです。&lt;/p&gt;

&lt;h3 id=&quot;lambda関数の作成とpublish&quot;&gt;Lambda関数の作成とpublish&lt;/h3&gt;

&lt;p&gt;次にLambda関数の実装を行います。 &lt;strong&gt;Lambda@EdgeはNode 6.10のみをサポートしているため、Nodeでの実装が必要です&lt;/strong&gt; 。
軽量なwebアプリケーションを作成する手段として、手っ取り早いのは &lt;a href=&quot;https://www.npmjs.com/package/express&quot;&gt;express&lt;/a&gt; を使う方法です。
expressの使い方の説明は割愛しますが、実装時に注意すべき点だけ記載します。&lt;/p&gt;

&lt;h4 id=&quot;lambdaedgeはcloudfrontのオリジンリクエスト時に実行させる&quot;&gt;Lambda@EdgeはCloudfrontのオリジンリクエスト時に実行させる&lt;/h4&gt;

&lt;p&gt;Lambda@EdgeとCloudfrontを連携させる場合に、Lambda@Edgeの実行タイミングを4つのうちから選択することができます。
詳細は&lt;a href=&quot;https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/lambda-cloudfront-trigger-events.html&quot;&gt;開発者ガイド&lt;/a&gt; に記載されています。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CloudFront ビューワーリクエスト
    &lt;ul&gt;
      &lt;li&gt;リクエストをCloudfrontが受ける前にLambda@Edgeが処理をする(Lambda@Edge -&amp;gt; Cloudfront -&amp;gt; Origin)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CloudFront オリジンリクエスト
    &lt;ul&gt;
      &lt;li&gt;リクエストをCloudfrontが受けた後にLambda@Edgeが処理をする(Cloudfront -&amp;gt; Lambda@Edge -&amp;gt; Origin)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CloudFront オリジンレスポンス
    &lt;ul&gt;
      &lt;li&gt;オリジンからのレスポンスをCloudfrontに返却する前にLambda@Edgeが処理をする(Cloudfront &amp;lt;- Lambda@Edge &amp;lt;- Origin)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CloudFront ビューワーのレスポンス
    &lt;ul&gt;
      &lt;li&gt;Cloudfrontがクライアントにレスポンスを返却する前にLambda@Edgeが処理をする(Lambda@Edge &amp;lt;- Cloudfront &amp;lt;- Origin)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CloudFront オリジンリクエスト&lt;/strong&gt; で実行することを選択しましょう。これにより、Originの代わりにLambda@Edgeがレスポンスを返せるようになります。
&lt;code class=&quot;highlighter-rouge&quot;&gt;ビューワーリクエスト&lt;/code&gt; にしてしまうと、CDNのキャッシュが活用できなくなりますし、 &lt;code class=&quot;highlighter-rouge&quot;&gt;オリジンレスポンス&lt;/code&gt; にすると一度リクエストを受けるためのオリジンをS3などで作成しないといけなくなります。&lt;/p&gt;

&lt;h4 id=&quot;lambdaedgeからcloudfrontへのレスポンス形式に注意する&quot;&gt;Lambda@EdgeからCloudfrontへのレスポンス形式に注意する&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;オリジンリクエスト&lt;/code&gt; の場合、Lambda@EdgeからCloudfrontに返却するレスポンスの形式が以下のように定められているため、そちらに準拠する必要があります。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    body: 'content',
    bodyEncoding: 'text' | 'base64',
    headers: {
        'header name in lowercase': [{
            key: 'header name in standard case',
            value: 'header value'
         }],
         ...
    },
    status: 'HTTP status code',
    statusDescription: 'status description'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;これを愚直に実装するのは少々手間がかかるので、 &lt;a href=&quot;https://github.com/jgautheron/aws-serverless-express-edge&quot;&gt;aws-serverless-express-edge&lt;/a&gt; というnpmモジュールを使ってしまうのが早いです。&lt;/p&gt;

&lt;h3 id=&quot;cloudfrontで配信する&quot;&gt;Cloudfrontで配信する&lt;/h3&gt;

&lt;p&gt;最後にCloudfrontの配信設定を行います。Cloudfront自体の使い方は公式のドキュメントを読んでいただければ問題ないので、ここでも注意点にだけ触れておきます。&lt;/p&gt;

&lt;h4 id=&quot;lambda関数はpublishして使う&quot;&gt;Lambda関数はpublishして使う&lt;/h4&gt;

&lt;p&gt;Lambda@EdgeをCloudfrontと連携させる場合、&lt;strong&gt;Lambda関数はpublishしておく必要があります&lt;/strong&gt; 。
Cloudfrontでは実行するLambda@EdgeのARNをバージョン番号込みで指定する必要があり、&lt;code class=&quot;highlighter-rouge&quot;&gt;$LATEST&lt;/code&gt; による指定はサポート外であるため、
Lambda関数の更新の都度バージョンを上げていくスタイルになります。
一番良い方法としてオススメなのは、&lt;a href=&quot;https://www.terraform.io/&quot;&gt;Terraform&lt;/a&gt; を使ってCloudfrontとLambdaのコード化をしてしまうことです。&lt;/p&gt;

&lt;p&gt;Cloudfrontは設定項目が多いためTerraformに書き起こすのに時間がかかりますが、後々の更新コストを加味して早めに対応しておきましょう。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LambdaのTerraformサンプル&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;resource &quot;aws_lambda_function&quot; &quot;hogehoge&quot; {
    filename = &quot;../hogehoge.zip&quot;
    function_name = &quot;hoeghoge&quot;
    publish = true
    role = &quot;${EdgeLambdaForCloudfrontRoleのARN}&quot;
    handler = &quot;index.handler&quot;
    source_code_hash = &quot;${data.archive_file.hogehoge.output_base64sha256}&quot;
    runtime = &quot;nodejs6.10&quot;
    timeout = 30
}

data &quot;archive_file&quot; &quot;hogehoge&quot; {
    type = &quot;zip&quot;
    source_dir  = &quot;../workspace&quot;
    output_path = &quot;../hogehoge.zip&quot;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;CloudfrontのTerraformサンプル&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;resource &quot;aws_cloudfront_distribution&quot; &quot;hogehogefront_cloudfront&quot; {
    origin {
        domain_name = &quot;xxxx.soudegesu.com&quot;
        origin_id   = &quot;Custom-your-xxxx.soudegesu.com&quot;
        custom_origin_config {
            http_port = 80
            https_port = 443
            origin_protocol_policy = &quot;http-only&quot;
            origin_ssl_protocols = [&quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;]
        }
    }
    aliases = [&quot;xxxx.soudegesu.com&quot;]
    enabled = true
    is_ipv6_enabled = true
    comment = &quot;tools distribution&quot;

    default_cache_behavior {
        allowed_methods  = [&quot;GET&quot;, &quot;HEAD&quot;, &quot;OPTIONS&quot;]
        cached_methods   = [&quot;GET&quot;, &quot;HEAD&quot;]
        target_origin_id = &quot;Custom-xxxx.soudegesu.com&quot;

        forwarded_values {
            query_string = false

            cookies {
                forward = &quot;none&quot;
            }
        }

        viewer_protocol_policy = &quot;redirect-to-https&quot;
        min_ttl = 86400
        default_ttl = 604800
        max_ttl = 2592000
        compress = true
        lambda_function_association {
            event_type = &quot;origin-request&quot;
            lambda_arn = &quot;${aws_lambda_function.hogehoge.qualified_arn}&quot;
        }
    }

    viewer_certificate {
        acm_certificate_arn = &quot;${ACMのARN}&quot;
        minimum_protocol_version = &quot;TLSv1.1_2016&quot;
        ssl_support_method = &quot;sni-only&quot;
    }

    restrictions {
        geo_restriction {
            restriction_type = &quot;none&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ポイントなのは Cloudfront側の以下の部分で、&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    lambda_function_association {
        event_type = &quot;origin-request&quot;
        lambda_arn = &quot;${aws_lambda_function.hogehoge.qualified_arn}&quot;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;qualified_arn&lt;/code&gt; を指定すると、バージョン込のフルのARNにて変数展開がされます。
これにより、terraformを実行するだけで、LambdaのデプロイとCloudfrontの更新の両方ができるようになります。&lt;/p&gt;

&lt;h4 id=&quot;キャシュクリアをする2回目以降のデプロイ時&quot;&gt;キャシュクリアをする(2回目以降のデプロイ時)&lt;/h4&gt;

&lt;p&gt;CloudfrontはCDNサービスなので、デプロイ後にキャッシュをクリアして上げた方がよいです。&lt;/p&gt;

&lt;p&gt;AWSコンソールからCloudfrontのInvalidationsのタブを押します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180403/invalidations.png&quot; alt=&quot;invalidations&quot; /&gt;&lt;/p&gt;

&lt;p&gt;全てのURLのキャッシュをクリアしたいので、「*」を指定すればOKです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180403/invalidation_target.png&quot; alt=&quot;invalidation_target&quot; /&gt;&lt;/p&gt;

&lt;p&gt;なお、このキャッシュクリアに関してCloudfrontの料金ページでは、&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;月間で無効をリクエストしたパスの最初の 1,000 パスまでは追加料金なし。それ以降は、無効をリクエストしたパスごとに 0.005 USD かかります。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;と記載されているので、URLのパターンが増えてきたら、削除対象の指定パターンはもう少し工夫した方がいいかもしれません。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回、Cloudfront + Lambda@Edgeを用いてサーバレスでのwebコンテンツを配信する仕組みを構築しました。
実際にサンプルコンテンツを作成してみたのが &lt;a href=&quot;http://www.tools.soudegesu.com/&quot;&gt;こちら&lt;/a&gt; になります。
ブラウザの言語設定の情報を基に &lt;code class=&quot;highlighter-rouge&quot;&gt;ja&lt;/code&gt; か &lt;code class=&quot;highlighter-rouge&quot;&gt;en&lt;/code&gt; かにリダイレクトする機能(俗に言うi18n対応っぽいもの)を実現しています。&lt;/p&gt;

&lt;p&gt;1週間程寝かせてみた後のAWS Billing Dashboardは以下のようになりました。$1到達していないですね。素晴らしい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180403/billing_dashborad.png&quot; alt=&quot;billing dashboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;立ち上げ期のアクセスが少ないコンテンツでは、ランニングコストが大きくならないようにサーバレスで節約していきたいですね！&lt;/p&gt;

&lt;h2 id=&quot;参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/lambda-generating-http-responses.html&quot;&gt;Amazon Cloudfront 開発者ガイド&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>soudegesu</name></author><category term="aws" /><category term="lambda" /><category term="cloudfront" /><category term="serverless" /><summary type="html">このブログ自体は github-pages と cloudflare を使って無料でホスティングをしているのですが、稀に 「動的なwebコンテンツを提供したい」 と思うことがあります。今回はお金を節約しつつ、動的なwebコンテンツを提供する方法を紹介します。</summary></entry><entry><title type="html">springboot-webfluxのバックプレッシャーを体験してたらいい感じだった</title><link href="https://www.soudegesu.com/java/non-blocking-webflux/" rel="alternate" type="text/html" title="springboot-webfluxのバックプレッシャーを体験してたらいい感じだった" /><published>2018-03-16T00:00:00+09:00</published><updated>2018-03-16T00:00:00+09:00</updated><id>https://www.soudegesu.com/java/non-blocking-webflux</id><content type="html" xml:base="https://www.soudegesu.com/java/non-blocking-webflux/">&lt;p&gt;2018/3にリリースされた &lt;code class=&quot;highlighter-rouge&quot;&gt;springboot2&lt;/code&gt; から &lt;code class=&quot;highlighter-rouge&quot;&gt;spring5&lt;/code&gt; がバンドルされるようになりました。
リリースの中でも注目機能と言われている &lt;code class=&quot;highlighter-rouge&quot;&gt;webflux&lt;/code&gt; 、とりわけ &lt;code class=&quot;highlighter-rouge&quot;&gt;webflux&lt;/code&gt; が内包しているリアクティブプログラミングライブラリである &lt;code class=&quot;highlighter-rouge&quot;&gt;Reactor&lt;/code&gt; はspringユーザであれば気になるはずです。今回はバックプレッシャーがいい感じだったので、それをまとめてみました。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#今回作成したリポジトリ&quot; id=&quot;markdown-toc-今回作成したリポジトリ&quot;&gt;今回作成したリポジトリ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#routerfunctionを登録する&quot; id=&quot;markdown-toc-routerfunctionを登録する&quot;&gt;RouterFunctionを登録する&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#パフォーマンスを測定してみた&quot; id=&quot;markdown-toc-パフォーマンスを測定してみた&quot;&gt;パフォーマンスを測定してみた&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#環境情報&quot; id=&quot;markdown-toc-環境情報&quot;&gt;環境情報&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#バックプレッシャーを体験する&quot; id=&quot;markdown-toc-バックプレッシャーを体験する&quot;&gt;バックプレッシャーを体験する&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#springboot-webfluxは普通に生きている&quot; id=&quot;markdown-toc-springboot-webfluxは普通に生きている&quot;&gt;springboot-webfluxは普通に生きている&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#springboot-webmvcはやっぱり死んだ&quot; id=&quot;markdown-toc-springboot-webmvcはやっぱり死んだ&quot;&gt;springboot-webmvcはやっぱり死んだ&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#スレッド増加の傾向を見てみる&quot; id=&quot;markdown-toc-スレッド増加の傾向を見てみる&quot;&gt;スレッド増加の傾向を見てみる&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考にさせていただいたサイト&quot; id=&quot;markdown-toc-参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;今回作成したリポジトリ&quot;&gt;今回作成したリポジトリ&lt;/h2&gt;
&lt;p&gt;今回作成したリポジトリは &lt;a href=&quot;https://github.com/soudegesu/springboot-webflux-test&quot;&gt;こちら&lt;/a&gt; です。
全てローカル環境で動かせるように &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose&lt;/code&gt; でコンポーネント化してあるものの、 ローカルマシンのリソースを食い合うため、負荷試験をするときはLinuxサーバ上に展開することをオススメします。&lt;/p&gt;

&lt;h2 id=&quot;routerfunctionを登録する&quot;&gt;RouterFunctionを登録する&lt;/h2&gt;
&lt;p&gt;以下のような &lt;code class=&quot;highlighter-rouge&quot;&gt;RouterFunction&lt;/code&gt; を作成し、 &lt;code class=&quot;highlighter-rouge&quot;&gt;@Bean&lt;/code&gt; で登録しておきます。
RouterFunctionのレスポンスを返す部分はもう少しいい実装がありそうですが、一旦こうしました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RouterFunction&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Component
public class HelloWebClientHandler {

    @Value(&quot;${app.backend.uri}&quot;)
    private String baseUri;

    private static final String PATH = &quot;/test&quot;;

    public RouterFunction&amp;lt;ServerResponse&amp;gt; routes() {
        return RouterFunctions.route(
                RequestPredicates.GET(&quot;/hello&quot;)
                        .and(RequestPredicates.accept(MediaType.APPLICATION_JSON))
                , this::webclient);
    }

    private Mono&amp;lt;ServerResponse&amp;gt; webclient(ServerRequest req) {
        return WebClient.builder()
                .baseUrl(baseUri)
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON.toString())
                .build()
                .get()
                .uri(uriBuilder -&amp;gt; {
                    uriBuilder.path(PATH);
                    if (req.queryParam(&quot;time&quot;).isPresent()) {
                        uriBuilder.queryParam(&quot;time&quot;, req.queryParam(&quot;time&quot;).get());
                    }
                    return uriBuilder.build();
                })
                .accept(MediaType.APPLICATION_JSON)
                .exchange()
                .flatMap(response -&amp;gt;
                    ServerResponse.ok()
                            .contentType(MediaType.APPLICATION_JSON)
                            .body(response.bodyToMono(User.class), User.class)
                            .switchIfEmpty(ServerResponse.notFound().build())
                );
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;RouterFunctionを登録する側&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作成した &lt;code class=&quot;highlighter-rouge&quot;&gt;HelloWebClientHandler&lt;/code&gt; を登録します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Configuration
@EnableWebFlux
public class WebConfig extends DelegatingWebFluxConfiguration {
    // ~中略~

    @Bean
    RouterFunction&amp;lt;ServerResponse&amp;gt; route7(HelloWebClientHandler webClientHandler) {
        return webClientHandler.routes();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;あとは &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; メソッドを持ったクラスを作ってあげればspringbootアプリケーションは作成完了です。&lt;/p&gt;

&lt;h2 id=&quot;パフォーマンスを測定してみた&quot;&gt;パフォーマンスを測定してみた&lt;/h2&gt;
&lt;p&gt;springbootのjarファイルをEC2上に置いて実際にバックプレッシャーの効果を見てみましょう。&lt;/p&gt;

&lt;h3 id=&quot;環境情報&quot;&gt;環境情報&lt;/h3&gt;
&lt;p&gt;私のローカルマシン上からgatlingを実行し、EC2上のspringbootアプリケーションに負荷がけをします。
springbootアプリケーションは、バックエンドのmockサーバ(OpenRestyを使用)に対して &lt;code class=&quot;highlighter-rouge&quot;&gt;WebClient&lt;/code&gt; を使ってAsyncなHTTP通信を行います。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180316/architecture.png&quot; alt=&quot;architechture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;なお、EC2インスタンスは &lt;code class=&quot;highlighter-rouge&quot;&gt;t2.small&lt;/code&gt; を使用し、JVMへの割当メモリは &lt;code class=&quot;highlighter-rouge&quot;&gt;最大256M&lt;/code&gt; に設定しています。
また、バックプレッシャーを観測したいので、mockサーバではsleep処理を入れています。&lt;/p&gt;

&lt;h3 id=&quot;バックプレッシャーを体験する&quot;&gt;バックプレッシャーを体験する&lt;/h3&gt;
&lt;h4 id=&quot;springboot-webfluxは普通に生きている&quot;&gt;springboot-webfluxは普通に生きている&lt;/h4&gt;
&lt;p&gt;バックプレッシャーの効果を見てみましょう。
gatlingのリクエスト量と、mockサーバ側のsleep時間は以下です。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;gatlingのリクエスト&lt;/th&gt;
      &lt;th&gt;mockのsleep時間&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;150req/s&lt;/td&gt;
      &lt;td&gt;1s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180316/webflux-sleep-150.png&quot; alt=&quot;webflux-sleep-150&quot; /&gt;&lt;/p&gt;

&lt;p&gt;普通に全て200レスポンスが返却されていますね。すごい。&lt;/p&gt;

&lt;p&gt;次にsleep時間を &lt;code class=&quot;highlighter-rouge&quot;&gt;5s&lt;/code&gt; にして見てみます。
対照実験的な意味で &lt;code class=&quot;highlighter-rouge&quot;&gt;150req/s&lt;/code&gt; がよかったのですが、今回は私のマシンのパワー不足により &lt;code class=&quot;highlighter-rouge&quot;&gt;130&lt;/code&gt; までしか出ませんでした。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;gatlingのリクエスト&lt;/th&gt;
      &lt;th&gt;mockのsleep時間&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;130req/s&lt;/td&gt;
      &lt;td&gt;5s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180316/webflux-sleep-130-5s.png&quot; alt=&quot;webflux-sleep-130-5s&quot; /&gt;&lt;/p&gt;

&lt;p&gt;バックエンドサーバが5秒も応答待ちでも普通に200応答できていますね。&lt;/p&gt;

&lt;h4 id=&quot;springboot-webmvcはやっぱり死んだ&quot;&gt;springboot-webmvcはやっぱり死んだ&lt;/h4&gt;
&lt;p&gt;比較として、従来の &lt;code class=&quot;highlighter-rouge&quot;&gt;springboot-webmvc&lt;/code&gt; ではどうでしょう。
サーブレットコンテナはデフォルトの &lt;code class=&quot;highlighter-rouge&quot;&gt;embed-tomcat&lt;/code&gt; として、&lt;code class=&quot;highlighter-rouge&quot;&gt;application.yaml&lt;/code&gt; の設定もデフォルトとします。
また、mockへの通信を行う &lt;code class=&quot;highlighter-rouge&quot;&gt;HttpClient&lt;/code&gt; はConnectionPoolingから取得するように実装した上で以下の条件でリクエストを流してみました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;gatlingのリクエスト&lt;/th&gt;
      &lt;th&gt;mockのsleep時間&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;100req/s&lt;/td&gt;
      &lt;td&gt;1s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180316/mvc-sleep-100.png&quot; alt=&quot;mvc-sleep-100&quot; /&gt;&lt;/p&gt;

&lt;p&gt;うむ。やはりだめでしたか。&lt;/p&gt;

&lt;p&gt;一応、同条件にて、HttpClientのPool数も増やしたりして調整しましたが、エラーレスポンス件数が0にはなりませんでした。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180316/mvc-sleep-100-tuned.png&quot; alt=&quot;mvc-sleep-100-tuned&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;スレッド増加の傾向を見てみる&quot;&gt;スレッド増加の傾向を見てみる&lt;/h3&gt;
&lt;p&gt;負荷試験中のスレッドの増加傾向も見てみましょう。この観点は単純に &lt;code class=&quot;highlighter-rouge&quot;&gt;netty4&lt;/code&gt; vs &lt;code class=&quot;highlighter-rouge&quot;&gt;tomcat&lt;/code&gt; に依存する部分が大きいのですが、見てみましょう。&lt;/p&gt;

&lt;p&gt;webflux(Netty4)の場合は起動時からスレッド数が一定ですね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180316/webflux-thread.png&quot; alt=&quot;webflux-thread&quot; /&gt;&lt;/p&gt;

&lt;p&gt;tomcatはやはりリクエストをさばくためにスレッドが必要になってしまうため、増加傾向にあります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180316/tomcat-thread.png&quot; alt=&quot;tomcat-thread&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回は &lt;code class=&quot;highlighter-rouge&quot;&gt;springboot-webflux&lt;/code&gt; と &lt;code class=&quot;highlighter-rouge&quot;&gt;springboo-webmvc&lt;/code&gt; を比較して、バックプレッシャーがどんな感じかを確認しました。
梱包されている &lt;code class=&quot;highlighter-rouge&quot;&gt;netty4&lt;/code&gt; が持つnon-blockingな仕組みのおかげで、バックエンドサーバの遅延に引きずられることなくレスポンスを返却できていることがわかります。&lt;/p&gt;

&lt;p&gt;しかしながら、もちろん銀の弾丸ではなくて、実装する上でのデメリットや考慮ポイントが他のサイトを見ると情報が色々出てきます。
例えば、自身が書こうとしている処理がblockingな処理なのか、non-blockingな処理なのかを実装する側が気をつけないといけない、という点があります。
そのためには、ライブラリがどのように動いているかをきちんと把握しないといけないでしょう。
加えて、スレッドを共有する形でアプリケーションが動作するので、 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; をむやみに使わない方が良い気もしています。&lt;/p&gt;

&lt;p&gt;ただ、 tomcatでサポートしているServlet 3.1の非同期IOよりは良さそうなので、用法を見定めた上で使っていきたいですね。&lt;/p&gt;

&lt;h2 id=&quot;参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://acro-engineer.hatenablog.com/entry/2013/10/17/113216&quot;&gt;How to Migrate Netty 3 to 4 (Netty 番外編)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>soudegesu</name></author><category term="java" /><category term="spring" /><category term="webflux" /><category term="reactor" /><summary type="html">2018/3にリリースされた springboot2 から spring5 がバンドルされるようになりました。 リリースの中でも注目機能と言われている webflux 、とりわけ webflux が内包しているリアクティブプログラミングライブラリである Reactor はspringユーザであれば気になるはずです。今回はバックプレッシャーがいい感じだったので、それをまとめてみました。</summary></entry><entry><title type="html">EthereumでDApps開発のための開発環境を構築する(Truffle&amp;amp;Ganache接続まで)</title><link href="https://www.soudegesu.com/ethereum/ethereum-development-with-ganache/" rel="alternate" type="text/html" title="EthereumでDApps開発のための開発環境を構築する(Truffle&amp;Ganache接続まで)" /><published>2018-03-10T00:00:00+09:00</published><updated>2018-03-10T00:00:00+09:00</updated><id>https://www.soudegesu.com/ethereum/ethereum-development-with-ganache</id><content type="html" xml:base="https://www.soudegesu.com/ethereum/ethereum-development-with-ganache/">&lt;p&gt;&lt;a href=&quot;/ethereum/ethereum-development-environment/&quot;&gt;前回の記事&lt;/a&gt; で &lt;code class=&quot;highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; の開発環境の構築を行いました。
今回はさらに &lt;code class=&quot;highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; 用のフレームワークである &lt;code class=&quot;highlighter-rouge&quot;&gt;Truffle&lt;/code&gt; と &lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; を使ってローカルでの開発環境を整えようと思います。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#truffleとは&quot; id=&quot;markdown-toc-truffleとは&quot;&gt;Truffleとは&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ganacheとは&quot; id=&quot;markdown-toc-ganacheとは&quot;&gt;Ganacheとは&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#セットアップ&quot; id=&quot;markdown-toc-セットアップ&quot;&gt;セットアップ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#設定&quot; id=&quot;markdown-toc-設定&quot;&gt;設定&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#packagejson-の修正&quot; id=&quot;markdown-toc-packagejson-の修正&quot;&gt;package.json の修正&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#truffleを初期化する&quot; id=&quot;markdown-toc-truffleを初期化する&quot;&gt;truffleを初期化する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ganacheと接続する&quot; id=&quot;markdown-toc-ganacheと接続する&quot;&gt;Ganacheと接続する&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;truffleとは&quot;&gt;Truffleとは&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://truffleframework.com/&quot;&gt;Truffle&lt;/a&gt; は &lt;code class=&quot;highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; アプリケーションの開発効率を上げるためのフレームワークです。
ボイラープレート的な仕事をしてくれるところから始まり、 ネットワーク接続の設定管理や、ネットワークのマイグレーション実行や初期化、テストフレームワークをバンドルしていたりなど、一通り開発できるように準備を整えてくれます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180310/truffle.png&quot; alt=&quot;Truffle top&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ganacheとは&quot;&gt;Ganacheとは&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://truffleframework.com/ganache/&quot;&gt;Ganache&lt;/a&gt; はDAppsを開発時のテストをする際に使用するローカル用のプライベートネットワークを構築してくれます。自動マイニングしてくれるので、別でターミナルを立ち上げて、マイニング用のコマンドを実行する必要もありません。発生したトランザクションは順番にソートされて表示もされるので、動作確認も比較的容易にできると思います。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180310/ganache.png&quot; alt=&quot;Ganache top&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;セットアップ&quot;&gt;セットアップ&lt;/h2&gt;
&lt;p&gt;以前同様の記事を書きましたが、簡単におさらいします。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Etehreum のインストール&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew tap ethereum/ethereum
brew install ethereum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;nodenvのインストール&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;私の場合、ローカル環境のグローバルなnodeのバージョンを変更したくないので、 &lt;code class=&quot;highlighter-rouge&quot;&gt;nodenv&lt;/code&gt; を使って切り替えています。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install nodenv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;nodenv起動のために、 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt; に以下を追記します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export PATH=&quot;$PATH:$HOME/.nodenv/bin:&quot;
eval &quot;$(nodenv init --no-rehash -)&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;node(9.6.1)のインストールと設定&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nodenv install 9.6.1
nodenv local 9.6.1
node -v
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt; の作成&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm init
(面倒なので、以降はEnter)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;truffle&lt;/code&gt; のインストール&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install truffle@4.0.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;solidityのコンパイラ &lt;code class=&quot;highlighter-rouge&quot;&gt;solc&lt;/code&gt; のインストール&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install solc@0.4.18
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; のインストール&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://truffleframework.com/ganache/&quot;&gt;Ganache&lt;/a&gt; のページからインストーラを取得し実行する。&lt;/p&gt;

&lt;h2 id=&quot;設定&quot;&gt;設定&lt;/h2&gt;
&lt;h3 id=&quot;packagejson-の修正&quot;&gt;package.json の修正&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;truffle&lt;/code&gt; をグローバルインストールしていないので、&lt;code class=&quot;highlighter-rouge&quot;&gt;npm run&lt;/code&gt; でキックできるように &lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt; を修正します。
&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt; の &lt;code class=&quot;highlighter-rouge&quot;&gt;scripts&lt;/code&gt; ブロックを修正します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &quot;scripts&quot;: {
    &quot;truffle&quot;: &quot;truffle&quot;,
    &quot;develop&quot;: &quot;truffle develop&quot;,
    &quot;truffle-ganache&quot;: &quot;truffle migrate --compile-all --reset --network ganache&quot;,
    &quot;truffle-console&quot;: &quot;truffle console --network ganache&quot;
  },
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;truffleを初期化する&quot;&gt;truffleを初期化する&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm run truffle init 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;実行が完了すると、プロジェクトディレクトリにフォルダやファイルがジェネレートされます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tree -L 1

.
├── contracts
├── migrations
├── node_modules
├── package-lock.json
├── package.json
├── test
├── truffle-config.js
└── truffle.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;contracts&lt;/code&gt; ディレクトリ
    &lt;ul&gt;
      &lt;li&gt;コントラクトプログラムを配置する場所。&lt;code class=&quot;highlighter-rouge&quot;&gt;truffle init&lt;/code&gt; 時に &lt;code class=&quot;highlighter-rouge&quot;&gt;Migrations.sol&lt;/code&gt; が生成される&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;migrations&lt;/code&gt; ディレクトリ
    &lt;ul&gt;
      &lt;li&gt;マイグレーションスクリプトを配置する場所。 &lt;code class=&quot;highlighter-rouge&quot;&gt;truffle init&lt;/code&gt; 時に &lt;code class=&quot;highlighter-rouge&quot;&gt;1_initial_migrations.js&lt;/code&gt; が生成される。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt; ディレクトリ
    &lt;ul&gt;
      &lt;li&gt;作成したコントラクトプログラムのテストスクリプトを配置する場所。デフォルトで &lt;code class=&quot;highlighter-rouge&quot;&gt;mocha&lt;/code&gt; が使える。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;truffle.js&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;truffleの設定ファイル&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;truffle-config.js&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;truffle.jsと同じ。&lt;code class=&quot;highlighter-rouge&quot;&gt;PowerShell&lt;/code&gt; や &lt;code class=&quot;highlighter-rouge&quot;&gt;Git-bash&lt;/code&gt; 利用時にはこちらを編集する。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;私はMacユーザなので、&lt;code class=&quot;highlighter-rouge&quot;&gt;truffle-config.js&lt;/code&gt; は消してしまいます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rm truffle-config.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;ganacheと接続する&quot;&gt;Ganacheと接続する&lt;/h3&gt;

&lt;p&gt;次にインストール済みの &lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; を起動します。
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; はデフォルトで10個のアカウントを作成してくれます。指定がなければ1番上に表示されているアカウントが &lt;code class=&quot;highlighter-rouge&quot;&gt;coinbase&lt;/code&gt; になります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180310/boot_ganache.png&quot; alt=&quot;Boot Ganache&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ganacheが表示しているネットワークの情報を基に、&lt;code class=&quot;highlighter-rouge&quot;&gt;truffle.js&lt;/code&gt; を以下のように編集します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = {
  // See &amp;lt;http://truffleframework.com/docs/advanced/configuration&amp;gt;
  // to customize your Truffle configuration!
  networks: {
    ganache: {
      host: &quot;localhost&quot;,
      port: 7545,
      network_id: &quot;*&quot;
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt; に記載した npm scriptsのコマンドから &lt;code class=&quot;highlighter-rouge&quot;&gt;truffle-ganache&lt;/code&gt; を起動し、
Ganacheのマイグレーションを行います。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm run truffle-ganache
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ganacheの画面を見てみると1番上のアドレスの &lt;code class=&quot;highlighter-rouge&quot;&gt;balance&lt;/code&gt; (所有しているether) が &lt;code class=&quot;highlighter-rouge&quot;&gt;100&lt;/code&gt; → &lt;code class=&quot;highlighter-rouge&quot;&gt;99.97&lt;/code&gt; に減っています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180310/migration_ganache.png&quot; alt=&quot;migration Ganache&quot; /&gt;&lt;/p&gt;

&lt;p&gt;実はこれ、&lt;code class=&quot;highlighter-rouge&quot;&gt;npm run truffle-ganache&lt;/code&gt; 実行により、&lt;code class=&quot;highlighter-rouge&quot;&gt;migrations/1_initial_migrations.js&lt;/code&gt; が実行され、
そこから &lt;code class=&quot;highlighter-rouge&quot;&gt;contracts/Migrations.sol&lt;/code&gt; がデプロイされています。
そのマイグレーションの処理自体もトランザクションが行われており、ganacheに &lt;code class=&quot;highlighter-rouge&quot;&gt;gas&lt;/code&gt; をお支払いしたため少しだけ減っています。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TRANSACTIONS&lt;/code&gt; タブを押すと、トランザクションハッシュが生成されていることを確認できます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180310/transaction_ganache.png&quot; alt=&quot;transaction Ganache&quot; /&gt;&lt;/p&gt;

&lt;p&gt;また、対話形式でプログラムを書きたい場合には以下のようにコンソールを立ち上げて、&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm run truffle-console
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;試しに以下のようなコードを実行すると&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;web3.eth.sendTransaction({from: web3.eth.accounts[0], to: web3.eth.accounts[1], value:web3.toWei(5, &quot;ether&quot;)})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;トランザクションのアドレスが帰ってきます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;  '0x046714fb412724c656250e5856bbb83469e2811b5d710bfa3c515606f5ff938a'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; の方を確認すると、ちゃんとトランザクションが反映されていることがわかりますね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180310/transaction_sample.png&quot; alt=&quot;transaction sample&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回は &lt;code class=&quot;highlighter-rouge&quot;&gt;Truffle&lt;/code&gt; でローカル環境構築をした後、 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; のネットワークに接続設定をして、マイグレーションまでを行いました。
&lt;code class=&quot;highlighter-rouge&quot;&gt;Truffle&lt;/code&gt; と &lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; を使うことで、素の &lt;code class=&quot;highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; 単体で開発するよりも、開発環境周辺の手間が軽減されるので、これから積極的に使っていきたいと思います。
ここまでできれば、次は &lt;code class=&quot;highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; によるコントラクトの開発と、テストコードによる動作確認です。&lt;/p&gt;</content><author><name>soudegesu</name></author><category term="ethereum" /><category term="truffle" /><category term="ganache" /><category term="dapps" /><summary type="html">前回の記事 で Ethereum の開発環境の構築を行いました。 今回はさらに Ethereum 用のフレームワークである Truffle と Ganache を使ってローカルでの開発環境を整えようと思います。</summary></entry><entry><title type="html">EthereumでDApps開発のための開発環境を構築する(Ethereumで別アカウントに送金まで)</title><link href="https://www.soudegesu.com/ethereum/ethereum-development-environment/" rel="alternate" type="text/html" title="EthereumでDApps開発のための開発環境を構築する(Ethereumで別アカウントに送金まで)" /><published>2018-03-05T00:00:00+09:00</published><updated>2018-03-05T00:00:00+09:00</updated><id>https://www.soudegesu.com/ethereum/ethereum-development-environment</id><content type="html" xml:base="https://www.soudegesu.com/ethereum/ethereum-development-environment/">&lt;p&gt;以前、&lt;code class=&quot;highlighter-rouge&quot;&gt;IPFS&lt;/code&gt; を調査したことがあり、そこから &lt;code class=&quot;highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; の存在を知りました。
昨年頃から本格的に日本でも名前が売れてきて、日本語のソースも増えてきたこともあるので、これを機にサンプルでも作成しようかと思いました。
今回はDApps開発のための下準備までを纏めます。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#環境情報&quot; id=&quot;markdown-toc-環境情報&quot;&gt;環境情報&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#etehreumのセットアップ&quot; id=&quot;markdown-toc-etehreumのセットアップ&quot;&gt;Etehreumのセットアップ&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ethereumのインストール&quot; id=&quot;markdown-toc-ethereumのインストール&quot;&gt;Ethereumのインストール&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#設定ファイルの作成&quot; id=&quot;markdown-toc-設定ファイルの作成&quot;&gt;設定ファイルの作成&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#プライベートネットワークの初期化&quot; id=&quot;markdown-toc-プライベートネットワークの初期化&quot;&gt;プライベートネットワークの初期化&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#アカウントの作成&quot; id=&quot;markdown-toc-アカウントの作成&quot;&gt;アカウントの作成&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#マイニングの動作確認をする&quot; id=&quot;markdown-toc-マイニングの動作確認をする&quot;&gt;マイニングの動作確認をする&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#別アカウントにethを送ってみる&quot; id=&quot;markdown-toc-別アカウントにethを送ってみる&quot;&gt;別アカウントにEthを送ってみる&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考にさせていただいたサイト&quot; id=&quot;markdown-toc-参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;環境情報&quot;&gt;環境情報&lt;/h2&gt;
&lt;p&gt;今回、私は以下の環境にて構築を行いました&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Mac Book Pro
    &lt;ul&gt;
      &lt;li&gt;OS: High Seria 10.13.2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Homebrew
    &lt;ul&gt;
      &lt;li&gt;1.5.6&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;etehreumのセットアップ&quot;&gt;Etehreumのセットアップ&lt;/h2&gt;
&lt;p&gt;今回は &lt;a href=&quot;https://www.ethereum.org/&quot;&gt;Ethereum&lt;/a&gt; を使用します。理由としては、DApps開発のためのOSSとして開発が積極的に行われており、
様々なDAppsにて使用されている(らしい)からです。&lt;/p&gt;

&lt;h3 id=&quot;ethereumのインストール&quot;&gt;Ethereumのインストール&lt;/h3&gt;
&lt;p&gt;Homebrewがあれば簡単にインストールができます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;リポジトリを追加&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew tap ethereum/ethereum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Ethereum をインストール&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install ethereum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;バージョンを確認&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth -h

&amp;gt; NAME:
&amp;gt;    geth - the go-ethereum command line interface
&amp;gt;
&amp;gt;    Copyright 2013-2017 The go-ethereum Authors
&amp;gt;
&amp;gt; USAGE:
&amp;gt;    geth [options] command [command options] [arguments...]
&amp;gt;
&amp;gt; VERSION:
&amp;gt;    1.8.1-stable
(以下略)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1.8.1&lt;/code&gt; がインストールされているようですね。&lt;/p&gt;

&lt;p&gt;以降の作業は以下のディレクトリにて実施します。(誤解を招かないように念のため)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pwd
&amp;gt; /Users/xxxxxx/workspace/eth_private_net
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;設定ファイルの作成&quot;&gt;設定ファイルの作成&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; の 1.6から &lt;code class=&quot;highlighter-rouge&quot;&gt;puppeth&lt;/code&gt; コマンドが追加されました。
これを使って初期化を行います。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;puppeth
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;すると以下のようなメッセージが出てくるので、とりあえずネットワーク名を任意の名前にします。
今回は &lt;code class=&quot;highlighter-rouge&quot;&gt;soudegesu&lt;/code&gt; にしました。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-----------------------------------------------------------+
| Welcome to puppeth, your Ethereum private network manager |
|                                                           |
| This tool lets you create a new Ethereum network down to  |
| the genesis block, bootnodes, miners and ethstats servers |
| without the hassle that it would normally entail.         |
|                                                           |
| Puppeth uses SSH to dial in to remote servers, and builds |
| its network components out of Docker containers using the |
| docker-compose toolset.                                   |
+-----------------------------------------------------------+

Please specify a network name to administer (no spaces, please)
&amp;gt; soudegesu
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以降も対話形式で入力していきます。まず、 &lt;code class=&quot;highlighter-rouge&quot;&gt;2. Configure new genesis&lt;/code&gt; を選択します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sweet, you can set this via --network=soudegesu next time!

INFO [03-05|14:24:17] Administering Ethereum network           name=soudegesu
WARN [03-05|14:24:17] No previous configurations found         path=/Users/xxxxxxxxx/.puppeth/soudegesu

What would you like to do? (default = stats)
 1. Show network stats
 2. Configure new genesis
 3. Track new remote server
 4. Deploy network components
&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;次にコンセンサスルールを決めます。今回は &lt;code class=&quot;highlighter-rouge&quot;&gt;Ethash&lt;/code&gt; にしましょう。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Which consensus engine to use? (default = clique)
 1. Ethash - proof-of-work
 2. Clique - proof-of-authority
&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;次はとりあえずデフォルトにしておきます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Which accounts are allowed to seal? (mandatory at least one)
&amp;gt; 0x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;次に使用するネットワークIDを指定します。
適当に &lt;code class=&quot;highlighter-rouge&quot;&gt;4224&lt;/code&gt; にします。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Specify your chain/network ID if you want an explicit one (default = random)
&amp;gt; 4224
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;なお、代表的なnetwork idは以下のようになっています。
今回はローカル環境で動かすだけですが、重複しないようにしておきましょう。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;: Mainnet&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;: Morden test net(obsolete)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;: Ropsten test net&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;: Rinkeby test net&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;42&lt;/code&gt;: Kovan test net&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次にgenesisの設定管理を選択します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;What would you like to do? (default = stats)
 1. Show network stats
 2. Manage existing genesis
 3. Track new remote server
 4. Deploy network components
&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;genesisの設定をエクスポートします。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1. Modify existing fork rules
 2. Export genesis configuration
 3. Remove genesis configuration
&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;次はデフォルトでOK&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Which file to save the genesis into? (default = soudegesu.json)
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ココまで来ると &lt;code class=&quot;highlighter-rouge&quot;&gt;Exported existing genesis block&lt;/code&gt; と表示され、コンソール上の表示が最初に戻ります。
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl + C&lt;/code&gt; にてexitしましょう。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;soudegesu.json&lt;/code&gt; が作成されていることが確認できます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat soudegesu.json

{
  &quot;config&quot;: {
    &quot;chainId&quot;: 4224,
    &quot;homesteadBlock&quot;: 1,
    &quot;eip150Block&quot;: 2,
    &quot;eip150Hash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
    &quot;eip155Block&quot;: 3,
    &quot;eip158Block&quot;: 3,
    &quot;byzantiumBlock&quot;: 4,
    &quot;ethash&quot;: {}
  },
  &quot;nonce&quot;: &quot;0x0&quot;,
  &quot;timestamp&quot;: &quot;0x5a9cd72a&quot;,
  &quot;extraData&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;gasLimit&quot;: &quot;0x47b760&quot;,
  &quot;difficulty&quot;: &quot;0x80000&quot;,
  &quot;mixHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;,
  &quot;alloc&quot;: {
    &quot;0000000000000000000000000000000000000000&quot;: {
      &quot;balance&quot;: &quot;0x1&quot;
    },
    (以下略)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;プライベートネットワークの初期化&quot;&gt;プライベートネットワークの初期化&lt;/h3&gt;

&lt;p&gt;次にネットワークの初期化を行います。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth --datadir ./private init ./soudegesu.json

INFO [03-05|14:54:31] Maximum peer count                       ETH=25 LES=0 total=25
INFO [03-05|14:54:31] Allocated cache and file handles         database=/Users/xxxxxx/workspace/eth_private_net/private/geth/chaindata cache=16 handles=16
INFO [03-05|14:54:31] Writing custom genesis block
INFO [03-05|14:54:31] Persisted trie from memory database      nodes=354 size=65.02kB time=1.10945ms gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [03-05|14:54:31] Successfully wrote genesis state         database=chaindata                                                              hash=25e489…52b7d1
INFO [03-05|14:54:31] Allocated cache and file handles         database=/Users/xxxxxx/workspace/eth_private_net/private/geth/lightchaindata cache=16 handles=16
INFO [03-05|14:54:31] Writing custom genesis block
INFO [03-05|14:54:31] Persisted trie from memory database      nodes=354 size=65.02kB time=1.327455ms gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [03-05|14:54:31] Successfully wrote genesis state         database=lightchaindata                                                              hash=25e489…52b7d1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;アカウントの作成&quot;&gt;アカウントの作成&lt;/h3&gt;

&lt;p&gt;ether(wei) をやりとりするためのアカウントを作成します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth --datadir . account new
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;適当にパスワードを設定すると &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; のところにアカウントのアドレスが表示されます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Your new account is locked with a password. Please give a password. Do not forget this password.
Passphrase:
Repeat passphrase:
Address: {アカウントA}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;作成が完了すると &lt;code class=&quot;highlighter-rouge&quot;&gt;keystore&lt;/code&gt; ディレクトリ下にユーザ情報が記載されたjsonファイルが出力されます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ls keystore

UTC--2018-03-05T06-00-32.829542689Z--アカウントA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;作成されたアカウントを確認します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth --datadir . account list
Account #0: {アカウントA} keystore:///Users/xxxxx/workspace/eth_private_net/keystore/UTC--2018-03-05T06-00-32.829542689Z--アカウントA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;後の行程で、複数ユーザ間でデータをやりとりする仕組みを試してみるため、
 &lt;code class=&quot;highlighter-rouge&quot;&gt;geth --datadir . account new&lt;/code&gt; コマンドを複数実行し、アカウントを複数作っておきましょう。(とりあえず3つくらい)&lt;/p&gt;

&lt;h3 id=&quot;マイニングの動作確認をする&quot;&gt;マイニングの動作確認をする&lt;/h3&gt;
&lt;p&gt;次にマイニングの動作確認をします。&lt;/p&gt;

&lt;p&gt;先程作成した &lt;code class=&quot;highlighter-rouge&quot;&gt;keystore&lt;/code&gt; の情報を移動します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp ~/workspace/eth_private_net/keystore/* ~/workspace/eth_private_net/private/keystore/.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;作成したユーザのパスワードファイルを作成します。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo (account new する時に指定したパスワード) &amp;gt; private/password.sec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;実行してみましょう。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth --networkid 4224 --mine --minerthreads 1 --datadir &quot;~/workspace/eth_private_net/private&quot; --nodiscover --rpc --rpcport &quot;8545&quot; --port &quot;30303&quot; --rpccorsdomain &quot;*&quot; --nat &quot;any&quot; --rpcapi eth,web3,personal,net --unlock 0 --password ~/workspace/eth_private_net/private/password.sec --ipcpath &quot;~/Library/Ethereum/geth.ipc&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;その際に、標準出力に表示される &lt;code class=&quot;highlighter-rouge&quot;&gt;ChainID&lt;/code&gt; が指定されたIDになっているかを確認しましょう。
今回であれば &lt;strong&gt;4224&lt;/strong&gt; が出ていればOKです。&lt;/p&gt;

&lt;p&gt;処理がもりもり走っていきます。ハンマーアイコンが出てくればマイニングできています。
(もちろんテスト用なので、何の価値もないですが)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180305/chained.png&quot; alt=&quot;mining&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;別アカウントにethを送ってみる&quot;&gt;別アカウントにEthを送ってみる&lt;/h3&gt;
&lt;p&gt;先程複数アカウントを作成したので、実際にetherを送ってみましょう。
ターミナル上のマイニングの画面はそのままにして、ターミナルの別ウィンドウを立ち上げましょう。&lt;/p&gt;

&lt;p&gt;その後、以下を実行し、Javascriptコンソールを起動します。
コンソールは対話形式で入力していくことが可能です。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth attach

instance: Geth/v1.8.1-stable/darwin-amd64/go1.10
coinbase: xxxxxxxxxxxxxxxxxxxxxxxxxx
at block: 23 (Mon, 05 Mar 2018 15:39:56 JST)
 datadir: /Users/xxxxxx/workspace/eth_private_net/private
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;まず存在するアカウントを確認しておきます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; eth.accounts
[&quot;アカウントA&quot;, &quot;アカウントB&quot;, &quot;アカウントC&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;マイニング時のメインアカウントを確認します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; eth.coinbase
アカウントA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;現時点での保有量を確認します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; eth.getBalance(eth.accounts[0])
285000000000000000000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;単位が &lt;code class=&quot;highlighter-rouge&quot;&gt;wei&lt;/code&gt; でわかりにくいので &lt;code class=&quot;highlighter-rouge&quot;&gt;ether&lt;/code&gt; にしましょう。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; web3.fromWei(eth.getBalance(eth.coinbase), &quot;ether&quot;)
288
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;アカウントAから他のアカウントBとアカウントCにそれぞれ送りつけてみましょう。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# アカウントA -&amp;gt; アカウントB へ10 ether送る
eth.sendTransaction({from:eth.accounts[0], to:eth.accounts[1], value:web3.toWei(10, &quot;ether&quot;)})
&amp;gt; ハッシュ値
# アカウントA -&amp;gt; アカウントC へ6 ether送る
eth.sendTransaction({from:eth.accounts[0], to:eth.accounts[2], value:web3.toWei(6, &quot;ether&quot;)})
&amp;gt; ハッシュ値
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以下で確認することができました。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; web3.fromWei(eth.getBalance(eth.accounts[1]), &quot;ether&quot;)
10
&amp;gt; web3.fromWei(eth.getBalance(eth.accounts[2]), &quot;ether&quot;)
6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;駆け足でしたが、今回はざっくり以下まで実施できました。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; のインストール&lt;/li&gt;
  &lt;li&gt;開発用のConfigファイルの作成&lt;/li&gt;
  &lt;li&gt;アカウントの作成&lt;/li&gt;
  &lt;li&gt;マイニング&lt;/li&gt;
  &lt;li&gt;複数アカウント間の送金&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この後、&lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; や &lt;code class=&quot;highlighter-rouge&quot;&gt;truffle&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;Metamask&lt;/code&gt; のセットアップ、 &lt;code class=&quot;highlighter-rouge&quot;&gt;web3&lt;/code&gt; での開発作業があるのですが、
長くなりそうなので、今回はここで一旦切ろうと思います。&lt;/p&gt;

&lt;p&gt;ローカルとはいえ、マイニングされていく様を見ると少しそわそわしますね。&lt;/p&gt;

&lt;p&gt;genesisファイルやコマンドの細かい部分は完全にすっ飛ばしており、私もまだまだ理解が浅いので、
様々なソースを見ながら引き続き学習したいと思います。&lt;/p&gt;

&lt;p&gt;(いやぁ、しかし、早く &lt;a href=&quot;https://github.com/ethereumbook/ethereumbook&quot;&gt;Mastering Ethereum&lt;/a&gt; 発売されないかな)&lt;/p&gt;

&lt;h2 id=&quot;参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.ethereum.org/2017/04/14/geth-1-6-puppeth-master/&quot;&gt;Ethereum blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>soudegesu</name></author><category term="ethereum" /><category term="dapps" /><category term="truffle" /><category term="ganache" /><summary type="html">以前、IPFS を調査したことがあり、そこから Ethereum の存在を知りました。 昨年頃から本格的に日本でも名前が売れてきて、日本語のソースも増えてきたこともあるので、これを機にサンプルでも作成しようかと思いました。 今回はDApps開発のための下準備までを纏めます。</summary></entry></feed>