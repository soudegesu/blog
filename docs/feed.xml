<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="https://www.soudegesu.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.soudegesu.com/" rel="alternate" type="text/html" /><updated>2018-04-04T08:36:47+09:00</updated><id>https://www.soudegesu.com/</id><title type="html">そうなんでげす</title><subtitle>soudegesuのtechブログ。普段仕事では使わない技術を中心に書いていくので入門系記事が多くなると思います</subtitle><author><name>soudegesu</name></author><entry><title type="html">Cloudfront+Lambda@Edgeのサーバレス構成で費用を抑えつつ、動的なWEBコンテンツを作ろう[貧テック]</title><link href="https://www.soudegesu.com/aws/hosting-with-cloudfront-lambda-edge-serverless/" rel="alternate" type="text/html" title="Cloudfront+Lambda@Edgeのサーバレス構成で費用を抑えつつ、動的なWEBコンテンツを作ろう[貧テック]" /><published>2018-04-03T00:00:00+09:00</published><updated>2018-04-03T00:00:00+09:00</updated><id>https://www.soudegesu.com/aws/hosting-with-cloudfront-lambda-edge-serverless</id><content type="html" xml:base="https://www.soudegesu.com/aws/hosting-with-cloudfront-lambda-edge-serverless/">&lt;p&gt;このブログ自体は &lt;code class=&quot;highlighter-rouge&quot;&gt;github-pages&lt;/code&gt; と &lt;code class=&quot;highlighter-rouge&quot;&gt;cloudflare&lt;/code&gt; を使って無料でホスティングをしているのですが、稀に &lt;strong&gt;「動的なwebコンテンツを提供したい」&lt;/strong&gt; と思うことがあります。今回はお金を節約しつつ、動的なwebコンテンツを提供する方法を紹介します。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#モチベーション&quot; id=&quot;markdown-toc-モチベーション&quot;&gt;モチベーション&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#動的なwebコンテンツを作りたい&quot; id=&quot;markdown-toc-動的なwebコンテンツを作りたい&quot;&gt;動的なwebコンテンツを作りたい！&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#問題点アクセスが少ない時期はランニングコストが高くつく&quot; id=&quot;markdown-toc-問題点アクセスが少ない時期はランニングコストが高くつく&quot;&gt;問題点：アクセスが少ない時期はランニングコストが高くつく&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#サーバレスで費用を抑えよう&quot; id=&quot;markdown-toc-サーバレスで費用を抑えよう&quot;&gt;サーバレスで費用を抑えよう&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#案1-cloudfront--lambdaedge&quot; id=&quot;markdown-toc-案1-cloudfront--lambdaedge&quot;&gt;案1 Cloudfront + Lambda@Edge&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#案2-api-gateway--lambda&quot; id=&quot;markdown-toc-案2-api-gateway--lambda&quot;&gt;案2 API Gateway + Lambda&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#案3-gcpのgce-f1-micro-インスタンス&quot; id=&quot;markdown-toc-案3-gcpのgce-f1-micro-インスタンス&quot;&gt;案3 GCPのGCE f1-micro インスタンス&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#awsで構築してみる&quot; id=&quot;markdown-toc-awsで構築してみる&quot;&gt;AWSで構築してみる&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#iam-roleの作成&quot; id=&quot;markdown-toc-iam-roleの作成&quot;&gt;IAM Roleの作成&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ドメインを設定する&quot; id=&quot;markdown-toc-ドメインを設定する&quot;&gt;ドメインを設定する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#certification-managerでssl証明書を取得する&quot; id=&quot;markdown-toc-certification-managerでssl証明書を取得する&quot;&gt;Certification ManagerでSSL証明書を取得する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#lambda関数の作成とpublish&quot; id=&quot;markdown-toc-lambda関数の作成とpublish&quot;&gt;Lambda関数の作成とpublish&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#lambdaedgeはcloudfrontのオリジンリクエスト時に実行させる&quot; id=&quot;markdown-toc-lambdaedgeはcloudfrontのオリジンリクエスト時に実行させる&quot;&gt;Lambda@EdgeはCloudfrontのオリジンリクエスト時に実行させる&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#lambdaedgeからcloudfrontへのレスポンス形式に注意する&quot; id=&quot;markdown-toc-lambdaedgeからcloudfrontへのレスポンス形式に注意する&quot;&gt;Lambda@EdgeからCloudfrontへのレスポンス形式に注意する&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cloudfrontで配信する&quot; id=&quot;markdown-toc-cloudfrontで配信する&quot;&gt;Cloudfrontで配信する&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#lambda関数はpublishして使う&quot; id=&quot;markdown-toc-lambda関数はpublishして使う&quot;&gt;Lambda関数はpublishして使う&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#キャシュクリアをする2回目以降のデプロイ時&quot; id=&quot;markdown-toc-キャシュクリアをする2回目以降のデプロイ時&quot;&gt;キャシュクリアをする(2回目以降のデプロイ時)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考にさせていただいたサイト&quot; id=&quot;markdown-toc-参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;モチベーション&quot;&gt;モチベーション&lt;/h2&gt;
&lt;h3 id=&quot;動的なwebコンテンツを作りたい&quot;&gt;動的なwebコンテンツを作りたい！&lt;/h3&gt;
&lt;p&gt;Google Adsense等を使った広告収入で小遣い稼ぎをしたいと思った場合に、
&lt;code class=&quot;highlighter-rouge&quot;&gt;はてなブログ&lt;/code&gt; のような無料ブログサービスや &lt;code class=&quot;highlighter-rouge&quot;&gt;Github Pages&lt;/code&gt; を利用すると、主に静的ファイルでのコンテンツ配信が中心になります。
1ページあたり1記事を作成する必要があり、1ページあたりの作成コストが高くなるデメリットがあるため、
リクエストパラメータないしはパスパラメータを使ってサーバ側で動的なページ生成を行う機構があれば、
ロングテールでのページのクローリングを狙うことができます。
ちなみに、ロングテールをざっくり説明すると、 &lt;strong&gt;単体の検索ボリュームでは少ないけど、複数カテゴリの検索クエリの組み合わせのバリエーションに対応することで、検索ボリュームの総和に対してリーチする&lt;/strong&gt; 方法です。&lt;/p&gt;

&lt;h3 id=&quot;問題点アクセスが少ない時期はランニングコストが高くつく&quot;&gt;問題点：アクセスが少ない時期はランニングコストが高くつく&lt;/h3&gt;
&lt;p&gt;従来、動的なwebコンテンツを作成しようとする場合、&lt;strong&gt;ページ生成プログラムを動かすためのサーバが必要&lt;/strong&gt; でした。
環境調達の方法としては「レンタルサーバを借りる」のが一般的ですが、バンドルされている &lt;a href=&quot;https://ja.wordpress.org/&quot;&gt;WordPress&lt;/a&gt; で要件が充足されないケースがある場合には、&lt;code class=&quot;highlighter-rouge&quot;&gt;VPS&lt;/code&gt; サービスを契約しなければいけません。
VPSサービスは通常のレンタルサーバよりもランニングコストが少しお高めになってしまいます。&lt;/p&gt;

&lt;p&gt;参考までに2種類のサービス料金を記載しますが、コンテンツ配信のための月額料金がボディブローのようにじわじわ効いてくることが容易に想像できます。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;サービス名&lt;/td&gt;
      &lt;td&gt;月額料金(最低スペック)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tfoot&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://vps.sakura.ad.jp/&quot;&gt;さくらのVPS&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;685JPY/month 〜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://vps.gmocloud.com/&quot;&gt;GMOクラウド&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;780JPY/month 〜&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tfoot&gt;
&lt;/table&gt;

&lt;h3 id=&quot;サーバレスで費用を抑えよう&quot;&gt;サーバレスで費用を抑えよう&lt;/h3&gt;
&lt;p&gt;前提として、&lt;strong&gt;プログラミングに関する知識が必要にはなります&lt;/strong&gt; が、パブリッククラウドを使用することでサーバのランニングコストを抑えることができます。
ざっくりですがパブリッククラウドを用いた構成案と勘案要素を以下にまとめました。いずれの案においても、&lt;strong&gt;最低利用料金 + リクエスト量に応じた従量課金&lt;/strong&gt; というコスト構造になるので、VPSよりも割安なのですが、今回は利便性と最低利用料金のバランスが良い &lt;strong&gt;案1 Cloudfront + Lambda@Edge&lt;/strong&gt; を今回採用しました。&lt;/p&gt;

&lt;h4 id=&quot;案1-cloudfront--lambdaedge&quot;&gt;案1 Cloudfront + Lambda@Edge&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;メリット
    &lt;ul&gt;
      &lt;li&gt;サーバレス&lt;/li&gt;
      &lt;li&gt;CDNキャッシュが効く&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;デメリット
    &lt;ul&gt;
      &lt;li&gt;Lambda@Edgeは無料利用枠がない&lt;/li&gt;
      &lt;li&gt;Node 6.10 しか利用できない&lt;/li&gt;
      &lt;li&gt;その他、通常のLambdaよりも&lt;a href=&quot;https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html#limits-lambda-at-edge&quot;&gt;制限事項が多い&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;案2-api-gateway--lambda&quot;&gt;案2 API Gateway + Lambda&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;メリット
    &lt;ul&gt;
      &lt;li&gt;サーバレス&lt;/li&gt;
      &lt;li&gt;Lambdaがサポートしている複数言語での開発が可能&lt;/li&gt;
      &lt;li&gt;CDNキャッシュが効く&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;デメリット
    &lt;ul&gt;
      &lt;li&gt;API Gatewayの最低利用料金がCloudfrontと比べて高い&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;案3-gcpのgce-f1-micro-インスタンス&quot;&gt;案3 GCPのGCE f1-micro インスタンス&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;メリット
    &lt;ul&gt;
      &lt;li&gt;おそらく利用料金が最も安く抑えられる&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;デメリット
    &lt;ul&gt;
      &lt;li&gt;ロケーションが遠いので、レイテンシが気になる&lt;/li&gt;
      &lt;li&gt;Cloud CDN と組み合わせるとf1-microインスタンス料金無料の旨味が消える&lt;/li&gt;
      &lt;li&gt;インスタンスの設定(ランタイムとかSSL証明書のインストールとか)が必要&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;awsで構築してみる&quot;&gt;AWSで構築してみる&lt;/h2&gt;
&lt;p&gt;以降は案1での構築方法を記載していきます。&lt;/p&gt;

&lt;h3 id=&quot;iam-roleの作成&quot;&gt;IAM Roleの作成&lt;/h3&gt;

&lt;p&gt;Lambdaに付与するIAM Roleを作成します。
まず、以下のようなAssume Role Policy を作成します。
 &lt;code class=&quot;highlighter-rouge&quot;&gt;Lambda&lt;/code&gt; と &lt;code class=&quot;highlighter-rouge&quot;&gt;Lambda@Edge&lt;/code&gt; は別ものとして扱われているため、 &lt;code class=&quot;highlighter-rouge&quot;&gt;edgelambda.amazonaws.com&lt;/code&gt; の記載が必要です。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Sid&quot;: &quot;&quot;,
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Principal&quot;: {
        &quot;Service&quot;: [
          &quot;edgelambda.amazonaws.com&quot;,
          &quot;lambda.amazonaws.com&quot;
        ]
      },
      &quot;Action&quot;: &quot;sts:AssumeRole&quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;作成したPolicyと &lt;code class=&quot;highlighter-rouge&quot;&gt;CloudWatchLogsFullAccess&lt;/code&gt; のポリシーをアタッチしたRoleを作成します。
名前はとりあえず &lt;strong&gt;EdgeLambdaForCloudfrontRole&lt;/strong&gt; としましょう。&lt;/p&gt;

&lt;h3 id=&quot;ドメインを設定する&quot;&gt;ドメインを設定する&lt;/h3&gt;
&lt;p&gt;Cloudfrontのディストリビューションのドメインをそのまま使うわけには行かないので、ドメインを設定します。
個人的にはお金を払い、 &lt;code class=&quot;highlighter-rouge&quot;&gt;.com&lt;/code&gt; や &lt;code class=&quot;highlighter-rouge&quot;&gt;.net&lt;/code&gt; のような信頼のあるドメインを確保することをオススメします。
ドメイン料金も抑えたい方は &lt;strong&gt;「ドメイン 無料」&lt;/strong&gt; で検索すればいくらでも無料ドメインサービスが出てくるので、それを活用してください。&lt;/p&gt;

&lt;p&gt;私が取得しているドメインは &lt;a href=&quot;https://www.cloudflare.com/&quot;&gt;Cloudflare&lt;/a&gt; で管理しているので、
Route53で取得しているドメインのサブドメインのHosted Zoneを作成し、NSレコードをCloudflare上に登録してあげます。&lt;/p&gt;

&lt;h3 id=&quot;certification-managerでssl証明書を取得する&quot;&gt;Certification ManagerでSSL証明書を取得する&lt;/h3&gt;

&lt;p&gt;サブドメインの委譲が正しくできていれば(= Route53上の設定値でDNSが引けるようになれば) Certification Manager を用いてSSL証明書を取得しましょう。
SSL証明書の取得に関してはDNS Validationでやり方をオススメします。 詳しくは以前のポスト &lt;a href=&quot;/aws/validate-certification-manager&quot;&gt;AWS Certification ManagerのSSL証明書の検証にはDNS検証を使った方が良い&lt;/a&gt; を見てみてください。
注意点として、&lt;strong&gt;SSL証明書は us-east-1(Virginia)リージョンで取得する必要があります&lt;/strong&gt; 。
これは「Cloudfrontに適用可能なSSL証明書はVirginiaリージョンで発行されたもののみ」という仕様のためです。&lt;/p&gt;

&lt;h3 id=&quot;lambda関数の作成とpublish&quot;&gt;Lambda関数の作成とpublish&lt;/h3&gt;

&lt;p&gt;次にLambda関数の実装を行います。 &lt;strong&gt;Lambda@EdgeはNode 6.10のみをサポートしているため、Nodeでの実装が必要です&lt;/strong&gt; 。
軽量なwebアプリケーションを作成する手段として、手っ取り早いのは &lt;a href=&quot;https://www.npmjs.com/package/express&quot;&gt;express&lt;/a&gt; を使う方法です。
expressの使い方の説明は割愛しますが、実装時に注意すべき点だけ記載します。&lt;/p&gt;

&lt;h4 id=&quot;lambdaedgeはcloudfrontのオリジンリクエスト時に実行させる&quot;&gt;Lambda@EdgeはCloudfrontのオリジンリクエスト時に実行させる&lt;/h4&gt;

&lt;p&gt;Lambda@EdgeとCloudfrontを連携させる場合に、Lambda@Edgeの実行タイミングを4つのうちから選択することができます。
詳細は&lt;a href=&quot;https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/lambda-cloudfront-trigger-events.html&quot;&gt;開発者ガイド&lt;/a&gt; に記載されています。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CloudFront ビューワーリクエスト
    &lt;ul&gt;
      &lt;li&gt;リクエストをCloudfrontが受ける前にLambda@Edgeが処理をする(Lambda@Edge -&amp;gt; Cloudfront -&amp;gt; Origin)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CloudFront オリジンリクエスト
    &lt;ul&gt;
      &lt;li&gt;リクエストをCloudfrontが受けた後にLambda@Edgeが処理をする(Cloudfront -&amp;gt; Lambda@Edge -&amp;gt; Origin)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CloudFront オリジンレスポンス
    &lt;ul&gt;
      &lt;li&gt;オリジンからのレスポンスをCloudfrontに返却する前にLambda@Edgeが処理をする(Cloudfront &amp;lt;- Lambda@Edge &amp;lt;- Origin)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CloudFront ビューワーのレスポンス
    &lt;ul&gt;
      &lt;li&gt;Cloudfrontがクライアントにレスポンスを返却する前にLambda@Edgeが処理をする(Lambda@Edge &amp;lt;- Cloudfront &amp;lt;- Origin)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CloudFront オリジンリクエスト&lt;/strong&gt; で実行することを選択しましょう。これにより、Originの代わりにLambda@Edgeがレスポンスを返せるようになります。
&lt;code class=&quot;highlighter-rouge&quot;&gt;ビューワーリクエスト&lt;/code&gt; にしてしまうと、CDNのキャッシュが活用できなくなりますし、 &lt;code class=&quot;highlighter-rouge&quot;&gt;オリジンレスポンス&lt;/code&gt; にすると一度リクエストを受けるためのオリジンをS3などで作成しないといけなくなります。&lt;/p&gt;

&lt;h4 id=&quot;lambdaedgeからcloudfrontへのレスポンス形式に注意する&quot;&gt;Lambda@EdgeからCloudfrontへのレスポンス形式に注意する&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;オリジンリクエスト&lt;/code&gt; の場合、Lambda@EdgeからCloudfrontに返却するレスポンスの形式が以下のように定められているため、そちらに準拠する必要があります。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    body: 'content',
    bodyEncoding: 'text' | 'base64',
    headers: {
        'header name in lowercase': [{
            key: 'header name in standard case',
            value: 'header value'
         }],
         ...
    },
    status: 'HTTP status code',
    statusDescription: 'status description'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;これを愚直に実装するのは少々手間がかかるので、 &lt;a href=&quot;https://github.com/jgautheron/aws-serverless-express-edge&quot;&gt;aws-serverless-express-edge&lt;/a&gt; というnpmモジュールを使ってしまうのが早いです。&lt;/p&gt;

&lt;h3 id=&quot;cloudfrontで配信する&quot;&gt;Cloudfrontで配信する&lt;/h3&gt;

&lt;p&gt;最後にCloudfrontの配信設定を行います。Cloudfront自体の使い方は公式のドキュメントを読んでいただければ問題ないので、ここでも注意点にだけ触れておきます。&lt;/p&gt;

&lt;h4 id=&quot;lambda関数はpublishして使う&quot;&gt;Lambda関数はpublishして使う&lt;/h4&gt;

&lt;p&gt;Lambda@EdgeをCloudfrontと連携させる場合、&lt;strong&gt;Lambda関数はpublishしておく必要があります&lt;/strong&gt; 。
Cloudfrontでは実行するLambda@EdgeのARNをバージョン番号込みで指定する必要があり、&lt;code class=&quot;highlighter-rouge&quot;&gt;$LATEST&lt;/code&gt; による指定はサポート外であるため、
Lambda関数の更新の都度バージョンを上げていくスタイルになります。
一番良い方法としてオススメなのは、&lt;a href=&quot;https://www.terraform.io/&quot;&gt;Terraform&lt;/a&gt; を使ってCloudfrontとLambdaのコード化をしてしまうことです。&lt;/p&gt;

&lt;p&gt;Cloudfrontは設定項目が多いためTerraformに書き起こすのに時間がかかりますが、後々の更新コストを加味して早めに対応しておきましょう。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LambdaのTerraformサンプル&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;resource &quot;aws_lambda_function&quot; &quot;hogehoge&quot; {
    filename = &quot;../hogehoge.zip&quot;
    function_name = &quot;hoeghoge&quot;
    publish = true
    role = &quot;${EdgeLambdaForCloudfrontRoleのARN}&quot;
    handler = &quot;index.handler&quot;
    source_code_hash = &quot;${data.archive_file.hogehoge.output_base64sha256}&quot;
    runtime = &quot;nodejs6.10&quot;
    timeout = 30
}

data &quot;archive_file&quot; &quot;hogehoge&quot; {
    type = &quot;zip&quot;
    source_dir  = &quot;../workspace&quot;
    output_path = &quot;../hogehoge.zip&quot;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;CloudfrontのTerraformサンプル&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;resource &quot;aws_cloudfront_distribution&quot; &quot;hogehogefront_cloudfront&quot; {
    origin {
        domain_name = &quot;xxxx.soudegesu.com&quot;
        origin_id   = &quot;Custom-your-xxxx.soudegesu.com&quot;
        custom_origin_config {
            http_port = 80
            https_port = 443
            origin_protocol_policy = &quot;http-only&quot;
            origin_ssl_protocols = [&quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;]
        }
    }
    aliases = [&quot;xxxx.soudegesu.com&quot;]
    enabled = true
    is_ipv6_enabled = true
    comment = &quot;tools distribution&quot;

    default_cache_behavior {
        allowed_methods  = [&quot;GET&quot;, &quot;HEAD&quot;, &quot;OPTIONS&quot;]
        cached_methods   = [&quot;GET&quot;, &quot;HEAD&quot;]
        target_origin_id = &quot;Custom-xxxx.soudegesu.com&quot;

        forwarded_values {
            query_string = false

            cookies {
                forward = &quot;none&quot;
            }
        }

        viewer_protocol_policy = &quot;redirect-to-https&quot;
        min_ttl = 86400
        default_ttl = 604800
        max_ttl = 2592000
        compress = true
        lambda_function_association {
            event_type = &quot;origin-request&quot;
            lambda_arn = &quot;${aws_lambda_function.hogehoge.qualified_arn}&quot;
        }
    }

    viewer_certificate {
        acm_certificate_arn = &quot;${ACMのARN}&quot;
        minimum_protocol_version = &quot;TLSv1.1_2016&quot;
        ssl_support_method = &quot;sni-only&quot;
    }

    restrictions {
        geo_restriction {
            restriction_type = &quot;none&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ポイントなのは Cloudfront側の以下の部分で、&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    lambda_function_association {
        event_type = &quot;origin-request&quot;
        lambda_arn = &quot;${aws_lambda_function.hogehoge.qualified_arn}&quot;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;qualified_arn&lt;/code&gt; を指定すると、バージョン込のフルのARNにて変数展開がされます。
これにより、terraformを実行するだけで、LambdaのデプロイとCloudfrontの更新の両方ができるようになります。&lt;/p&gt;

&lt;h4 id=&quot;キャシュクリアをする2回目以降のデプロイ時&quot;&gt;キャシュクリアをする(2回目以降のデプロイ時)&lt;/h4&gt;

&lt;p&gt;CloudfrontはCDNサービスなので、デプロイ後にキャッシュをクリアして上げた方がよいです。&lt;/p&gt;

&lt;p&gt;AWSコンソールからCloudfrontのInvalidationsのタブを押します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180403/invalidations.png&quot; alt=&quot;invalidations&quot; /&gt;&lt;/p&gt;

&lt;p&gt;全てのURLのキャッシュをクリアしたいので、「*」を指定すればOKです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180403/invalidation_target.png&quot; alt=&quot;invalidation_target&quot; /&gt;&lt;/p&gt;

&lt;p&gt;なお、このキャッシュクリアに関してCloudfrontの料金ページでは、&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;月間で無効をリクエストしたパスの最初の 1,000 パスまでは追加料金なし。それ以降は、無効をリクエストしたパスごとに 0.005 USD かかります。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;と記載されているので、URLのパターンが増えてきたら、削除対象の指定パターンはもう少し工夫した方がいいかもしれません。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回、Cloudfront + Lambda@Edgeを用いてサーバレスでのwebコンテンツを配信する仕組みを構築しました。
実際にサンプルコンテンツを作成してみたのが &lt;a href=&quot;http://www.tools.soudegesu.com/&quot;&gt;こちら&lt;/a&gt; になります。
ブラウザの言語設定の情報を基に &lt;code class=&quot;highlighter-rouge&quot;&gt;ja&lt;/code&gt; か &lt;code class=&quot;highlighter-rouge&quot;&gt;en&lt;/code&gt; かにリダイレクトする機能(俗に言うi18n対応っぽいもの)を実現しています。&lt;/p&gt;

&lt;p&gt;1週間程寝かせてみた後のAWS Billing Dashboardは以下のようになりました。$1到達していないですね。素晴らしい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180403/billing_dashborad.png&quot; alt=&quot;billing dashboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;立ち上げ期のアクセスが少ないコンテンツでは、ランニングコストが大きくならないようにサーバレスで節約していきたいですね！&lt;/p&gt;

&lt;h2 id=&quot;参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/lambda-generating-http-responses.html&quot;&gt;Amazon Cloudfront 開発者ガイド&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>soudegesu</name></author><category term="aws" /><category term="lambda" /><category term="cloudfront" /><category term="serverless" /><summary type="html">このブログ自体は github-pages と cloudflare を使って無料でホスティングをしているのですが、稀に 「動的なwebコンテンツを提供したい」 と思うことがあります。今回はお金を節約しつつ、動的なwebコンテンツを提供する方法を紹介します。</summary></entry><entry><title type="html">springboot-webfluxのバックプレッシャーを体験してたらいい感じだった</title><link href="https://www.soudegesu.com/java/non-blocking-webflux/" rel="alternate" type="text/html" title="springboot-webfluxのバックプレッシャーを体験してたらいい感じだった" /><published>2018-03-16T00:00:00+09:00</published><updated>2018-03-16T00:00:00+09:00</updated><id>https://www.soudegesu.com/java/non-blocking-webflux</id><content type="html" xml:base="https://www.soudegesu.com/java/non-blocking-webflux/">&lt;p&gt;2018/3にリリースされた &lt;code class=&quot;highlighter-rouge&quot;&gt;springboot2&lt;/code&gt; から &lt;code class=&quot;highlighter-rouge&quot;&gt;spring5&lt;/code&gt; がバンドルされるようになりました。
リリースの中でも注目機能と言われている &lt;code class=&quot;highlighter-rouge&quot;&gt;webflux&lt;/code&gt; 、とりわけ &lt;code class=&quot;highlighter-rouge&quot;&gt;webflux&lt;/code&gt; が内包しているリアクティブプログラミングライブラリである &lt;code class=&quot;highlighter-rouge&quot;&gt;Reactor&lt;/code&gt; はspringユーザであれば気になるはずです。今回はバックプレッシャーがいい感じだったので、それをまとめてみました。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#今回作成したリポジトリ&quot; id=&quot;markdown-toc-今回作成したリポジトリ&quot;&gt;今回作成したリポジトリ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#routerfunctionを登録する&quot; id=&quot;markdown-toc-routerfunctionを登録する&quot;&gt;RouterFunctionを登録する&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#パフォーマンスを測定してみた&quot; id=&quot;markdown-toc-パフォーマンスを測定してみた&quot;&gt;パフォーマンスを測定してみた&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#環境情報&quot; id=&quot;markdown-toc-環境情報&quot;&gt;環境情報&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#バックプレッシャーを体験する&quot; id=&quot;markdown-toc-バックプレッシャーを体験する&quot;&gt;バックプレッシャーを体験する&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#springboot-webfluxは普通に生きている&quot; id=&quot;markdown-toc-springboot-webfluxは普通に生きている&quot;&gt;springboot-webfluxは普通に生きている&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#springboot-webmvcはやっぱり死んだ&quot; id=&quot;markdown-toc-springboot-webmvcはやっぱり死んだ&quot;&gt;springboot-webmvcはやっぱり死んだ&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#スレッド増加の傾向を見てみる&quot; id=&quot;markdown-toc-スレッド増加の傾向を見てみる&quot;&gt;スレッド増加の傾向を見てみる&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考にさせていただいたサイト&quot; id=&quot;markdown-toc-参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;今回作成したリポジトリ&quot;&gt;今回作成したリポジトリ&lt;/h2&gt;
&lt;p&gt;今回作成したリポジトリは &lt;a href=&quot;https://github.com/soudegesu/springboot-webflux-test&quot;&gt;こちら&lt;/a&gt; です。
全てローカル環境で動かせるように &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose&lt;/code&gt; でコンポーネント化してあるものの、 ローカルマシンのリソースを食い合うため、負荷試験をするときはLinuxサーバ上に展開することをオススメします。&lt;/p&gt;

&lt;h2 id=&quot;routerfunctionを登録する&quot;&gt;RouterFunctionを登録する&lt;/h2&gt;
&lt;p&gt;以下のような &lt;code class=&quot;highlighter-rouge&quot;&gt;RouterFunction&lt;/code&gt; を作成し、 &lt;code class=&quot;highlighter-rouge&quot;&gt;@Bean&lt;/code&gt; で登録しておきます。
RouterFunctionのレスポンスを返す部分はもう少しいい実装がありそうですが、一旦こうしました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RouterFunction&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Component
public class HelloWebClientHandler {

    @Value(&quot;${app.backend.uri}&quot;)
    private String baseUri;

    private static final String PATH = &quot;/test&quot;;

    public RouterFunction&amp;lt;ServerResponse&amp;gt; routes() {
        return RouterFunctions.route(
                RequestPredicates.GET(&quot;/hello&quot;)
                        .and(RequestPredicates.accept(MediaType.APPLICATION_JSON))
                , this::webclient);
    }

    private Mono&amp;lt;ServerResponse&amp;gt; webclient(ServerRequest req) {
        return WebClient.builder()
                .baseUrl(baseUri)
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON.toString())
                .build()
                .get()
                .uri(uriBuilder -&amp;gt; {
                    uriBuilder.path(PATH);
                    if (req.queryParam(&quot;time&quot;).isPresent()) {
                        uriBuilder.queryParam(&quot;time&quot;, req.queryParam(&quot;time&quot;).get());
                    }
                    return uriBuilder.build();
                })
                .accept(MediaType.APPLICATION_JSON)
                .exchange()
                .flatMap(response -&amp;gt;
                    ServerResponse.ok()
                            .contentType(MediaType.APPLICATION_JSON)
                            .body(response.bodyToMono(User.class), User.class)
                            .switchIfEmpty(ServerResponse.notFound().build())
                );
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;RouterFunctionを登録する側&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作成した &lt;code class=&quot;highlighter-rouge&quot;&gt;HelloWebClientHandler&lt;/code&gt; を登録します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Configuration
@EnableWebFlux
public class WebConfig extends DelegatingWebFluxConfiguration {
    // ~中略~

    @Bean
    RouterFunction&amp;lt;ServerResponse&amp;gt; route7(HelloWebClientHandler webClientHandler) {
        return webClientHandler.routes();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;あとは &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; メソッドを持ったクラスを作ってあげればspringbootアプリケーションは作成完了です。&lt;/p&gt;

&lt;h2 id=&quot;パフォーマンスを測定してみた&quot;&gt;パフォーマンスを測定してみた&lt;/h2&gt;
&lt;p&gt;springbootのjarファイルをEC2上に置いて実際にバックプレッシャーの効果を見てみましょう。&lt;/p&gt;

&lt;h3 id=&quot;環境情報&quot;&gt;環境情報&lt;/h3&gt;
&lt;p&gt;私のローカルマシン上からgatlingを実行し、EC2上のspringbootアプリケーションに負荷がけをします。
springbootアプリケーションは、バックエンドのmockサーバ(OpenRestyを使用)に対して &lt;code class=&quot;highlighter-rouge&quot;&gt;WebClient&lt;/code&gt; を使ってAsyncなHTTP通信を行います。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180316/architecture.png&quot; alt=&quot;architechture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;なお、EC2インスタンスは &lt;code class=&quot;highlighter-rouge&quot;&gt;t2.small&lt;/code&gt; を使用し、JVMへの割当メモリは &lt;code class=&quot;highlighter-rouge&quot;&gt;最大256M&lt;/code&gt; に設定しています。
また、バックプレッシャーを観測したいので、mockサーバではsleep処理を入れています。&lt;/p&gt;

&lt;h3 id=&quot;バックプレッシャーを体験する&quot;&gt;バックプレッシャーを体験する&lt;/h3&gt;
&lt;h4 id=&quot;springboot-webfluxは普通に生きている&quot;&gt;springboot-webfluxは普通に生きている&lt;/h4&gt;
&lt;p&gt;バックプレッシャーの効果を見てみましょう。
gatlingのリクエスト量と、mockサーバ側のsleep時間は以下です。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;gatlingのリクエスト&lt;/th&gt;
      &lt;th&gt;mockのsleep時間&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;150req/s&lt;/td&gt;
      &lt;td&gt;1s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180316/webflux-sleep-150.png&quot; alt=&quot;webflux-sleep-150&quot; /&gt;&lt;/p&gt;

&lt;p&gt;普通に全て200レスポンスが返却されていますね。すごい。&lt;/p&gt;

&lt;p&gt;次にsleep時間を &lt;code class=&quot;highlighter-rouge&quot;&gt;5s&lt;/code&gt; にして見てみます。
対照実験的な意味で &lt;code class=&quot;highlighter-rouge&quot;&gt;150req/s&lt;/code&gt; がよかったのですが、今回は私のマシンのパワー不足により &lt;code class=&quot;highlighter-rouge&quot;&gt;130&lt;/code&gt; までしか出ませんでした。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;gatlingのリクエスト&lt;/th&gt;
      &lt;th&gt;mockのsleep時間&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;130req/s&lt;/td&gt;
      &lt;td&gt;5s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180316/webflux-sleep-130-5s.png&quot; alt=&quot;webflux-sleep-130-5s&quot; /&gt;&lt;/p&gt;

&lt;p&gt;バックエンドサーバが5秒も応答待ちでも普通に200応答できていますね。&lt;/p&gt;

&lt;h4 id=&quot;springboot-webmvcはやっぱり死んだ&quot;&gt;springboot-webmvcはやっぱり死んだ&lt;/h4&gt;
&lt;p&gt;比較として、従来の &lt;code class=&quot;highlighter-rouge&quot;&gt;springboot-webmvc&lt;/code&gt; ではどうでしょう。
サーブレットコンテナはデフォルトの &lt;code class=&quot;highlighter-rouge&quot;&gt;embed-tomcat&lt;/code&gt; として、&lt;code class=&quot;highlighter-rouge&quot;&gt;application.yaml&lt;/code&gt; の設定もデフォルトとします。
また、mockへの通信を行う &lt;code class=&quot;highlighter-rouge&quot;&gt;HttpClient&lt;/code&gt; はConnectionPoolingから取得するように実装した上で以下の条件でリクエストを流してみました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;gatlingのリクエスト&lt;/th&gt;
      &lt;th&gt;mockのsleep時間&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;100req/s&lt;/td&gt;
      &lt;td&gt;1s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180316/mvc-sleep-100.png&quot; alt=&quot;mvc-sleep-100&quot; /&gt;&lt;/p&gt;

&lt;p&gt;うむ。やはりだめでしたか。&lt;/p&gt;

&lt;p&gt;一応、同条件にて、HttpClientのPool数も増やしたりして調整しましたが、エラーレスポンス件数が0にはなりませんでした。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180316/mvc-sleep-100-tuned.png&quot; alt=&quot;mvc-sleep-100-tuned&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;スレッド増加の傾向を見てみる&quot;&gt;スレッド増加の傾向を見てみる&lt;/h3&gt;
&lt;p&gt;負荷試験中のスレッドの増加傾向も見てみましょう。この観点は単純に &lt;code class=&quot;highlighter-rouge&quot;&gt;netty4&lt;/code&gt; vs &lt;code class=&quot;highlighter-rouge&quot;&gt;tomcat&lt;/code&gt; に依存する部分が大きいのですが、見てみましょう。&lt;/p&gt;

&lt;p&gt;webflux(Netty4)の場合は起動時からスレッド数が一定ですね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180316/webflux-thread.png&quot; alt=&quot;webflux-thread&quot; /&gt;&lt;/p&gt;

&lt;p&gt;tomcatはやはりリクエストをさばくためにスレッドが必要になってしまうため、増加傾向にあります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180316/tomcat-thread.png&quot; alt=&quot;tomcat-thread&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回は &lt;code class=&quot;highlighter-rouge&quot;&gt;springboot-webflux&lt;/code&gt; と &lt;code class=&quot;highlighter-rouge&quot;&gt;springboo-webmvc&lt;/code&gt; を比較して、バックプレッシャーがどんな感じかを確認しました。
梱包されている &lt;code class=&quot;highlighter-rouge&quot;&gt;netty4&lt;/code&gt; が持つnon-blockingな仕組みのおかげで、バックエンドサーバの遅延に引きずられることなくレスポンスを返却できていることがわかります。&lt;/p&gt;

&lt;p&gt;しかしながら、もちろん銀の弾丸ではなくて、実装する上でのデメリットや考慮ポイントが他のサイトを見ると情報が色々出てきます。
例えば、自身が書こうとしている処理がblockingな処理なのか、non-blockingな処理なのかを実装する側が気をつけないといけない、という点があります。
そのためには、ライブラリがどのように動いているかをきちんと把握しないといけないでしょう。
加えて、スレッドを共有する形でアプリケーションが動作するので、 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; をむやみに使わない方が良い気もしています。&lt;/p&gt;

&lt;p&gt;ただ、 tomcatでサポートしているServlet 3.1の非同期IOよりは良さそうなので、用法を見定めた上で使っていきたいですね。&lt;/p&gt;

&lt;h2 id=&quot;参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://acro-engineer.hatenablog.com/entry/2013/10/17/113216&quot;&gt;How to Migrate Netty 3 to 4 (Netty 番外編)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>soudegesu</name></author><category term="java" /><category term="spring" /><category term="webflux" /><category term="reactor" /><summary type="html">2018/3にリリースされた springboot2 から spring5 がバンドルされるようになりました。 リリースの中でも注目機能と言われている webflux 、とりわけ webflux が内包しているリアクティブプログラミングライブラリである Reactor はspringユーザであれば気になるはずです。今回はバックプレッシャーがいい感じだったので、それをまとめてみました。</summary></entry><entry><title type="html">EthereumでDApps開発のための開発環境を構築する(Truffle&amp;amp;Ganache接続まで)</title><link href="https://www.soudegesu.com/ethereum/ethereum-development-with-ganache/" rel="alternate" type="text/html" title="EthereumでDApps開発のための開発環境を構築する(Truffle&amp;Ganache接続まで)" /><published>2018-03-10T00:00:00+09:00</published><updated>2018-03-10T00:00:00+09:00</updated><id>https://www.soudegesu.com/ethereum/ethereum-development-with-ganache</id><content type="html" xml:base="https://www.soudegesu.com/ethereum/ethereum-development-with-ganache/">&lt;p&gt;&lt;a href=&quot;/ethereum/ethereum-development-environment/&quot;&gt;前回の記事&lt;/a&gt; で &lt;code class=&quot;highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; の開発環境の構築を行いました。
今回はさらに &lt;code class=&quot;highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; 用のフレームワークである &lt;code class=&quot;highlighter-rouge&quot;&gt;Truffle&lt;/code&gt; と &lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; を使ってローカルでの開発環境を整えようと思います。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#truffleとは&quot; id=&quot;markdown-toc-truffleとは&quot;&gt;Truffleとは&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ganacheとは&quot; id=&quot;markdown-toc-ganacheとは&quot;&gt;Ganacheとは&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#セットアップ&quot; id=&quot;markdown-toc-セットアップ&quot;&gt;セットアップ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#設定&quot; id=&quot;markdown-toc-設定&quot;&gt;設定&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#packagejson-の修正&quot; id=&quot;markdown-toc-packagejson-の修正&quot;&gt;package.json の修正&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#truffleを初期化する&quot; id=&quot;markdown-toc-truffleを初期化する&quot;&gt;truffleを初期化する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ganacheと接続する&quot; id=&quot;markdown-toc-ganacheと接続する&quot;&gt;Ganacheと接続する&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;truffleとは&quot;&gt;Truffleとは&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://truffleframework.com/&quot;&gt;Truffle&lt;/a&gt; は &lt;code class=&quot;highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; アプリケーションの開発効率を上げるためのフレームワークです。
ボイラープレート的な仕事をしてくれるところから始まり、 ネットワーク接続の設定管理や、ネットワークのマイグレーション実行や初期化、テストフレームワークをバンドルしていたりなど、一通り開発できるように準備を整えてくれます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180310/truffle.png&quot; alt=&quot;Truffle top&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ganacheとは&quot;&gt;Ganacheとは&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://truffleframework.com/ganache/&quot;&gt;Ganache&lt;/a&gt; はDAppsを開発時のテストをする際に使用するローカル用のプライベートネットワークを構築してくれます。自動マイニングしてくれるので、別でターミナルを立ち上げて、マイニング用のコマンドを実行する必要もありません。発生したトランザクションは順番にソートされて表示もされるので、動作確認も比較的容易にできると思います。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180310/ganache.png&quot; alt=&quot;Ganache top&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;セットアップ&quot;&gt;セットアップ&lt;/h2&gt;
&lt;p&gt;以前同様の記事を書きましたが、簡単におさらいします。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Etehreum のインストール&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew tap ethereum/ethereum
brew install ethereum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;nodenvのインストール&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;私の場合、ローカル環境のグローバルなnodeのバージョンを変更したくないので、 &lt;code class=&quot;highlighter-rouge&quot;&gt;nodenv&lt;/code&gt; を使って切り替えています。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install nodenv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;nodenv起動のために、 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt; に以下を追記します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export PATH=&quot;$PATH:$HOME/.nodenv/bin:&quot;
eval &quot;$(nodenv init --no-rehash -)&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;node(9.6.1)のインストールと設定&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nodenv install 9.6.1
nodenv local 9.6.1
node -v
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt; の作成&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm init
(面倒なので、以降はEnter)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;truffle&lt;/code&gt; のインストール&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install truffle@4.0.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;solidityのコンパイラ &lt;code class=&quot;highlighter-rouge&quot;&gt;solc&lt;/code&gt; のインストール&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install solc@0.4.18
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; のインストール&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://truffleframework.com/ganache/&quot;&gt;Ganache&lt;/a&gt; のページからインストーラを取得し実行する。&lt;/p&gt;

&lt;h2 id=&quot;設定&quot;&gt;設定&lt;/h2&gt;
&lt;h3 id=&quot;packagejson-の修正&quot;&gt;package.json の修正&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;truffle&lt;/code&gt; をグローバルインストールしていないので、&lt;code class=&quot;highlighter-rouge&quot;&gt;npm run&lt;/code&gt; でキックできるように &lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt; を修正します。
&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt; の &lt;code class=&quot;highlighter-rouge&quot;&gt;scripts&lt;/code&gt; ブロックを修正します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &quot;scripts&quot;: {
    &quot;truffle&quot;: &quot;truffle&quot;,
    &quot;develop&quot;: &quot;truffle develop&quot;,
    &quot;truffle-ganache&quot;: &quot;truffle migrate --compile-all --reset --network ganache&quot;,
    &quot;truffle-console&quot;: &quot;truffle console --network ganache&quot;
  },
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;truffleを初期化する&quot;&gt;truffleを初期化する&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm run truffle init 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;実行が完了すると、プロジェクトディレクトリにフォルダやファイルがジェネレートされます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tree -L 1

.
├── contracts
├── migrations
├── node_modules
├── package-lock.json
├── package.json
├── test
├── truffle-config.js
└── truffle.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;contracts&lt;/code&gt; ディレクトリ
    &lt;ul&gt;
      &lt;li&gt;コントラクトプログラムを配置する場所。&lt;code class=&quot;highlighter-rouge&quot;&gt;truffle init&lt;/code&gt; 時に &lt;code class=&quot;highlighter-rouge&quot;&gt;Migrations.sol&lt;/code&gt; が生成される&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;migrations&lt;/code&gt; ディレクトリ
    &lt;ul&gt;
      &lt;li&gt;マイグレーションスクリプトを配置する場所。 &lt;code class=&quot;highlighter-rouge&quot;&gt;truffle init&lt;/code&gt; 時に &lt;code class=&quot;highlighter-rouge&quot;&gt;1_initial_migrations.js&lt;/code&gt; が生成される。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt; ディレクトリ
    &lt;ul&gt;
      &lt;li&gt;作成したコントラクトプログラムのテストスクリプトを配置する場所。デフォルトで &lt;code class=&quot;highlighter-rouge&quot;&gt;mocha&lt;/code&gt; が使える。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;truffle.js&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;truffleの設定ファイル&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;truffle-config.js&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;truffle.jsと同じ。&lt;code class=&quot;highlighter-rouge&quot;&gt;PowerShell&lt;/code&gt; や &lt;code class=&quot;highlighter-rouge&quot;&gt;Git-bash&lt;/code&gt; 利用時にはこちらを編集する。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;私はMacユーザなので、&lt;code class=&quot;highlighter-rouge&quot;&gt;truffle-config.js&lt;/code&gt; は消してしまいます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rm truffle-config.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;ganacheと接続する&quot;&gt;Ganacheと接続する&lt;/h3&gt;

&lt;p&gt;次にインストール済みの &lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; を起動します。
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; はデフォルトで10個のアカウントを作成してくれます。指定がなければ1番上に表示されているアカウントが &lt;code class=&quot;highlighter-rouge&quot;&gt;coinbase&lt;/code&gt; になります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180310/boot_ganache.png&quot; alt=&quot;Boot Ganache&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ganacheが表示しているネットワークの情報を基に、&lt;code class=&quot;highlighter-rouge&quot;&gt;truffle.js&lt;/code&gt; を以下のように編集します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = {
  // See &amp;lt;http://truffleframework.com/docs/advanced/configuration&amp;gt;
  // to customize your Truffle configuration!
  networks: {
    ganache: {
      host: &quot;localhost&quot;,
      port: 7545,
      network_id: &quot;*&quot;
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt; に記載した npm scriptsのコマンドから &lt;code class=&quot;highlighter-rouge&quot;&gt;truffle-ganache&lt;/code&gt; を起動し、
Ganacheのマイグレーションを行います。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm run truffle-ganache
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ganacheの画面を見てみると1番上のアドレスの &lt;code class=&quot;highlighter-rouge&quot;&gt;balance&lt;/code&gt; (所有しているether) が &lt;code class=&quot;highlighter-rouge&quot;&gt;100&lt;/code&gt; → &lt;code class=&quot;highlighter-rouge&quot;&gt;99.97&lt;/code&gt; に減っています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180310/migration_ganache.png&quot; alt=&quot;migration Ganache&quot; /&gt;&lt;/p&gt;

&lt;p&gt;実はこれ、&lt;code class=&quot;highlighter-rouge&quot;&gt;npm run truffle-ganache&lt;/code&gt; 実行により、&lt;code class=&quot;highlighter-rouge&quot;&gt;migrations/1_initial_migrations.js&lt;/code&gt; が実行され、
そこから &lt;code class=&quot;highlighter-rouge&quot;&gt;contracts/Migrations.sol&lt;/code&gt; がデプロイされています。
そのマイグレーションの処理自体もトランザクションが行われており、ganacheに &lt;code class=&quot;highlighter-rouge&quot;&gt;gas&lt;/code&gt; をお支払いしたため少しだけ減っています。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TRANSACTIONS&lt;/code&gt; タブを押すと、トランザクションハッシュが生成されていることを確認できます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180310/transaction_ganache.png&quot; alt=&quot;transaction Ganache&quot; /&gt;&lt;/p&gt;

&lt;p&gt;また、対話形式でプログラムを書きたい場合には以下のようにコンソールを立ち上げて、&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm run truffle-console
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;試しに以下のようなコードを実行すると&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;web3.eth.sendTransaction({from: web3.eth.accounts[0], to: web3.eth.accounts[1], value:web3.toWei(5, &quot;ether&quot;)})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;トランザクションのアドレスが帰ってきます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;  '0x046714fb412724c656250e5856bbb83469e2811b5d710bfa3c515606f5ff938a'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; の方を確認すると、ちゃんとトランザクションが反映されていることがわかりますね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180310/transaction_sample.png&quot; alt=&quot;transaction sample&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回は &lt;code class=&quot;highlighter-rouge&quot;&gt;Truffle&lt;/code&gt; でローカル環境構築をした後、 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; のネットワークに接続設定をして、マイグレーションまでを行いました。
&lt;code class=&quot;highlighter-rouge&quot;&gt;Truffle&lt;/code&gt; と &lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; を使うことで、素の &lt;code class=&quot;highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; 単体で開発するよりも、開発環境周辺の手間が軽減されるので、これから積極的に使っていきたいと思います。
ここまでできれば、次は &lt;code class=&quot;highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; によるコントラクトの開発と、テストコードによる動作確認です。&lt;/p&gt;</content><author><name>soudegesu</name></author><category term="ethereum" /><category term="truffle" /><category term="ganache" /><category term="dapps" /><summary type="html">前回の記事 で Ethereum の開発環境の構築を行いました。 今回はさらに Ethereum 用のフレームワークである Truffle と Ganache を使ってローカルでの開発環境を整えようと思います。</summary></entry><entry><title type="html">EthereumでDApps開発のための開発環境を構築する(Ethereumで別アカウントに送金まで)</title><link href="https://www.soudegesu.com/ethereum/ethereum-development-environment/" rel="alternate" type="text/html" title="EthereumでDApps開発のための開発環境を構築する(Ethereumで別アカウントに送金まで)" /><published>2018-03-05T00:00:00+09:00</published><updated>2018-03-05T00:00:00+09:00</updated><id>https://www.soudegesu.com/ethereum/ethereum-development-environment</id><content type="html" xml:base="https://www.soudegesu.com/ethereum/ethereum-development-environment/">&lt;p&gt;以前、&lt;code class=&quot;highlighter-rouge&quot;&gt;IPFS&lt;/code&gt; を調査したことがあり、そこから &lt;code class=&quot;highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; の存在を知りました。
昨年頃から本格的に日本でも名前が売れてきて、日本語のソースも増えてきたこともあるので、これを機にサンプルでも作成しようかと思いました。
今回はDApps開発のための下準備までを纏めます。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#環境情報&quot; id=&quot;markdown-toc-環境情報&quot;&gt;環境情報&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#etehreumのセットアップ&quot; id=&quot;markdown-toc-etehreumのセットアップ&quot;&gt;Etehreumのセットアップ&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ethereumのインストール&quot; id=&quot;markdown-toc-ethereumのインストール&quot;&gt;Ethereumのインストール&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#設定ファイルの作成&quot; id=&quot;markdown-toc-設定ファイルの作成&quot;&gt;設定ファイルの作成&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#プライベートネットワークの初期化&quot; id=&quot;markdown-toc-プライベートネットワークの初期化&quot;&gt;プライベートネットワークの初期化&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#アカウントの作成&quot; id=&quot;markdown-toc-アカウントの作成&quot;&gt;アカウントの作成&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#マイニングの動作確認をする&quot; id=&quot;markdown-toc-マイニングの動作確認をする&quot;&gt;マイニングの動作確認をする&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#別アカウントにethを送ってみる&quot; id=&quot;markdown-toc-別アカウントにethを送ってみる&quot;&gt;別アカウントにEthを送ってみる&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考にさせていただいたサイト&quot; id=&quot;markdown-toc-参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;環境情報&quot;&gt;環境情報&lt;/h2&gt;
&lt;p&gt;今回、私は以下の環境にて構築を行いました&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Mac Book Pro
    &lt;ul&gt;
      &lt;li&gt;OS: High Seria 10.13.2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Homebrew
    &lt;ul&gt;
      &lt;li&gt;1.5.6&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;etehreumのセットアップ&quot;&gt;Etehreumのセットアップ&lt;/h2&gt;
&lt;p&gt;今回は &lt;a href=&quot;https://www.ethereum.org/&quot;&gt;Ethereum&lt;/a&gt; を使用します。理由としては、DApps開発のためのOSSとして開発が積極的に行われており、
様々なDAppsにて使用されている(らしい)からです。&lt;/p&gt;

&lt;h3 id=&quot;ethereumのインストール&quot;&gt;Ethereumのインストール&lt;/h3&gt;
&lt;p&gt;Homebrewがあれば簡単にインストールができます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;リポジトリを追加&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew tap ethereum/ethereum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Ethereum をインストール&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install ethereum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;バージョンを確認&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth -h

&amp;gt; NAME:
&amp;gt;    geth - the go-ethereum command line interface
&amp;gt;
&amp;gt;    Copyright 2013-2017 The go-ethereum Authors
&amp;gt;
&amp;gt; USAGE:
&amp;gt;    geth [options] command [command options] [arguments...]
&amp;gt;
&amp;gt; VERSION:
&amp;gt;    1.8.1-stable
(以下略)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1.8.1&lt;/code&gt; がインストールされているようですね。&lt;/p&gt;

&lt;p&gt;以降の作業は以下のディレクトリにて実施します。(誤解を招かないように念のため)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pwd
&amp;gt; /Users/xxxxxx/workspace/eth_private_net
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;設定ファイルの作成&quot;&gt;設定ファイルの作成&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; の 1.6から &lt;code class=&quot;highlighter-rouge&quot;&gt;puppeth&lt;/code&gt; コマンドが追加されました。
これを使って初期化を行います。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;puppeth
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;すると以下のようなメッセージが出てくるので、とりあえずネットワーク名を任意の名前にします。
今回は &lt;code class=&quot;highlighter-rouge&quot;&gt;soudegesu&lt;/code&gt; にしました。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-----------------------------------------------------------+
| Welcome to puppeth, your Ethereum private network manager |
|                                                           |
| This tool lets you create a new Ethereum network down to  |
| the genesis block, bootnodes, miners and ethstats servers |
| without the hassle that it would normally entail.         |
|                                                           |
| Puppeth uses SSH to dial in to remote servers, and builds |
| its network components out of Docker containers using the |
| docker-compose toolset.                                   |
+-----------------------------------------------------------+

Please specify a network name to administer (no spaces, please)
&amp;gt; soudegesu
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以降も対話形式で入力していきます。まず、 &lt;code class=&quot;highlighter-rouge&quot;&gt;2. Configure new genesis&lt;/code&gt; を選択します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sweet, you can set this via --network=soudegesu next time!

INFO [03-05|14:24:17] Administering Ethereum network           name=soudegesu
WARN [03-05|14:24:17] No previous configurations found         path=/Users/xxxxxxxxx/.puppeth/soudegesu

What would you like to do? (default = stats)
 1. Show network stats
 2. Configure new genesis
 3. Track new remote server
 4. Deploy network components
&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;次にコンセンサスルールを決めます。今回は &lt;code class=&quot;highlighter-rouge&quot;&gt;Ethash&lt;/code&gt; にしましょう。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Which consensus engine to use? (default = clique)
 1. Ethash - proof-of-work
 2. Clique - proof-of-authority
&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;次はとりあえずデフォルトにしておきます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Which accounts are allowed to seal? (mandatory at least one)
&amp;gt; 0x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;次に使用するネットワークIDを指定します。
適当に &lt;code class=&quot;highlighter-rouge&quot;&gt;4224&lt;/code&gt; にします。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Specify your chain/network ID if you want an explicit one (default = random)
&amp;gt; 4224
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;なお、代表的なnetwork idは以下のようになっています。
今回はローカル環境で動かすだけですが、重複しないようにしておきましょう。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;: Mainnet&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;: Morden test net(obsolete)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;: Ropsten test net&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;: Rinkeby test net&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;42&lt;/code&gt;: Kovan test net&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次にgenesisの設定管理を選択します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;What would you like to do? (default = stats)
 1. Show network stats
 2. Manage existing genesis
 3. Track new remote server
 4. Deploy network components
&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;genesisの設定をエクスポートします。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1. Modify existing fork rules
 2. Export genesis configuration
 3. Remove genesis configuration
&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;次はデフォルトでOK&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Which file to save the genesis into? (default = soudegesu.json)
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ココまで来ると &lt;code class=&quot;highlighter-rouge&quot;&gt;Exported existing genesis block&lt;/code&gt; と表示され、コンソール上の表示が最初に戻ります。
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl + C&lt;/code&gt; にてexitしましょう。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;soudegesu.json&lt;/code&gt; が作成されていることが確認できます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat soudegesu.json

{
  &quot;config&quot;: {
    &quot;chainId&quot;: 4224,
    &quot;homesteadBlock&quot;: 1,
    &quot;eip150Block&quot;: 2,
    &quot;eip150Hash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
    &quot;eip155Block&quot;: 3,
    &quot;eip158Block&quot;: 3,
    &quot;byzantiumBlock&quot;: 4,
    &quot;ethash&quot;: {}
  },
  &quot;nonce&quot;: &quot;0x0&quot;,
  &quot;timestamp&quot;: &quot;0x5a9cd72a&quot;,
  &quot;extraData&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;gasLimit&quot;: &quot;0x47b760&quot;,
  &quot;difficulty&quot;: &quot;0x80000&quot;,
  &quot;mixHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;,
  &quot;alloc&quot;: {
    &quot;0000000000000000000000000000000000000000&quot;: {
      &quot;balance&quot;: &quot;0x1&quot;
    },
    (以下略)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;プライベートネットワークの初期化&quot;&gt;プライベートネットワークの初期化&lt;/h3&gt;

&lt;p&gt;次にネットワークの初期化を行います。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth --datadir ./private init ./soudegesu.json

INFO [03-05|14:54:31] Maximum peer count                       ETH=25 LES=0 total=25
INFO [03-05|14:54:31] Allocated cache and file handles         database=/Users/xxxxxx/workspace/eth_private_net/private/geth/chaindata cache=16 handles=16
INFO [03-05|14:54:31] Writing custom genesis block
INFO [03-05|14:54:31] Persisted trie from memory database      nodes=354 size=65.02kB time=1.10945ms gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [03-05|14:54:31] Successfully wrote genesis state         database=chaindata                                                              hash=25e489…52b7d1
INFO [03-05|14:54:31] Allocated cache and file handles         database=/Users/xxxxxx/workspace/eth_private_net/private/geth/lightchaindata cache=16 handles=16
INFO [03-05|14:54:31] Writing custom genesis block
INFO [03-05|14:54:31] Persisted trie from memory database      nodes=354 size=65.02kB time=1.327455ms gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [03-05|14:54:31] Successfully wrote genesis state         database=lightchaindata                                                              hash=25e489…52b7d1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;アカウントの作成&quot;&gt;アカウントの作成&lt;/h3&gt;

&lt;p&gt;ether(wei) をやりとりするためのアカウントを作成します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth --datadir . account new
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;適当にパスワードを設定すると &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; のところにアカウントのアドレスが表示されます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Your new account is locked with a password. Please give a password. Do not forget this password.
Passphrase:
Repeat passphrase:
Address: {アカウントA}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;作成が完了すると &lt;code class=&quot;highlighter-rouge&quot;&gt;keystore&lt;/code&gt; ディレクトリ下にユーザ情報が記載されたjsonファイルが出力されます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ls keystore

UTC--2018-03-05T06-00-32.829542689Z--アカウントA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;作成されたアカウントを確認します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth --datadir . account list
Account #0: {アカウントA} keystore:///Users/xxxxx/workspace/eth_private_net/keystore/UTC--2018-03-05T06-00-32.829542689Z--アカウントA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;後の行程で、複数ユーザ間でデータをやりとりする仕組みを試してみるため、
 &lt;code class=&quot;highlighter-rouge&quot;&gt;geth --datadir . account new&lt;/code&gt; コマンドを複数実行し、アカウントを複数作っておきましょう。(とりあえず3つくらい)&lt;/p&gt;

&lt;h3 id=&quot;マイニングの動作確認をする&quot;&gt;マイニングの動作確認をする&lt;/h3&gt;
&lt;p&gt;次にマイニングの動作確認をします。&lt;/p&gt;

&lt;p&gt;先程作成した &lt;code class=&quot;highlighter-rouge&quot;&gt;keystore&lt;/code&gt; の情報を移動します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp ~/workspace/eth_private_net/keystore/* ~/workspace/eth_private_net/private/keystore/.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;作成したユーザのパスワードファイルを作成します。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo (account new する時に指定したパスワード) &amp;gt; private/password.sec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;実行してみましょう。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth --networkid 4224 --mine --minerthreads 1 --datadir &quot;~/workspace/eth_private_net/private&quot; --nodiscover --rpc --rpcport &quot;8545&quot; --port &quot;30303&quot; --rpccorsdomain &quot;*&quot; --nat &quot;any&quot; --rpcapi eth,web3,personal,net --unlock 0 --password ~/workspace/eth_private_net/private/password.sec --ipcpath &quot;~/Library/Ethereum/geth.ipc&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;その際に、標準出力に表示される &lt;code class=&quot;highlighter-rouge&quot;&gt;ChainID&lt;/code&gt; が指定されたIDになっているかを確認しましょう。
今回であれば &lt;strong&gt;4224&lt;/strong&gt; が出ていればOKです。&lt;/p&gt;

&lt;p&gt;処理がもりもり走っていきます。ハンマーアイコンが出てくればマイニングできています。
(もちろんテスト用なので、何の価値もないですが)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180305/chained.png&quot; alt=&quot;mining&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;別アカウントにethを送ってみる&quot;&gt;別アカウントにEthを送ってみる&lt;/h3&gt;
&lt;p&gt;先程複数アカウントを作成したので、実際にetherを送ってみましょう。
ターミナル上のマイニングの画面はそのままにして、ターミナルの別ウィンドウを立ち上げましょう。&lt;/p&gt;

&lt;p&gt;その後、以下を実行し、Javascriptコンソールを起動します。
コンソールは対話形式で入力していくことが可能です。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth attach

instance: Geth/v1.8.1-stable/darwin-amd64/go1.10
coinbase: xxxxxxxxxxxxxxxxxxxxxxxxxx
at block: 23 (Mon, 05 Mar 2018 15:39:56 JST)
 datadir: /Users/xxxxxx/workspace/eth_private_net/private
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;まず存在するアカウントを確認しておきます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; eth.accounts
[&quot;アカウントA&quot;, &quot;アカウントB&quot;, &quot;アカウントC&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;マイニング時のメインアカウントを確認します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; eth.coinbase
アカウントA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;現時点での保有量を確認します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; eth.getBalance(eth.accounts[0])
285000000000000000000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;単位が &lt;code class=&quot;highlighter-rouge&quot;&gt;wei&lt;/code&gt; でわかりにくいので &lt;code class=&quot;highlighter-rouge&quot;&gt;ether&lt;/code&gt; にしましょう。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; web3.fromWei(eth.getBalance(eth.coinbase), &quot;ether&quot;)
288
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;アカウントAから他のアカウントBとアカウントCにそれぞれ送りつけてみましょう。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# アカウントA -&amp;gt; アカウントB へ10 ether送る
eth.sendTransaction({from:eth.accounts[0], to:eth.accounts[1], value:web3.toWei(10, &quot;ether&quot;)})
&amp;gt; ハッシュ値
# アカウントA -&amp;gt; アカウントC へ6 ether送る
eth.sendTransaction({from:eth.accounts[0], to:eth.accounts[2], value:web3.toWei(6, &quot;ether&quot;)})
&amp;gt; ハッシュ値
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以下で確認することができました。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; web3.fromWei(eth.getBalance(eth.accounts[1]), &quot;ether&quot;)
10
&amp;gt; web3.fromWei(eth.getBalance(eth.accounts[2]), &quot;ether&quot;)
6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;駆け足でしたが、今回はざっくり以下まで実施できました。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; のインストール&lt;/li&gt;
  &lt;li&gt;開発用のConfigファイルの作成&lt;/li&gt;
  &lt;li&gt;アカウントの作成&lt;/li&gt;
  &lt;li&gt;マイニング&lt;/li&gt;
  &lt;li&gt;複数アカウント間の送金&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この後、&lt;code class=&quot;highlighter-rouge&quot;&gt;Ganache&lt;/code&gt; や &lt;code class=&quot;highlighter-rouge&quot;&gt;truffle&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;Metamask&lt;/code&gt; のセットアップ、 &lt;code class=&quot;highlighter-rouge&quot;&gt;web3&lt;/code&gt; での開発作業があるのですが、
長くなりそうなので、今回はここで一旦切ろうと思います。&lt;/p&gt;

&lt;p&gt;ローカルとはいえ、マイニングされていく様を見ると少しそわそわしますね。&lt;/p&gt;

&lt;p&gt;genesisファイルやコマンドの細かい部分は完全にすっ飛ばしており、私もまだまだ理解が浅いので、
様々なソースを見ながら引き続き学習したいと思います。&lt;/p&gt;

&lt;p&gt;(いやぁ、しかし、早く &lt;a href=&quot;https://github.com/ethereumbook/ethereumbook&quot;&gt;Mastering Ethereum&lt;/a&gt; 発売されないかな)&lt;/p&gt;

&lt;h2 id=&quot;参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.ethereum.org/2017/04/14/geth-1-6-puppeth-master/&quot;&gt;Ethereum blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>soudegesu</name></author><category term="ethereum" /><category term="dapps" /><category term="truffle" /><category term="ganache" /><category term="metamask" /><summary type="html">以前、IPFS を調査したことがあり、そこから Ethereum の存在を知りました。 昨年頃から本格的に日本でも名前が売れてきて、日本語のソースも増えてきたこともあるので、これを機にサンプルでも作成しようかと思いました。 今回はDApps開発のための下準備までを纏めます。</summary></entry><entry xml:lang="ja"><title type="html">Udemyでサイバーセキュリティコース「The Complete Cyber Security Course : Hackers Exposed」を受講した</title><link href="https://www.soudegesu.com/security/take-udemy-cyber-security-hacker-exposed/" rel="alternate" type="text/html" title="Udemyでサイバーセキュリティコース「The Complete Cyber Security Course : Hackers Exposed」を受講した" /><published>2018-02-26T00:00:00+09:00</published><updated>2018-02-26T00:00:00+09:00</updated><id>https://www.soudegesu.com/security/take-udemy-cyber-security-hacker-exposed</id><content type="html" xml:base="https://www.soudegesu.com/security/take-udemy-cyber-security-hacker-exposed/">&lt;p&gt;昨今の仮想通貨流出問題を受けて、システム開発に携わるエンジニアにとって、セキュリティの専門家でなくても、サイバーセキュリティに関する学習の必要性を感じている方はいらっしゃるのではないでしょうか。
かくいう私もその口で、今回は &lt;a href=&quot;https://www.udemy.com/&quot;&gt;Udemy&lt;/a&gt; というオンライン学習プラットフォームを活用してサイバーセキュリティの基礎を学んだ感想を書きます。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#udemyとは何か&quot; id=&quot;markdown-toc-udemyとは何か&quot;&gt;Udemyとは何か&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#学習のため購入したコンテンツ&quot; id=&quot;markdown-toc-学習のため購入したコンテンツ&quot;&gt;学習のため購入したコンテンツ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#なぜこのコンテンツにしたのか&quot; id=&quot;markdown-toc-なぜこのコンテンツにしたのか&quot;&gt;なぜこのコンテンツにしたのか&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#レベル感が視聴者私に合ってそうだったから&quot; id=&quot;markdown-toc-レベル感が視聴者私に合ってそうだったから&quot;&gt;レベル感が視聴者(私)に合ってそうだったから&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#有料コンテンツのしかもトップヒットだから&quot; id=&quot;markdown-toc-有料コンテンツのしかもトップヒットだから&quot;&gt;有料コンテンツのしかも「トップヒット」だから&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#英語のコンテンツだから&quot; id=&quot;markdown-toc-英語のコンテンツだから&quot;&gt;英語のコンテンツだから&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#実際に受けてみた感想&quot; id=&quot;markdown-toc-実際に受けてみた感想&quot;&gt;実際に受けてみた感想&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#良かった点&quot; id=&quot;markdown-toc-良かった点&quot;&gt;良かった点&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#包括的かつ理解しやすいコンテンツだった&quot; id=&quot;markdown-toc-包括的かつ理解しやすいコンテンツだった&quot;&gt;包括的かつ理解しやすいコンテンツだった&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#サイバー犯罪スーパーハカーの仕業という幻想を壊せた&quot; id=&quot;markdown-toc-サイバー犯罪スーパーハカーの仕業という幻想を壊せた&quot;&gt;サイバー犯罪＝スーパーハカーの仕業という幻想を壊せた&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#未知の領域の学習は映像がオススメ&quot; id=&quot;markdown-toc-未知の領域の学習は映像がオススメ&quot;&gt;未知の領域の学習は映像がオススメ&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#反省点&quot; id=&quot;markdown-toc-反省点&quot;&gt;反省点&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#コースコンテンツをちゃんと読めば良かった&quot; id=&quot;markdown-toc-コースコンテンツをちゃんと読めば良かった&quot;&gt;コースコンテンツをちゃんと読めば良かった&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;udemyとは何か&quot;&gt;Udemyとは何か&lt;/h2&gt;
&lt;p&gt;Udemyはオンライン学習プラットフォームです。自身の目的に合った学習コンテンツを購入し、オンラインで受講することができます。
今回はサイバーセキュリティのコンテンツを購入したのですが、&lt;code class=&quot;highlighter-rouge&quot;&gt;Robotics&lt;/code&gt; や &lt;code class=&quot;highlighter-rouge&quot;&gt;機械学習&lt;/code&gt; のような別のIT分野の授業もありますし、
&lt;code class=&quot;highlighter-rouge&quot;&gt;投資信託&lt;/code&gt; のような経済系のコンテンツ等の幅広いジャンルの取り扱いがあります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180226/about_udemy.png&quot; alt=&quot;about_udemy&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;学習のため購入したコンテンツ&quot;&gt;学習のため購入したコンテンツ&lt;/h2&gt;
&lt;p&gt;今回はUdemyの中でもサイバーセキュリティのコンテンツのジャンルの中で人気のコンテンツ &lt;a href=&quot;https://www.udemy.com/the-complete-internet-security-privacy-course-volume-1/&quot;&gt;「The Complete Cyber Security Course : Hackers Exposed!」&lt;/a&gt; を購入しました。
価格は &lt;code class=&quot;highlighter-rouge&quot;&gt;1,300円&lt;/code&gt; ほどで、クレジットカードでお支払いです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180226/cyber_security.png&quot; alt=&quot;cyber_security&quot; /&gt;&lt;/p&gt;

&lt;p&gt;この &lt;code class=&quot;highlighter-rouge&quot;&gt;The Complete Cyber Security Course&lt;/code&gt; シリーズは全部で以下4つのコースが提供されており、先に進む程応用的な内容になっているそうです。(全部まだ受けていないので、伝聞で書いています)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The Complete Cyber Security Course : Hackers Exposed!&lt;/li&gt;
  &lt;li&gt;The Complete Cyber Security Course : Network Security!&lt;/li&gt;
  &lt;li&gt;The Complete Cyber Security Course : Anonymous Browsing!&lt;/li&gt;
  &lt;li&gt;The Complete Cyber Security Course : End Point Protection!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ちなみにPart.1は全編英語、約11時間のコースでした。&lt;/p&gt;

&lt;h2 id=&quot;なぜこのコンテンツにしたのか&quot;&gt;なぜこのコンテンツにしたのか&lt;/h2&gt;
&lt;p&gt;類似のオンライン学習サービスとしては&lt;a href=&quot;https://www.coursera.org/&quot;&gt;coursera&lt;/a&gt; や &lt;a href=&quot;https://www.cybrary.it/&quot;&gt;cybrary&lt;/a&gt;などもあります。しかし、今回は以下の理由でUdemyのコンテンツ購入としました。&lt;/p&gt;

&lt;h3 id=&quot;レベル感が視聴者私に合ってそうだったから&quot;&gt;レベル感が視聴者(私)に合ってそうだったから&lt;/h3&gt;

&lt;p&gt;まず私のサイバーセキュリティに関連しそうなシステム開発に略歴をざっくり記載すると&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;webアプリケーション開発経験7年程度&lt;/li&gt;
  &lt;li&gt;OSはCentOS/Amazon Linuxを中心に利用(Qubes OSやDebianはない)&lt;/li&gt;
  &lt;li&gt;インフラはAWSを利用しており、IAM制御/SecurityGroup設定/ルーティング程度なら自力でできる&lt;/li&gt;
  &lt;li&gt;ハードウェアや通信回線の知識は皆無&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;のような感じです。つまり、サイバーセキュリティはど素人です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cybrary.it/&quot;&gt;cybrary&lt;/a&gt;はセキュリティを中心にしたコンテンツが出揃っているのですが、
いきなりピンポイントなテーマを学習する気はなく、まずは全体感がわかるものを探しました。
なお、 &lt;a href=&quot;https://www.coursera.org/&quot;&gt;coursera&lt;/a&gt; にはサイバーセキュリティのジャンル自体がほとんど見当たらなかったので、
その時点で落選です。&lt;/p&gt;

&lt;h3 id=&quot;有料コンテンツのしかもトップヒットだから&quot;&gt;有料コンテンツのしかも「トップヒット」だから&lt;/h3&gt;

&lt;p&gt;完全に私の偏見ですが、コンテンツのレベル感が自分にフィットしていれば、以下の方程式は概ね成立すると考えています。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「外国人」+「有料」+「トップヒット」＝ 間違いない&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;そもそもUdemyは有料のコンテンツがほとんどです(無料も極稀にある)。
以前、外国人講師の方が開催されている研修で、同じテーマを題材とした無料版と有料版の両方を受けたことがあるのですが、
有料版の方が得られるエッセンスが非常に多かったです。「良い知識や経験はお金を払ってでも取りに行くべき」というやつです。
そのため、「可能であれば有料のコンテンツを受けた方が良い」と考えています。&lt;/p&gt;

&lt;p&gt;加えて、講師の方のプロフィールがコンテンツ購入画面に記載されているのですが、
サイバーセキュリティを生業にされている会社のCEOの方でしたので、専門性も疑う所はありませんでした。&lt;/p&gt;

&lt;h3 id=&quot;英語のコンテンツだから&quot;&gt;英語のコンテンツだから&lt;/h3&gt;

&lt;p&gt;いわゆる業界用語的なものをインプットしておきたかったのと、
業界的に海外の方がサイバーセキュリティは進んでいるであろうと思ったからです。&lt;/p&gt;

&lt;h2 id=&quot;実際に受けてみた感想&quot;&gt;実際に受けてみた感想&lt;/h2&gt;
&lt;p&gt;ここからは実際に受講したみた感想を纏めます。&lt;/p&gt;

&lt;h3 id=&quot;良かった点&quot;&gt;良かった点&lt;/h3&gt;
&lt;h4 id=&quot;包括的かつ理解しやすいコンテンツだった&quot;&gt;包括的かつ理解しやすいコンテンツだった&lt;/h4&gt;
&lt;p&gt;まず、コンテンツ全体の感想を先に書くと、内容は包括的でした。
ざっくりと以下の内容が盛り込まれていました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;身の回りにあるサイバー攻撃の全体像&lt;/li&gt;
  &lt;li&gt;情報盗聴に関する世界情勢&lt;/li&gt;
  &lt;li&gt;サイバー犯罪に対処するための基本的な考え方(予防・検知・追跡)&lt;/li&gt;
  &lt;li&gt;マルウェアなどに感染させるために取られる手段&lt;/li&gt;
  &lt;li&gt;ハッカーが使っているツール&lt;/li&gt;
  &lt;li&gt;暗号化通信&lt;/li&gt;
  &lt;li&gt;ソーシャルハッキング&lt;/li&gt;
  &lt;li&gt;OSやブラウザごとのセキュリティ対策の仕方&lt;/li&gt;
  &lt;li&gt;ホストOSやゲストOSでハードのシリアル番号の見方と改ざん方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらが全13章120項で構成されているのですが、1項が長くても20分程度のコンテンツであるため、隙間時間を学習に充てることができました。&lt;/p&gt;

&lt;p&gt;また、講師の方の英語についても&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;話すスピードも丁度いい(聞き取れる)&lt;/li&gt;
  &lt;li&gt;発音も聞き取り易い&lt;/li&gt;
  &lt;li&gt;単語がゆらがない(表現がある程度一定)&lt;/li&gt;
  &lt;li&gt;字幕もついてるのでググれる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;であり、英語はそこまで上手でない私でも十分ついて行けました。&lt;/p&gt;

&lt;h4 id=&quot;サイバー犯罪スーパーハカーの仕業という幻想を壊せた&quot;&gt;サイバー犯罪＝スーパーハカーの仕業という幻想を壊せた&lt;/h4&gt;
&lt;p&gt;サイバーセキュリティの勉強を始める前には「サイバー犯罪はウィザード級のスーパーハカーの仕業である」と考えていました。
それこそ、シュタインズ・ゲートに出てくる橋田至や、ブラックラグーンに出てくるベニーのようなやばいヤツらのイメージです。&lt;/p&gt;

&lt;p&gt;しかし、「そのような凄腕のハッカーによるサイバー犯罪は全体の1割にも満たない」という情報にバイアスは一蹴されました。
サイバー犯罪の大多数は比較的フツーの人、それこそ、子供や主婦ですらやっていますよ、というのです。
出回っている多くのツールを駆使したり、人を騙すためのちょっとしたトリックをうまく活用することで、ごくごく日常的に行われているそうです。&lt;/p&gt;

&lt;p&gt;「世間の人がふつうにできるのであれば、私もできるだろう」という妙な自身が沸いてきました。&lt;/p&gt;

&lt;h4 id=&quot;未知の領域の学習は映像がオススメ&quot;&gt;未知の領域の学習は映像がオススメ&lt;/h4&gt;
&lt;p&gt;これは過去の経験も踏まえてなのですが、私の中で「未知の分野の学習に関しては、映像を通じての学習の方が学習効率がいい」という風に感じました。
講師の方がちゃんと筋道を立ててくれているので(もちろん講師の方の手腕に寄るものですが)、情報の強弱がきちんと整理されているので、変な所に固執せずに進めることができますし、時系列に添って情報が展開されてくる(例えばライブコーディングのように順序立てて理解できる)ところが素人には有り難いです。
書籍もいいのですが、動画よりも情報量が多くなり、案外有用な情報を読み飛ばしたり誤解しがちです。&lt;/p&gt;

&lt;p&gt;拘束時間があるのは仕方がないかな、と割り切っています。&lt;/p&gt;

&lt;h3 id=&quot;反省点&quot;&gt;反省点&lt;/h3&gt;
&lt;h4 id=&quot;コースコンテンツをちゃんと読めば良かった&quot;&gt;コースコンテンツをちゃんと読めば良かった&lt;/h4&gt;
&lt;p&gt;購入前にコースコンテンツをちゃんと読んでいませんでした。
そのため、中盤にやってくる「OSごとのセキュリティ対策」の章はそこそこ長いこともあり、かなり中だるみしてしまいました。
しばらく「IT部門向けの章だなー。つまらん。」と思っていたのですが、後々コースコンテンツの一覧を見ると、
IT部門の人も受講対象にしている旨の記載があり、少し残念な気分になりました。&lt;/p&gt;

&lt;p&gt;ただ、終盤にかけ、エンジニア向けっぽい内容に少しづつシフトしていったので、そこでモチベーションを盛り返すことができました。
次以降のコースではよりエンジニア向けの内容になるため、少し楽しみです。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;今回はUdemyの講座を購入し、サイバーセキュリティの学習を始めました。全4編のうちの最初の1つを受けただけなので、
まだまだ実践的な内容にまでは踏み込めてはいませんが、以降のコンテンツで教えていただけそうなので、早めに受講しようと思いました。
一言で「セキュリティ」と言っても幅が広いので、自分の業務周辺のセキュリティは自身で守ってあげられる程度のスキルは継続的に研鑽していきたいです。&lt;/p&gt;</content><author><name>soudegesu</name></author><category term="cyber" /><category term="security" /><category term="udemy" /><category term="beginner" /><summary type="html">昨今の仮想通貨流出問題を受けて、システム開発に携わるエンジニアにとって、セキュリティの専門家でなくても、サイバーセキュリティに関する学習の必要性を感じている方はいらっしゃるのではないでしょうか。 かくいう私もその口で、今回は Udemy というオンライン学習プラットフォームを活用してサイバーセキュリティの基礎を学んだ感想を書きます。</summary></entry><entry xml:lang="ja"><title type="html">AWS RDS Aurora Cluster(MySQL互換)でパーティションをプロシージャで定期的に追加しつつ、エラーハンドリングもする</title><link href="https://www.soudegesu.com/aws/rds-aurora-cluster-partitioning-procedure/" rel="alternate" type="text/html" title="AWS RDS Aurora Cluster(MySQL互換)でパーティションをプロシージャで定期的に追加しつつ、エラーハンドリングもする" /><published>2018-02-19T00:00:00+09:00</published><updated>2018-02-19T00:00:00+09:00</updated><id>https://www.soudegesu.com/aws/rds-aurora-cluster-partitioning-procedure</id><content type="html" xml:base="https://www.soudegesu.com/aws/rds-aurora-cluster-partitioning-procedure/">&lt;p&gt;AWSのRDS AuroraはOSSのDBミドルウェアと互換性のあるマネージドサービスです。
今回はAuroraのMySQL互換での日付パーティションの作成に関して説明します。
AuroraというよりはMySQLの仕様に関する説明も多いのでご了承ください。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#今回やりたかったこと&quot; id=&quot;markdown-toc-今回やりたかったこと&quot;&gt;今回やりたかったこと&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#パーティションを日次で追加する&quot; id=&quot;markdown-toc-パーティションを日次で追加する&quot;&gt;パーティションを日次で追加する&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#テーブル作成とパーティションの指定&quot; id=&quot;markdown-toc-テーブル作成とパーティションの指定&quot;&gt;テーブル作成とパーティションの指定&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#パーティション追加用のプロシージャを作成&quot; id=&quot;markdown-toc-パーティション追加用のプロシージャを作成&quot;&gt;パーティション追加用のプロシージャを作成&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#初期パーティションを作成する&quot; id=&quot;markdown-toc-初期パーティションを作成する&quot;&gt;初期パーティションを作成する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#プロシージャ実行をevent登録し定期実行する&quot; id=&quot;markdown-toc-プロシージャ実行をevent登録し定期実行する&quot;&gt;プロシージャ実行をEVENT登録し定期実行する&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rds-aurora-clusterの場合を考える&quot; id=&quot;markdown-toc-rds-aurora-clusterの場合を考える&quot;&gt;RDS Aurora Clusterの場合を考える&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#eventはwriterのみで実行される&quot; id=&quot;markdown-toc-eventはwriterのみで実行される&quot;&gt;EVENTはWriterのみで実行される&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#エラーが発生したらどうするか&quot; id=&quot;markdown-toc-エラーが発生したらどうするか&quot;&gt;エラーが発生したらどうするか&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#プロシージャ実行時のエラーはlambdaで検知する&quot; id=&quot;markdown-toc-プロシージャ実行時のエラーはlambdaで検知する&quot;&gt;プロシージャ実行時のエラーはlambdaで検知する&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#aurora-clusterにiam-roleを追加する&quot; id=&quot;markdown-toc-aurora-clusterにiam-roleを追加する&quot;&gt;Aurora ClusterにIAM Roleを追加する&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#rdsインスタンスのあるsubnetのルーティング設定をする&quot; id=&quot;markdown-toc-rdsインスタンスのあるsubnetのルーティング設定をする&quot;&gt;RDSインスタンスのあるsubnetのルーティング設定をする&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#プロシージャ側のエラーハンドリングを追加する&quot; id=&quot;markdown-toc-プロシージャ側のエラーハンドリングを追加する&quot;&gt;プロシージャ側のエラーハンドリングを追加する&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#lambda関数を作成する&quot; id=&quot;markdown-toc-lambda関数を作成する&quot;&gt;lambda関数を作成する&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#備考rdsのエラーログが出力されない&quot; id=&quot;markdown-toc-備考rdsのエラーログが出力されない&quot;&gt;[備考]RDSのエラーログが出力されない?&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考にさせていただいたサイト&quot; id=&quot;markdown-toc-参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;今回やりたかったこと&quot;&gt;今回やりたかったこと&lt;/h2&gt;
&lt;p&gt;今回はRDS Aurora(MySQL互換)にてClusterを組み、テーブルは日でパーティショニングすることにしました。
要件はざっくり以下です。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ユーザ操作の都度データが格納されていく(&lt;strong&gt;データは常にINSERT&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;一定期間が経過したデータには利用価値が薄い&lt;/strong&gt; ため退避した後削除して良い&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;そもそもDynamoDBでよくない？というツッコミがあるかもしれませんが、システムとは別の理由があるため採用していません。&lt;/p&gt;

&lt;p&gt;今回は以下のような &lt;code class=&quot;highlighter-rouge&quot;&gt;hoge&lt;/code&gt; テーブルを考えます。
&lt;code class=&quot;highlighter-rouge&quot;&gt;hoge&lt;/code&gt; テーブルにはユーザ(&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;)が行なった操作を &lt;code class=&quot;highlighter-rouge&quot;&gt;info&lt;/code&gt; カラムに格納します。
&lt;code class=&quot;highlighter-rouge&quot;&gt;create_at&lt;/code&gt; はパーティションキーであり、 &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; と &lt;code class=&quot;highlighter-rouge&quot;&gt;create_at&lt;/code&gt; が PKです。&lt;/p&gt;

&lt;p&gt;なお、パーティションキーはPKに含める必要があります。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;カラム名&lt;/th&gt;
      &lt;th&gt;型&lt;/th&gt;
      &lt;th&gt;備考&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;id&lt;/td&gt;
      &lt;td&gt;varchar(255)&lt;/td&gt;
      &lt;td&gt;ユーザのID&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;info&lt;/td&gt;
      &lt;td&gt;varchar(255)&lt;/td&gt;
      &lt;td&gt;ユーザが行なった操作の情報&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;create_at&lt;/td&gt;
      &lt;td&gt;timestamp&lt;/td&gt;
      &lt;td&gt;レコードが作成された日時&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;パーティションを日次で追加する&quot;&gt;パーティションを日次で追加する&lt;/h2&gt;

&lt;p&gt;ここから具体的な手順を説明します。
&lt;code class=&quot;highlighter-rouge&quot;&gt;hoge&lt;/code&gt; テーブルには以下のような操作をすることにしました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最初に一定量のパーティションを作成しておく&lt;/li&gt;
  &lt;li&gt;パーティションの&lt;strong&gt;追加&lt;/strong&gt;はプロシージャで実施する&lt;/li&gt;
  &lt;li&gt;日次でパーティションの最後に+1日ぶんのパーティションを&lt;strong&gt;追加&lt;/strong&gt;する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般的に &lt;strong&gt;「プロシージャの追加は一定量をまとめて実施した方が良い」&lt;/strong&gt; と言われています。&lt;/p&gt;

&lt;p&gt;私の場合、システムの運用要件や、格納するデータの想定量を設計に加え、左記を踏まえた負荷試験も実施したところ、オンラインでの日次パーティション追加でもパフォーマンス上問題がなかったため、上記の対応方針にしました。&lt;/p&gt;

&lt;h3 id=&quot;テーブル作成とパーティションの指定&quot;&gt;テーブル作成とパーティションの指定&lt;/h3&gt;
&lt;p&gt;以下のようなクエリを発行し &lt;code class=&quot;highlighter-rouge&quot;&gt;hoge&lt;/code&gt; テーブルを作成します。
加えて、パーティション名のルールは &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;yyyyMMdd&lt;/code&gt; として、&lt;code class=&quot;highlighter-rouge&quot;&gt;create_at&lt;/code&gt; カラムでRANGEパーティション指定をします。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- create hoge table
DROP TABLE IF EXISTS hoge;
CREATE TABLE hoge (
  id varchar(255) NOT NULL,
  info varchar(255) NOT NULL,
  create_at timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (id, create_at),
  INDEX index_id (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

ALTER TABLE hoge PARTITION BY RANGE (UNIX_TIMESTAMP(create_at)) (
  PARTITION p20180219 VALUES LESS THAN (UNIX_TIMESTAMP('2018-02-19 00:00:00'))
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;パーティション追加用のプロシージャを作成&quot;&gt;パーティション追加用のプロシージャを作成&lt;/h3&gt;
&lt;p&gt;次にパーティションを追加するためのプロシージャを登録します。
可視性の観点でバリデーション等は省略しています。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--
-- hogeテーブルにパーティションを追加するストアドプロシージャ
-- 引数 from_date: パーティション作成の開始日時 to_date: パーティション作成の終了日時
-- パーティションは from_date &amp;lt; to_date - 1日 分まで作成されます。
-- 呼び出しサンプル
-- CALL add_hoge_partition(str_to_date('2018-01-01', '%Y-%m-%d'), str_to_date('2019-01-01', '%Y-%m-%d'));
--
DROP PROCEDURE IF EXISTS add_hoge_partition;
DELIMITER $$
CREATE PROCEDURE add_hoge_partition(IN from_date DATE, IN to_date DATE)
  proc_label:BEGIN
    DECLARE target_date DATE;
    DECLARE partition_range DATE;
    DECLARE p_count INT;

    -- 日次パーティションの作成
    SET target_date = from_date;
    WHILE DATEDIFF(to_date, target_date) &amp;gt; 0 DO

      -- パーティションはLESS THANになるので1日追加
      SET partition_range = DATE_ADD(target_date, INTERVAL 1 DAY);
      -- パーティションの追加
      SELECT CONCAT(
        'ALTER TABLE hoge ADD PARTITION ( PARTITION ',
        DATE_FORMAT(target_date, 'p%Y%m%d'),
        ' VALUES LESS THAN (UNIX_TIMESTAMP(', QUOTE(DATE_FORMAT(partition_range, '%Y-%m-%d 00:00:00')), ')))'
      ) INTO @ddl;

      PREPARE ddl_stmt FROM @ddl;
      EXECUTE ddl_stmt;
      DEALLOCATE PREPARE ddl_stmt;

      -- 次の日次のパーティションの設定
      SET target_date = DATE_ADD(target_date, INTERVAL 1 DAY);
    END WHILE;

  END$$
DELIMITER ;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;初期パーティションを作成する&quot;&gt;初期パーティションを作成する&lt;/h3&gt;
&lt;p&gt;登録したプロシージャ &lt;code class=&quot;highlighter-rouge&quot;&gt;add_hoge_partition&lt;/code&gt; を使用して、初期パーティションを追加します。&lt;/p&gt;

&lt;p&gt;とりあえず、現在日付から365日ぶんのパーティションを追加しましょう。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CALL add_hoge_partition(CURDATE(), DATE_ADD(CURDATE(), INTERVAL 365 DAY));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;なお、パーティションは &lt;strong&gt;追加しかできない&lt;/strong&gt; ことに注意してください。&lt;/p&gt;

&lt;h3 id=&quot;プロシージャ実行をevent登録し定期実行する&quot;&gt;プロシージャ実行をEVENT登録し定期実行する&lt;/h3&gt;

&lt;p&gt;MySQLには &lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE EVENT&lt;/code&gt; 構文にてイベントをスケジュール実行する仕組みがあります。
これを利用することにしましょう。&lt;/p&gt;

&lt;p&gt;まず、 RDSのDBのパラメータグループにて &lt;code class=&quot;highlighter-rouge&quot;&gt;event_scheduler&lt;/code&gt; を &lt;code class=&quot;highlighter-rouge&quot;&gt;ON&lt;/code&gt; に指定します。(デフォルトでは &lt;code class=&quot;highlighter-rouge&quot;&gt;OFF&lt;/code&gt; )
その際、&lt;code class=&quot;highlighter-rouge&quot;&gt;event_scheduler&lt;/code&gt; パラメータグループの変更に伴うDBの再起動は不要です。&lt;/p&gt;

&lt;p&gt;その後以下のようなクエリを発行し、日次でパーティションを追加できるようにしましょう。
少々見づらいですが、&lt;code class=&quot;highlighter-rouge&quot;&gt;INFORMATION_SCHEMA&lt;/code&gt; から既に存在するパーティションの情報を取得し、それに +1日してパーティションを追加しています。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE EVENT add_hoge_partition
ON SCHEDULE EVERY 1 DAY STARTS '2018-02-19 00:00:00'
COMMENT 'hogeテーブルに対して1日毎に1日分のパーティションを追加します'
DO CALL 
    add_hoge_partition(
        (select from_unixtime(max(PARTITION_DESCRIPTION)) from INFORMATION_SCHEMA.PARTITIONS where TABLE_NAME = 'hoge', DATE_ADD(
            (select from_unixtime(max(PARTITION_DESCRIPTION)) from INFORMATION_SCHEMA.PARTITIONS where TABLE_NAME = 'hoge'),INTERVAL 1 DAY)
        );

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;これで、毎日0時にパーティション追加のプロシージャが実行されるようになりました。&lt;/p&gt;

&lt;h2 id=&quot;rds-aurora-clusterの場合を考える&quot;&gt;RDS Aurora Clusterの場合を考える&lt;/h2&gt;
&lt;p&gt;ここで、Aurora Clusterの場合を考えます。
Auroraでクラスタを組んだ場合、Master/Slaveの構成ではなく、Writer/Readerの構成になります。
詳細は割愛しますが、Auroraに関しては以下のBalckBeltの資料を参照してください。&lt;/p&gt;

&lt;div class=&quot;embed-container rich &quot;&gt;&lt;iframe src=&quot;https://www.slideshare.net/slideshow/embed_code/key/f30UqyEiHKB11p&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;https://www.slideshare.net/AmazonWebServicesJapan/aws-black-belt-online-seminar-amazon-aurora&quot; title=&quot;AWS Black Belt Online Seminar Amazon Aurora&quot; target=&quot;_blank&quot;&gt;AWS Black Belt Online Seminar Amazon Aurora&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;https://www.slideshare.net/AmazonWebServicesJapan&quot; target=&quot;_blank&quot;&gt;Amazon Web Services Japan&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;

&lt;/div&gt;

&lt;h3 id=&quot;eventはwriterのみで実行される&quot;&gt;EVENTはWriterのみで実行される&lt;/h3&gt;
&lt;p&gt;先程、&lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE EVENT&lt;/code&gt; 構文にてプロシージャを日次で実行するように登録しました。
Clusterを組んだ場合においては、「WriterとReaderの両方で実行されてしまうのでは？」と思い、以下のクエリを実行してみたところ、&lt;strong&gt;プロシージャはWriterで1回だけ呼ばれている&lt;/strong&gt; ことが確認できました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;WriterでEVENTを確認
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select * from INFORMATION_SCHEMA.PROCESSLIST where USER = 'event_scheduler' limit 10;
&amp;gt; 1	event_scheduler	localhost		Daemon	40803	Waiting for next activation	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;ReaderでEVENTを確認
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select * from INFORMATION_SCHEMA.PROCESSLIST where USER = 'event_scheduler' limit 10;
&amp;gt; Empty set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Failoverさせた状態でも、翌日にもパーティションが作成されていることも確認できたため、Writerのみが実行できているといえます。&lt;/p&gt;

&lt;h2 id=&quot;エラーが発生したらどうするか&quot;&gt;エラーが発生したらどうするか&lt;/h2&gt;
&lt;p&gt;今回の「定期的にプロシージャを実行」という方法は &lt;strong&gt;Auroraインスタンスの中に閉じた処理&lt;/strong&gt; になります。
仮に実行時エラーやバリデーションエラー等が発生した場合に、開発者がそれを拾えなければサイレント障害になりかねません。
そのため、&lt;strong&gt;エラーが発生した場合に検知する機構&lt;/strong&gt; が必要になってきます。&lt;/p&gt;

&lt;h3 id=&quot;プロシージャ実行時のエラーはlambdaで検知する&quot;&gt;プロシージャ実行時のエラーはlambdaで検知する&lt;/h3&gt;
&lt;p&gt;今回はAurora(MySQL互換)に標準で組み込まれたプロシージャ &lt;code class=&quot;highlighter-rouge&quot;&gt;mysql.lambda_async&lt;/code&gt; を使用して問題発生を検知するようにします。
&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql.lambda_async&lt;/code&gt; は、RDSから直接AWS Lambdaを実行することができ、その際にメッセージを指定できるのです。
以降ではその手順を説明します。&lt;/p&gt;

&lt;h4 id=&quot;aurora-clusterにiam-roleを追加する&quot;&gt;Aurora ClusterにIAM Roleを追加する&lt;/h4&gt;
&lt;p&gt;Auroraからlambdaを実行するために、別途権限を付与する必要があります。
IAMのメニューから専用のIAM Roleを作成しましょう(今回は &lt;code class=&quot;highlighter-rouge&quot;&gt;rdsToLambdaRole&lt;/code&gt; という名前にします)。
&lt;code class=&quot;highlighter-rouge&quot;&gt;rdsToLambdaRole&lt;/code&gt; には&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;Action&quot;: [
  &quot;lambda:InvokeFunction&quot;
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;が許可されていれば良いので、AWSから提供されている &lt;code class=&quot;highlighter-rouge&quot;&gt;AWSLambdaRole&lt;/code&gt; ポリシーを適用すればOKです。&lt;/p&gt;

&lt;p&gt;作成した &lt;code class=&quot;highlighter-rouge&quot;&gt;rdsToLambdaRole&lt;/code&gt; のARNを &lt;strong&gt;クラスタのパラメータグループ&lt;/strong&gt;の&lt;strong&gt;aws_default_lambda_role&lt;/strong&gt;に指定しましょう。&lt;/p&gt;

&lt;p&gt;こちらのパラメータも &lt;code class=&quot;highlighter-rouge&quot;&gt;dynamic&lt;/code&gt; のためクラスタ再起動は不要です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180219/rds_to_lambda_role.png&quot; alt=&quot;rds_to_lambda_role&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;rdsインスタンスのあるsubnetのルーティング設定をする&quot;&gt;RDSインスタンスのあるsubnetのルーティング設定をする&lt;/h4&gt;
&lt;p&gt;RDSからのoutbound通信を許可してあげる必要があるので、ルーティングの設定を行います。
一般的にDBサーバはprivate subnetに置くケースが大半だと思いますので、private subnetから外に出られるように設定してあげましょう。&lt;/p&gt;

&lt;h4 id=&quot;プロシージャ側のエラーハンドリングを追加する&quot;&gt;プロシージャ側のエラーハンドリングを追加する&lt;/h4&gt;
&lt;p&gt;プロシージャ内でエラーが発生した場合に、lambdaを実行する &lt;code class=&quot;highlighter-rouge&quot;&gt;HANDLER&lt;/code&gt; を先程のプロシージャに追加しましょう。
lambda関数 &lt;code class=&quot;highlighter-rouge&quot;&gt;rds_monitor&lt;/code&gt; を &lt;code class=&quot;highlighter-rouge&quot;&gt;mysql.lambda_async&lt;/code&gt; プロシージャで呼び出します。&lt;/p&gt;

&lt;p&gt;追記箇所は以下のようになります。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    -- 失敗したらlambdaで通知する
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
      BEGIN
        GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
        CALL mysql.lambda_async(
          'arn:aws:lambda:ap-northeast-1:${account_id}:function:rds_monitor',
          CONCAT('{&quot;message&quot;:&quot;', @p2, '&quot;,',
                  '&quot;state&quot;:&quot;', @p1, '&quot;}')
        );
      END;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;先程のプロシージャに組み込んだ場合は以下のようになります。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--
-- hogeテーブルにパーティションを追加するストアドプロシージャ
-- 引数 from_date: パーティション作成の開始日時 to_date: パーティション作成の終了日時
-- パーティションは from_date &amp;lt; to_date - 1日 分まで作成されます。
-- 呼び出しサンプル
-- CALL add_hoge_partition(str_to_date('2018-01-01', '%Y-%m-%d'), str_to_date('2019-01-01', '%Y-%m-%d'));
--
DROP PROCEDURE IF EXISTS add_hoge_partition;
DELIMITER $$
CREATE PROCEDURE add_hoge_partition(IN from_date DATE, IN to_date DATE)
  proc_label:BEGIN
    DECLARE target_date DATE;
    DECLARE partition_range DATE;
    DECLARE p_count INT;
    -- 失敗したらlambdaで通知する
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
      BEGIN
        GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
        CALL mysql.lambda_async(
          'arn:aws:lambda:ap-northeast-1:${account_id}:function:rds_monitor',
          CONCAT('{&quot;message&quot;:&quot;', @p2, '&quot;,',
                  '&quot;state&quot;:&quot;', @p1, '&quot;}')
        );
      END;

    -- 日次パーティションの作成
    SET target_date = from_date;
    WHILE DATEDIFF(to_date, target_date) &amp;gt; 0 DO

      -- パーティションはLESS THANになるので1日追加
      SET partition_range = DATE_ADD(target_date, INTERVAL 1 DAY);
      -- パーティションの追加
      SELECT CONCAT(
        'ALTER TABLE hoge ADD PARTITION ( PARTITION ',
        DATE_FORMAT(target_date, 'p%Y%m%d'),
        ' VALUES LESS THAN (UNIX_TIMESTAMP(', QUOTE(DATE_FORMAT(partition_range, '%Y-%m-%d 00:00:00')), ')))'
      ) INTO @ddl;

      PREPARE ddl_stmt FROM @ddl;
      EXECUTE ddl_stmt;
      DEALLOCATE PREPARE ddl_stmt;

      -- 次の日次のパーティションの設定
      SET target_date = DATE_ADD(target_date, INTERVAL 1 DAY);
    END WHILE;

  END$$
DELIMITER ;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql.lambda_async&lt;/code&gt;の引数には&lt;strong&gt;lambdaのARN指定が必要&lt;/strong&gt;という点が注意ポイントです。&lt;/p&gt;

&lt;p&gt;DBのマイグレーションツールを使用して複数のAWSアカウントを運用されている方は、AWSのアカウント番号が異なるため、チェックサムが変わってしまいます。マイグレーションツールがテンプレート変数をサポートしているか確認すると良いでしょう。&lt;/p&gt;

&lt;h4 id=&quot;lambda関数を作成する&quot;&gt;lambda関数を作成する&lt;/h4&gt;

&lt;p&gt;Auroraから渡されたメッセージを処理して、監視システムやチャットツールに通知するためのlambda関数を実装します。
私の場合は監視用SaaSである &lt;a href=&quot;https://www.datadoghq.com/&quot;&gt;datadog&lt;/a&gt; に通知していました。&lt;/p&gt;

&lt;h4 id=&quot;備考rdsのエラーログが出力されない&quot;&gt;[備考]RDSのエラーログが出力されない?&lt;/h4&gt;
&lt;p&gt;コンソール上からRDSインスタンスのエラーログを参照しようと &lt;code class=&quot;highlighter-rouge&quot;&gt;error/mysql-error-running.log&lt;/code&gt; を選択しても、
以下のように &lt;strong&gt;END OF LOG&lt;/strong&gt; しか表示されない場合があります。
コンソール上部には 38.2kB とログの容量が記載されているにも関わらずに、です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180219/rds_log_is_empty.png&quot; alt=&quot;rds error log is empty&quot; /&gt;&lt;/p&gt;

&lt;p&gt;実はこれは、&lt;strong&gt;「AWS側で使用するログを上記のログファイルに出力しているらしく、我々AWSのユーザ側には表示されない」という仕様&lt;/strong&gt; によるものです。少しわかりにくいですが、このログファイルの容量はAWS用のログの容量も含まれて表示されている、ということですね。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;今回はAurora Clusterからプロシージャを定期実行することで、日付パーティションを定期追加する方法をまとめました。
マネージドサービスであるRDSのプロシージャ内部の処理は隠蔽されて見通しが悪くなるため、エラーハンドリングをきちんと定義してあげることが肝要です。今回はRDSからlambdaを実行しましたが、CloudwatchLogsへ連携することもできるそうなので、機会があれば試してみたいと思います。&lt;/p&gt;

&lt;h2 id=&quot;参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/ja/create-event.html&quot;&gt;MySQL 5.6 リファレンスマニュアル 13.1.11 CREATE EVENT 構文&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/AmazonWebServicesJapan/aws-black-belt-online-seminar-amazon-aurora/&quot;&gt;AWS Black Belt Online Seminar Amazon Aurora&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ja_jp/AmazonRDS/latest/UserGuide/AuroraMySQL.Integrating.Lambda.html#AuroraMySQL.Integrating.ProcLambda&quot;&gt;Amazon Aurora MySQL DB クラスターからの Lambda 関数の呼び出し&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>soudegesu</name></author><category term="aws" /><category term="rds" /><category term="aurora" /><category term="SQL" /><category term="MySQL" /><summary type="html">AWSのRDS AuroraはOSSのDBミドルウェアと互換性のあるマネージドサービスです。 今回はAuroraのMySQL互換での日付パーティションの作成に関して説明します。 AuroraというよりはMySQLの仕様に関する説明も多いのでご了承ください。</summary></entry><entry xml:lang="ja"><title type="html">Q# 量子コンピューティングプログラミング言語を試す</title><link href="https://www.soudegesu.com/q_sharp/what-is-q-sharp/" rel="alternate" type="text/html" title="Q# 量子コンピューティングプログラミング言語を試す" /><published>2018-02-11T00:00:00+09:00</published><updated>2018-02-11T00:00:00+09:00</updated><id>https://www.soudegesu.com/q_sharp/what-is-q-sharp</id><content type="html" xml:base="https://www.soudegesu.com/q_sharp/what-is-q-sharp/">&lt;p&gt;もともとは &lt;strong&gt;仮想通貨&lt;/strong&gt; を調べていた時に、 &lt;strong&gt;量子耐性&lt;/strong&gt; という言葉を発見し、量子耐性から &lt;strong&gt;量子耐性のあるアルゴリズム&lt;/strong&gt; や量子プログラミング言語である &lt;strong&gt;Q#&lt;/strong&gt; に行き着きました。
Wikipediaなどを見てみると、&lt;strong&gt;Q#&lt;/strong&gt; はどちらかといえば研究者向けの言語らしいので、普段の業務との関連性は少なそうですが、せっかくなので触ってみようと思います。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#qの環境構築&quot; id=&quot;markdown-toc-qの環境構築&quot;&gt;Q#の環境構築&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#azure上でのwindowsインスタンスセットアップ&quot; id=&quot;markdown-toc-azure上でのwindowsインスタンスセットアップ&quot;&gt;Azure上でのWindowsインスタンスセットアップ&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#microsoft-quantum-development-kitのインストール&quot; id=&quot;markdown-toc-microsoft-quantum-development-kitのインストール&quot;&gt;Microsoft Quantum Development Kitのインストール&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#サンプルコードのインポート&quot; id=&quot;markdown-toc-サンプルコードのインポート&quot;&gt;サンプルコードのインポート&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#サンプルコードの実行なるほどわからん&quot; id=&quot;markdown-toc-サンプルコードの実行なるほどわからん&quot;&gt;サンプルコードの実行(なるほど、わからん)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#基本を抑える&quot; id=&quot;markdown-toc-基本を抑える&quot;&gt;基本を抑える&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#qubit-量子コンピューティングの基本を抑える&quot; id=&quot;markdown-toc-qubit-量子コンピューティングの基本を抑える&quot;&gt;Qubit 量子コンピューティングの基本を抑える&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#注意点reference-to-unknown-namespace-xxx-が出る場合&quot; id=&quot;markdown-toc-注意点reference-to-unknown-namespace-xxx-が出る場合&quot;&gt;[注意点]Reference to unknown namespace xxx が出る場合&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#qの標準ライブラリを見てみる&quot; id=&quot;markdown-toc-qの標準ライブラリを見てみる&quot;&gt;Q#の標準ライブラリを見てみる&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#少し変わったプリミティブ型&quot; id=&quot;markdown-toc-少し変わったプリミティブ型&quot;&gt;少し変わったプリミティブ型&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#qubit&quot; id=&quot;markdown-toc-qubit&quot;&gt;Qubit&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#pauli&quot; id=&quot;markdown-toc-pauli&quot;&gt;Pauli&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#result&quot; id=&quot;markdown-toc-result&quot;&gt;Result&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#標準関数も少し見てみる&quot; id=&quot;markdown-toc-標準関数も少し見てみる&quot;&gt;標準関数も少し見てみる&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#qの理解自体はそこまで難しくない&quot; id=&quot;markdown-toc-qの理解自体はそこまで難しくない&quot;&gt;Q#の理解自体はそこまで難しくない&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#今後qはどのように活用されるのか&quot; id=&quot;markdown-toc-今後qはどのように活用されるのか&quot;&gt;今後Q#はどのように活用されるのか&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考にさせていただいたサイト&quot; id=&quot;markdown-toc-参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;qの環境構築&quot;&gt;Q#の環境構築&lt;/h2&gt;
&lt;p&gt;開発環境の構築に関しては大きく補足することは無さそうです。&lt;a href=&quot;https://docs.microsoft.com/en-us/quantum/quantum-installconfig?view=qsharp-preview&quot;&gt;公式サイト&lt;/a&gt;も手順が手厚めに記載されています。&lt;/p&gt;

&lt;p&gt;ただし、セットアップの途中で気づいたのですが、 &lt;strong&gt;Macは Microsoft Quantum Development KitのExtensionをインストールできない&lt;/strong&gt; ことが判明しました。手順の序盤に記載があったのですが、すっかり読み飛ばしていました。 現時点のVisual Studio for Mac がこのExtensionをサポートしていない、というのです。
仕方がないので、Mac使いの私はAzure上にWindowsのインスタンスを構築し、Remote Desktop接続にて作業をすることにしました。&lt;/p&gt;

&lt;h3 id=&quot;azure上でのwindowsインスタンスセットアップ&quot;&gt;Azure上でのWindowsインスタンスセットアップ&lt;/h3&gt;

&lt;p&gt;Microsoft Azureは30日間フリーで使えるクレジットを準備してくれているので、Visual Studioのサンプルコードを実行する程度であればお金の心配はしなくても良いです。Outlookのアカウントがあれば簡単にセットアップできます(手元にクレカや携帯電話は必要です)。
インスタンス構築時には &lt;code class=&quot;highlighter-rouge&quot;&gt;Visual Studio 2017&lt;/code&gt; がバンドルされているイメージを使用すると簡単に始められるため、私はそれを利用しました。&lt;/p&gt;

&lt;h3 id=&quot;microsoft-quantum-development-kitのインストール&quot;&gt;Microsoft Quantum Development Kitのインストール&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.microsoft.com/en-us/quantum/development-kit&quot;&gt;Microsoft Quantum Development Kit&lt;/a&gt; をダウンロードすることで &lt;code class=&quot;highlighter-rouge&quot;&gt;Q#&lt;/code&gt; のコードが動かせるようになります。公式サイトではwebサイトからの &lt;code class=&quot;highlighter-rouge&quot;&gt;.vsix&lt;/code&gt; ファイル(Visual Studio)入手の手順を紹介していますが、
今回はヘッダーメニューの [Tools] &amp;gt; [Extensions and Updates..] から検索してインストールしました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180211/extension_and_updates.png&quot; alt=&quot;extension_and_updates&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;サンプルコードのインポート&quot;&gt;サンプルコードのインポート&lt;/h3&gt;
&lt;p&gt;その後、&lt;a href=&quot;https://github.com/microsoft/quantum&quot;&gt;サンプルコード&lt;/a&gt;を &lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt; したものを &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; します。
(私の場合、学んだことをissueに書き連ねていきたいので、こうしました)&lt;/p&gt;

&lt;p&gt;Visual Studio上では &lt;code class=&quot;highlighter-rouge&quot;&gt;Team&lt;/code&gt; というメニューでVCSにアクセスできるので、そこからインポートを行い、
その後 &lt;code class=&quot;highlighter-rouge&quot;&gt;.sln&lt;/code&gt; ファイルをダブルクリックしてプロジェクトを開きます。&lt;/p&gt;

&lt;h3 id=&quot;サンプルコードの実行なるほどわからん&quot;&gt;サンプルコードの実行(なるほど、わからん)&lt;/h3&gt;
&lt;p&gt;プロジェクト内にいくつかディレクトリがあり、いくつかのサンプルコードが配置されています。
それを「Set as Startup Project」に設定した後、 &lt;code class=&quot;highlighter-rouge&quot;&gt;F5&lt;/code&gt; のショートカットキーでRunさせることができます。
おもむろにプロンプトが立ち上がり、何かが実行されているのですが、なるほどどうしてよく分かりません。
とりあえず、動作環境が構築できたことはわかりました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180211/prompt_success.png&quot; alt=&quot;prompt_success&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;基本を抑える&quot;&gt;基本を抑える&lt;/h2&gt;

&lt;p&gt;やはり前知識無しで進めていくのは厳しいものがあるので、基本を抑えに行きましょう。&lt;/p&gt;

&lt;h3 id=&quot;qubit-量子コンピューティングの基本を抑える&quot;&gt;Qubit 量子コンピューティングの基本を抑える&lt;/h3&gt;
&lt;p&gt;私の場合、そもそも量子コンピューティング自体への理解が皆無ですので、そこを補填する必要がありました。
そのため、&lt;code class=&quot;highlighter-rouge&quot;&gt;N.H.Shimada&lt;/code&gt; さんのブログの記事「&lt;a href=&quot;http://ut25252.hatenablog.com/entry/2017/12/15/222821&quot;&gt;新プログラミング言語「Q#」で量子テレポーテーション&lt;/a&gt;」やIPAより公開されている「&lt;a href=&quot;https://www.ipa.go.jp/security/enc/quantumcomputers/contents/doc/chap2.pdf&quot;&gt;2. 量子計算の基本原理[1-14]&lt;/a&gt;」、&lt;code class=&quot;highlighter-rouge&quot;&gt;lyncs&lt;/code&gt;さんの &lt;a href=&quot;http://lyncs.hateblo.jp/entry/2017/12/16/000103&quot;&gt;量子情報科学序論 IBM Qを動かして学ぶ量子コンピュータ&lt;/a&gt;、加えて &lt;code class=&quot;highlighter-rouge&quot;&gt;@eccyan&lt;/code&gt; さんの「&lt;a href=&quot;https://qiita.com/eccyan/items/180fb909a55a59bb4e1b&quot;&gt;量子コンピュータと量子ゲートと私&lt;/a&gt;」 を読みながら知識を増やしていきます。&lt;/p&gt;

&lt;p&gt;ここでは主に以下の3点を学習しました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Qubit(Quantum bit)
    &lt;ul&gt;
      &lt;li&gt;重ね合わせ&lt;/li&gt;
      &lt;li&gt;量子もつれ&lt;/li&gt;
      &lt;li&gt;観測&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ここでQubitについてまとめると先駆者の方々の丸パクリになってしまいそうでしたので、各リンク先の内容をご参照ください。&lt;/p&gt;

&lt;h3 id=&quot;注意点reference-to-unknown-namespace-xxx-が出る場合&quot;&gt;[注意点]Reference to unknown namespace xxx が出る場合&lt;/h3&gt;
&lt;p&gt;サンプルコードを動かした後、新規のプロジェクトでプログラムを実行しようと思ったのですが、
以下のようなエラーが表示され、ビルドに失敗しました。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Reference to unknown namespace Microsoft.Quantum.Primitive
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;調査してみたところ &lt;code class=&quot;highlighter-rouge&quot;&gt;.NETのバージョンが古い&lt;/code&gt; ことが原因でした。
 &lt;code class=&quot;highlighter-rouge&quot;&gt;.NET Framework&lt;/code&gt; を &lt;code class=&quot;highlighter-rouge&quot;&gt;4.6.1&lt;/code&gt; に変更することで namespaceの解決ができるようになりました。&lt;/p&gt;

&lt;h2 id=&quot;qの標準ライブラリを見てみる&quot;&gt;Q#の標準ライブラリを見てみる&lt;/h2&gt;
&lt;p&gt;普段、高級言語で仕事をしている身からすると、少し変わった型がプリミティブとして用意されているので、紹介しておきます。&lt;/p&gt;

&lt;h3 id=&quot;少し変わったプリミティブ型&quot;&gt;少し変わったプリミティブ型&lt;/h3&gt;
&lt;h4 id=&quot;qubit&quot;&gt;Qubit&lt;/h4&gt;
&lt;p&gt;量子コンピューティングに必要な量子ビット(Quantum Bit)を表現するための型。&lt;/p&gt;

&lt;h4 id=&quot;pauli&quot;&gt;Pauli&lt;/h4&gt;
&lt;p&gt;ブロッホ球での回転を考えるときに使用するパウリ行列を表す型。
何軸で回転させるかによって &lt;code class=&quot;highlighter-rouge&quot;&gt;PauliI&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PauliX&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PauliY&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PauliZ&lt;/code&gt; のいずれかを選択することになるのですが、
それをまとめてPauliとして扱います。&lt;/p&gt;

&lt;h4 id=&quot;result&quot;&gt;Result&lt;/h4&gt;
&lt;p&gt;Qubitを観測(Measurement)した際の結果が格納される型。
観測することで &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; か &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; に収束されるので、&lt;code class=&quot;highlighter-rouge&quot;&gt;Zero&lt;/code&gt; か &lt;code class=&quot;highlighter-rouge&quot;&gt;One&lt;/code&gt; しかありません。&lt;/p&gt;

&lt;h3 id=&quot;標準関数も少し見てみる&quot;&gt;標準関数も少し見てみる&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Microsoft.Quantum.Primitive&lt;/code&gt; パッケージには演算のための関数が予め準備されていました。
Microsoftのサンプルコードで使われている &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; や &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;CNOT&lt;/code&gt; といったゲートを構築するためのものがあり、
別のパッケージには &lt;code class=&quot;highlighter-rouge&quot;&gt;Math&lt;/code&gt; 系のパッケージもありました。&lt;/p&gt;

&lt;p&gt;関数が表す式は &lt;a href=&quot;https://docs.microsoft.com/en-us/qsharp/api/prelude/microsoft.quantum.primitive?view=qsharp-preview&quot;&gt;公式のライブラリリファレンス&lt;/a&gt;
に記載されています。端的ですが、変に言葉で説明するよりも良いのでしょうね。理解が及んでいない式は別途調べました。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;h3 id=&quot;qの理解自体はそこまで難しくない&quot;&gt;Q#の理解自体はそこまで難しくない&lt;/h3&gt;
&lt;p&gt;私はアルゴリズムや低レベルの機械計算を専門としてはいないため、応用するには学習時間が要しそうですが、
今時点での言語仕様は比較的理解しやすいと感じました。量子力学の基礎となる数式の意味が理解できれば、
量子ゲート作成に必要な演算部分は &lt;code class=&quot;highlighter-rouge&quot;&gt;Q#&lt;/code&gt; から提供されているため、あとは組み合わせるだけになります。
なお、&lt;a href=&quot;https://www.research.ibm.com/ibm-q/&quot;&gt;IBM Q&lt;/a&gt; にはGUIもあるのですが、 
pythonのSDKとして &lt;a href=&quot;https://github.com/QISKit/qiskit-sdk-py&quot;&gt;qiskit-sdk-py&lt;/a&gt; も提供しています。 
シミュレーションを目的とし、コード化による共有ができ、サクッと動かしてみたい、という方はこちらの方がいいのかもしれませんね。
(すみません、こちらは動作確認していません)&lt;/p&gt;

&lt;h3 id=&quot;今後qはどのように活用されるのか&quot;&gt;今後Q#はどのように活用されるのか&lt;/h3&gt;

&lt;p&gt;ソフトウェアを動かすにはどのように組み込まれるのか、に関するアイディアはMicrosoftの &lt;a href=&quot;https://docs.microsoft.com/en-us/quantum/quantum-concepts-9-softwarestack?view=qsharp-preview&quot;&gt;The Software Stack&lt;/a&gt; にて言及されていました。
量子コンピュータが得意とするアルゴリズムはQ#で組み、従来のコンピュータが得意とする計算はそちらに処理を委ねるハイブリッドな構成が提案されています。
今回は量子コンピュータプログラミング言語が活かせる演算までは踏み込みませんが、定期的に情報をウォッチしていきたいですね。&lt;/p&gt;

&lt;h2 id=&quot;参考にさせていただいたサイト&quot;&gt;参考にさせていただいたサイト&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://ut25252.hatenablog.com/entry/2017/12/15/222821&quot;&gt;新プログラミング言語「Q#」で量子テレポーテーション&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ipa.go.jp/security/enc/quantumcomputers/contents/doc/chap2.pdf&quot;&gt;2. 量子計算の基本原理[1-14]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qiita.com/eccyan/items/180fb909a55a59bb4e1b&quot;&gt;量子コンピュータと量子ゲートと私&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lyncs.hateblo.jp/entry/2017/12/16/000103&quot;&gt;量子情報科学序論 IBM Qを動かして学ぶ量子コンピュータ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/quantum/quantum-qr-intro?view=qsharp-preview&quot;&gt;The Q# Programming Language&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/47910347/q-environment-inconsistencies&quot;&gt;Q# environment inconsistencies(Stackoverflow)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>soudegesu</name></author><category term="q#" /><category term="q_sharp" /><category term="quantum" /><category term="computing" /><category term="量子コンピューティング" /><summary type="html">もともとは 仮想通貨 を調べていた時に、 量子耐性 という言葉を発見し、量子耐性から 量子耐性のあるアルゴリズム や量子プログラミング言語である Q# に行き着きました。 Wikipediaなどを見てみると、Q# はどちらかといえば研究者向けの言語らしいので、普段の業務との関連性は少なそうですが、せっかくなので触ってみようと思います。</summary></entry><entry xml:lang="ja"><title type="html">JavaプロジェクトをModule System(Java9のProject Jigsaw)にマイグレーションするステップ</title><link href="https://www.soudegesu.com/java/java9-modularity/" rel="alternate" type="text/html" title="JavaプロジェクトをModule System(Java9のProject Jigsaw)にマイグレーションするステップ" /><published>2018-02-04T00:00:00+09:00</published><updated>2018-02-04T00:00:00+09:00</updated><id>https://www.soudegesu.com/java/java9-modularity</id><content type="html" xml:base="https://www.soudegesu.com/java/java9-modularity/">&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#はじめに&quot; id=&quot;markdown-toc-はじめに&quot;&gt;はじめに&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#注意点&quot; id=&quot;markdown-toc-注意点&quot;&gt;注意点&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#どうなるこれからのjava&quot; id=&quot;markdown-toc-どうなるこれからのjava&quot;&gt;どうなる？これからのJava&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#半年に1度訪れるjava-seのリリース&quot; id=&quot;markdown-toc-半年に1度訪れるjava-seのリリース&quot;&gt;半年に1度訪れるJava SEのリリース&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ウォッチすべき話題はjavaのサポート期限&quot; id=&quot;markdown-toc-ウォッチすべき話題はjavaのサポート期限&quot;&gt;ウォッチすべき話題はJavaのサポート期限&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#java8はいつまでサポートされるか&quot; id=&quot;markdown-toc-java8はいつまでサポートされるか&quot;&gt;Java8はいつまでサポートされるか&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#他にも気をつけておいた方が良いこと&quot; id=&quot;markdown-toc-他にも気をつけておいた方が良いこと&quot;&gt;他にも気をつけておいた方が良いこと&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#module-systemへのマイグレーションに挑戦&quot; id=&quot;markdown-toc-module-systemへのマイグレーションに挑戦&quot;&gt;Module Systemへのマイグレーションに挑戦&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#step-1-module-systemの基礎を勉強する&quot; id=&quot;markdown-toc-step-1-module-systemの基礎を勉強する&quot;&gt;Step 1. Module Systemの基礎を勉強する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#step-2-依存ライブラリのバージョンアップを行う&quot; id=&quot;markdown-toc-step-2-依存ライブラリのバージョンアップを行う&quot;&gt;Step 2. 依存ライブラリのバージョンアップを行う&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#ライブラリのリリースノートを読んで大丈夫だなと早合点するのは危険&quot; id=&quot;markdown-toc-ライブラリのリリースノートを読んで大丈夫だなと早合点するのは危険&quot;&gt;ライブラリのリリースノートを読んで「大丈夫だな」と早合点するのは危険&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#step-3-unnamed-moduleにマイグレーションする&quot; id=&quot;markdown-toc-step-3-unnamed-moduleにマイグレーションする&quot;&gt;Step 3. Unnamed Moduleにマイグレーションする&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#step-4-named-moduelにマイグレーションする&quot; id=&quot;markdown-toc-step-4-named-moduelにマイグレーションする&quot;&gt;Step 4. Named Moduelにマイグレーションする&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#step-5-負荷試験とリソースモニタリングをする&quot; id=&quot;markdown-toc-step-5-負荷試験とリソースモニタリングをする&quot;&gt;Step 5. 負荷試験とリソースモニタリングをする&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考にさせていただいたページ&quot; id=&quot;markdown-toc-参考にさせていただいたページ&quot;&gt;参考にさせていただいたページ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;はじめに&quot;&gt;はじめに&lt;/h2&gt;
&lt;p&gt;今回はJava 9で追加されたModule System移行に関して説明します。
自身で手を動かすことで、JavaのプロダクションコードをJPMSに適用するための作業手順の一定の目処がたったのでまとめておきます。&lt;/p&gt;

&lt;p&gt;実は &lt;a href=&quot;https://speakerdeck.com/takaakisuzuki/korekarafalsejavafalsehua-wosiyou&quot;&gt;社内向けにも同様の発表&lt;/a&gt; はしています。
少しネガティブなニュアンスで資料を書いていますが、社内の(いろんな意味で)危機意識を煽るため、という背景もあったので、その点ご了承ください。&lt;/p&gt;

&lt;div class=&quot;embed-container rich &quot;&gt;&lt;iframe allowfullscreen=&quot;true&quot; allowtransparency=&quot;true&quot; frameborder=&quot;0&quot; height=&quot;596&quot; id=&quot;talk_frame_426422&quot; mozallowfullscreen=&quot;true&quot; src=&quot;//speakerdeck.com/player/0891ffc8f49a450284c48eabf1e1ccbd&quot; style=&quot;border:0; padding:0; margin:0; background:transparent;&quot; webkitallowfullscreen=&quot;true&quot; width=&quot;710&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2 id=&quot;注意点&quot;&gt;注意点&lt;/h2&gt;
&lt;p&gt;2018/1時点での情報を基に記載をしていますので、今後変更になる可能性があります。
最新の情報と照らし合わせながら適宜情報の補填を行っていただければと思います。&lt;/p&gt;

&lt;h2 id=&quot;どうなるこれからのjava&quot;&gt;どうなる？これからのJava&lt;/h2&gt;
&lt;p&gt;ここではまず最初に、足元のJPMSの話ではなく、Javaエンジニアが把握しておくべき今後の全体的な流れについて触れておきます。&lt;/p&gt;

&lt;h3 id=&quot;半年に1度訪れるjava-seのリリース&quot;&gt;半年に1度訪れるJava SEのリリース&lt;/h3&gt;
&lt;p&gt;昨年のJava Oneにて Java9 以降のJavaのリリースロードマップが発表されました。
要点だけまとめると以下になります。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;リリース頻度は半年に1度(次は2018/3、その次は2018/9)&lt;/li&gt;
  &lt;li&gt;バージョニングは &lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;11&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;Oracle社のページでは &lt;code class=&quot;highlighter-rouge&quot;&gt;yy.MM&lt;/code&gt; 形式で記載されているで注意&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;時間軸でリリースがされていくため、期限までに実装終了したフィーチャーがリリース対象の機能として取り込まれる
    &lt;ul&gt;
      &lt;li&gt;early access buildはリリース3ヶ月前から提供される&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ウォッチすべき話題はjavaのサポート期限&quot;&gt;ウォッチすべき話題はJavaのサポート期限&lt;/h3&gt;
&lt;p&gt;Javaのリリースロードマップの中で注目すべきは &lt;strong&gt;サポート期限&lt;/strong&gt; です。
リリースラインが1本化されたことで、&lt;strong&gt;複数のJavaのバージョンが並行サポートされることがなくなり&lt;/strong&gt; ます。
つまり、Javaの進化に合わせて、自分のプロダクトも追随していく必要がある、というわけです。
例えば、Java 10が出たら、Java 9はその時点でサポート終了ということです。&lt;/p&gt;

&lt;p&gt;ルールとして一見わかりやすくはあるものの、以下のようなプロジェクトの場合はJavaのリリースサイクルに追従していくのは容易なことではありません。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;リリースサイクルが長い&lt;/li&gt;
  &lt;li&gt;リリースタイミングが柔軟にコントロールできない&lt;/li&gt;
  &lt;li&gt;テストコード(非機能含む)が整備されていない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そのようなプロジェクトの場合には、Oracle社からの長期サポートを受けるなどして適宜自分たちのペースでマイグレーション計画をしていくことになるでしょう。&lt;/p&gt;

&lt;h3 id=&quot;java8はいつまでサポートされるか&quot;&gt;Java8はいつまでサポートされるか&lt;/h3&gt;
&lt;p&gt;実は &lt;strong&gt;2018/01/31現在でOracle社がJava 8のサポートを2018/09→2019/01へ延長した&lt;/strong&gt; こともあり、実際どうなるかはまだわかりません。 &lt;strong&gt;いつJava8から移行するか&lt;/strong&gt;を決断するための材料としても、「Javaのサポート期限」の話題は今後も慎重にウォッチした方が良いでしょう。&lt;/p&gt;

&lt;h3 id=&quot;他にも気をつけておいた方が良いこと&quot;&gt;他にも気をつけておいた方が良いこと&lt;/h3&gt;

&lt;p&gt;Javaが先程のリリースサイクルになった場合に他に留意すべき点も補足しておきます。
以下のようなポイントを中心に情報収集やearly access buildでの動作確認を早めにしておくと良いと感じました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;周辺のエコシステムが追従できているか
    &lt;ul&gt;
      &lt;li&gt;アプリケーションを構成する依存ライブラリ&lt;/li&gt;
      &lt;li&gt;実行環境として使用するパブリッククラウド&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;重要な仕様変更が入っているか
    &lt;ul&gt;
      &lt;li&gt;JPMSのような大きな仕様変更&lt;/li&gt;
      &lt;li&gt;パッケージの移動や非推奨になったAPI&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;module-systemへのマイグレーションに挑戦&quot;&gt;Module Systemへのマイグレーションに挑戦&lt;/h2&gt;
&lt;p&gt;Java9で導入された &lt;code class=&quot;highlighter-rouge&quot;&gt;Java Platform Module System(JPMS)&lt;/code&gt; の仕様により、
JDKを差し替えただけでは既存のJavaアプリケーションが動かない可能性が高いです。
そのため、Module Systemに対応するためにはいくつか段階を経る必要があります。&lt;/p&gt;

&lt;h3 id=&quot;step-1-module-systemの基礎を勉強する&quot;&gt;Step 1. Module Systemの基礎を勉強する&lt;/h3&gt;
&lt;p&gt;まず、Module Systemに関する知識がなければModule Systemの勉強をしましょう。
私の場合、ヌーラボさんが「&lt;a href=&quot;https://nulab-inc.com/ja/blog/nulab/java9-migration/&quot;&gt;ヌーラボのアカウント基盤を Java 9 にマイグレーションして起きた問題と解決法&lt;/a&gt;」 にて紹介されている内容を参考に学習しました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=NKY2FYTCo7I&amp;amp;t=1905s&quot;&gt;Virtual Java User GroupのJava9マイグレーション動画&lt;/a&gt; を見る
    &lt;ul&gt;
      &lt;li&gt;Githubにリポジトリも公開されているので、一緒に手を動かすのがオススメ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;書籍 &lt;strong&gt;Java9 Modularity&lt;/strong&gt; を読む
    &lt;ul&gt;
      &lt;li&gt;マイグレーションよりも、modulepathの動きとクラス解決の話を中心に読んだほうが良い&lt;/li&gt;
      &lt;li&gt;英語弱者もKindleがあれば大丈夫&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
&lt;a target=&quot;_blank&quot; href=&quot;https://www.amazon.co.jp/gp/product/B075FZK9DC/ref=as_li_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=1211&amp;amp;creativeASIN=B075FZK9DC&amp;amp;linkCode=as2&amp;amp;tag=soudegesu0a-22&amp;amp;linkId=57a893d3bc1e7e5418a0aff02cb01707&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;amp;MarketPlace=JP&amp;amp;ASIN=B075FZK9DC&amp;amp;ServiceVersion=20070822&amp;amp;ID=AsinImage&amp;amp;WS=1&amp;amp;Format=_SL250_&amp;amp;tag=soudegesu0a-22&quot; /&gt;&lt;/a&gt;&lt;img src=&quot;//ir-jp.amazon-adsystem.com/e/ir?t=soudegesu0a-22&amp;amp;l=am2&amp;amp;o=9&amp;amp;a=B075FZK9DC&quot; width=&quot;1&quot; height=&quot;1&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;border:none !important; margin:0px !important;&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;このステップでは&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Moduleの種類(Unnamed/Automatic/Named)と違いを理解する&lt;/li&gt;
  &lt;li&gt;classpathとmodulepathでのクラスロードの違いを理解する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が身につけばOKだと感じました。&lt;/p&gt;

&lt;p&gt;余裕があれば、Module SystemのBootstrapのコードを読んでおくと更に理解が捗ると思います。
(System#initPhase2の処理あたりからブレークポイント貼って読むといいです)&lt;/p&gt;

&lt;h3 id=&quot;step-2-依存ライブラリのバージョンアップを行う&quot;&gt;Step 2. 依存ライブラリのバージョンアップを行う&lt;/h3&gt;
&lt;p&gt;Step 1で基本が理解できたら、&lt;strong&gt;Java8のうちに依存ライブラリのバージョンアップをやりましょう&lt;/strong&gt; 。 
リリースノートでJava9対応を謳っているライブラリはJava8でも動作可能なものが大半なので、今の内にJava9(Module System)対応版のバージョンまで依存ライブラリのバージョンを更新するのが良いです。
理由は単純で、 &lt;strong&gt;Module Systemに対応させるのも多少時間がかかるのに、ライブラリ自体のマイナーアップグレードの対応も同時に行うのは苦行&lt;/strong&gt; だからです。変更箇所が多いと、細かな変更を見落としがちになり、デグレードを引き起こす原因になります。また、ライブラリの更新と合わせて、細かく商用環境にデプロイすることで、リスクを減らしながらマイグレーションすることができます。&lt;/p&gt;

&lt;p&gt;なお、参考までに私のプロジェクトでは主にライブラリを使用していて(モジュールの正式名称での記載は省略)、これらを最新の安定版まで全てアップグレードしました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;ライブラリ&lt;/th&gt;
      &lt;th&gt;Java9対応状況&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;springboot(embed tomcat)&lt;/td&gt;
      &lt;td&gt;2.x 〜(2018/2リリース予定)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;dropwizard-metric&lt;/td&gt;
      &lt;td&gt;不明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lombok&lt;/td&gt;
      &lt;td&gt;済&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mariadb-java-client&lt;/td&gt;
      &lt;td&gt;済&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;jmockit&lt;/td&gt;
      &lt;td&gt;済&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;gradle&lt;/td&gt;
      &lt;td&gt;未&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;加えて、リポジトリがマルチモジュール構成になっているという点が特徴です。&lt;/p&gt;

&lt;h4 id=&quot;ライブラリのリリースノートを読んで大丈夫だなと早合点するのは危険&quot;&gt;ライブラリのリリースノートを読んで「大丈夫だな」と早合点するのは危険&lt;/h4&gt;

&lt;p&gt;このステップのポイントとして、リリースノートの情報だけで自プロダクトがModule Systemに移行可能だと思い込んで作業を終了してしまうのは危険、ということです。 &lt;strong&gt;自分のプロジェクトがNamed Moduleとしてマイグレーション可能か(ここで言うStep 4)&lt;/strong&gt; まで手を動かして確認した方が良いでしょう。&lt;/p&gt;

&lt;p&gt;実際問題、Named Moduleにマイグレーションする場合には、 &lt;strong&gt;modulepath上で同じjavaのパッケージを持った複数のライブラリが存在しない状態&lt;/strong&gt; にする必要があり、依存ライブラリが古かったり多かったりするとパッケージの重複エラーが発生します。下のイメージの場合ではmodulepathでのクラスロードはできないので、ライブラリ側に対応をお願いするか、classpathからロードする必要があります。&lt;/p&gt;

&lt;p&gt;(例: &lt;code class=&quot;highlighter-rouge&quot;&gt;tomcat-embed-core&lt;/code&gt; と &lt;code class=&quot;highlighter-rouge&quot;&gt;tomcat-juli&lt;/code&gt; で パッケージ重複が起きていてNG)
&lt;img src=&quot;/assets/images/20180204/conflict_packages.png&quot; alt=&quot;conflict_packages&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;step-3-unnamed-moduleにマイグレーションする&quot;&gt;Step 3. Unnamed Moduleにマイグレーションする&lt;/h3&gt;
&lt;p&gt;
Unnamed Moduleはclasspathを用いてクラスをロードする方式であるため、そこまで大きな改修は不要です。Javaのバージョンが上がったことによってパッケージから分離されたクラスを利用可能にするためにコンパイル引数を追加する作業が主なタスクになります。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Gradle&lt;/code&gt; であれば、例えば以下のようにコンパイル引数を追加しました。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;compileJava.options.compilerArgs += [
    &quot;--add-modules&quot;, &quot;java.xml.ws.annotation&quot;,
    &quot;--add-modules&quot;, &quot;java.xml.bind&quot;,
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step-4-named-moduelにマイグレーションする&quot;&gt;Step 4. Named Moduelにマイグレーションする&lt;/h3&gt;

&lt;p&gt;Named Moduleはメインモジュールの &lt;code class=&quot;highlighter-rouge&quot;&gt;module-info.java&lt;/code&gt; に定義されている情報を基にmodulepath上に配備されているモジュールをロードしていきます。&lt;/p&gt;

&lt;p&gt;Unnamed Moduleの時とは異なり、ビルドスクリプト(私の場合は &lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt; ) をそこそこ書き換える必要があるので、覚悟して臨みましょう。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Gradle&lt;/code&gt; は &lt;code class=&quot;highlighter-rouge&quot;&gt;Maven&lt;/code&gt; と違い、java9のサポートを謳ってはいません。しかし、 &lt;a href=&quot;https://guides.gradle.org/building-java-9-modules/&quot;&gt;Building Java 9 Modules&lt;/a&gt; にjava9に対応するためのヒントとサンプルリポジトリへのリンクがあるので、これを参考にすると良いです。&lt;/p&gt;

&lt;p&gt;私も紹介されている通りに &lt;code class=&quot;highlighter-rouge&quot;&gt;java-library&lt;/code&gt; プラグインに差し替えてビルドするように修正しました。
なお、 &lt;code class=&quot;highlighter-rouge&quot;&gt;experimental-jigsaw&lt;/code&gt; プラグインは使わずともいけました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://guides.gradle.org/building-java-9-modules/&quot;&gt;Building Java 9 Modules&lt;/a&gt; を参考にしつつと言ったのですが、こちらも注意点があります。ページでは以下のようサンプルコードが書かれているのですが、試しにやってみたところ、一発でコンパイルは通りませんでした。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;doFirst {
    options.compilerArgs = [
        '--module-path', classpath.asPath,
    ]
    classpath = files()  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;このコードサンプルではGradleがリポジトリから取得したclasspath上のライブラリを全てmodulepathで読み込むように修正しています。
そのため、Step 2でも少し触れましたが &lt;strong&gt;modulepath上で同じjavaのパッケージを持った複数のモジュールが存在する場合&lt;/strong&gt; は以下のようなエラーが出力されてしまいます。(例としてspringboot1.5.9が依存している &lt;code class=&quot;highlighter-rouge&quot;&gt;embed tomcate&lt;/code&gt;のライブラリでパッケージが競合している場合)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;エラー: モジュールhttpclientはtomcat.embed.coreとtomcat.juliの両方からパッケージorg.apache.juliを読み取ります
エラー: モジュールhttpclientはtomcat.embed.coreとtomcat.juliの両方からパッケージorg.apache.juli.loggingを読み取ります
エラー: モジュールhttpclientはjava.persistenceとhibernate.jpaの両方からパッケージjavax.persistence.spiを読み取ります
エラー: モジュールhttpclientはjava.persistenceとhibernate.jpaの両方からパッケージjavax.persistence.criteriaを読み取ります
エラー: モジュールhttpclientはjava.persistenceとhibernate.jpaの両方からパッケージjavax.persistence.metamodelを読み取ります
エラー: モジュールhttpclientはjava.persistenceとhibernate.jpaの両方からパッケージjavax.persistenceを読み取ります
エラー: モジュールhttpclientはjava.persistenceとtomcat.annotations.apiの両方からパッケージjavax.persistenceを読み取ります
エラー: モジュールhttpclientはjavax.transaction.apiとjava.sqlの両方からパッケージjavax.transaction.xaを読み取ります
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;これを解決するためのワークアラウンドがそこそこ大変なのですが&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;モジュールのバージョンを合わせる(場合によっては片方のdependencyからexcludeする)&lt;/li&gt;
  &lt;li&gt;代替可能な別クラスや別モジュールにコードを置き換えて、依存モジュールを減らす&lt;/li&gt;
  &lt;li&gt;特定のモジュールのみclasspathから読み込むように &lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt; を修正する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という風に逐一スタックトレースとにらめっこをしていました。&lt;/p&gt;

&lt;h3 id=&quot;step-5-負荷試験とリソースモニタリングをする&quot;&gt;Step 5. 負荷試験とリソースモニタリングをする&lt;/h3&gt;
&lt;p&gt;最後にアプリケーションが今まで通りの振る舞いをするかどうかを外部から確認します。
自動化された単体テストや結合テストはもちろんですが、今までと同等のリクエスト負荷に耐えられるか、システムの健康状態を測定するメトリックが今まで通り取れているかを確認します。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;今回はプロダクションコードのリポジトリでModule Systemに移行するための手順を確認できました。
従来の &lt;code class=&quot;highlighter-rouge&quot;&gt;classpath&lt;/code&gt; のクラスロードから &lt;code class=&quot;highlighter-rouge&quot;&gt;modulepath&lt;/code&gt; へのクラスロードに機構が変わったことに加え、ビルドツールが現段階ではよしなにやってくれないため、モジュール同士の依存関係やモジュール自体の設計を強く意識する必要が出てきました。ここは今後の課題かもしれません。&lt;/p&gt;

&lt;p&gt;個人的には商用環境までデプロイできればかっこよかったのですが、&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;springboot 2.xの安定版がまだないこと&lt;/li&gt;
  &lt;li&gt;Java 9/10にはサポートがつかないこと&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt; の可読性とメンテナンス性が落ちた&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ことを理由に商用デプロイは見送っています。
Java 8もまだしばらくサポートされるようですし、今回の学習によってマイグレーションのアキレス腱がどこにありそうなのか理解できたことは収穫でした。
皆さんも是非、自プロダクトで練習してみてはいかがでしょうか。&lt;/p&gt;

&lt;p&gt;最後にポイントだけもう一度まとめておきます&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;マイグレ前にやること
    &lt;ul&gt;
      &lt;li&gt;依存ライブラリのサポート状況を確認しておく&lt;/li&gt;
      &lt;li&gt;依存ライブラリのバージョンを上げておく&lt;/li&gt;
      &lt;li&gt;依存ライブラリを減らしておく(可能なら)&lt;/li&gt;
      &lt;li&gt;テストコードを準備しておく&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;マイグレ中
    &lt;ul&gt;
      &lt;li&gt;まずはUnnamed Moduleにマイグレする&lt;/li&gt;
      &lt;li&gt;パッケージ重複が発生していないか注意する&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;マイグレ後
    &lt;ul&gt;
      &lt;li&gt;負荷試験とかしっかり&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参考にさせていただいたページ&quot;&gt;参考にさせていただいたページ&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://nulab-inc.com/ja/blog/nulab/java9-migration/&quot;&gt;ヌーラボのアカウント基盤を Java 9 にマイグレーションして起きた問題と解決法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.gradle.org/building-java-9-modules/&quot;&gt;Building Java 9 Modules&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>soudegesu</name></author><category term="java" /><category term="java9" /><category term="modular" /><category term="jigsaw" /><category term="gradle" /><category term="springboot" /><category term="modulepath" /><category term="classpath" /><category term="JPMS" /><summary type="html"></summary></entry><entry xml:lang="ja"><title type="html">AWS Certification ManagerのSSL証明書の検証にはDNS検証を使った方が良い</title><link href="https://www.soudegesu.com/aws/validate-certification-manager" rel="alternate" type="text/html" title="AWS Certification ManagerのSSL証明書の検証にはDNS検証を使った方が良い" /><published>2018-01-31T00:00:00+09:00</published><updated>2018-01-31T00:00:00+09:00</updated><id>https://www.soudegesu.com/aws/acm-route53-validate</id><content type="html" xml:base="https://www.soudegesu.com/aws/validate-certification-manager">&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#route53でcertification-managerのドメイン検証ができるようになった&quot; id=&quot;markdown-toc-route53でcertification-managerのドメイン検証ができるようになった&quot;&gt;Route53でCertification Managerのドメイン検証ができるようになった&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ssl証明書発行の違い&quot; id=&quot;markdown-toc-ssl証明書発行の違い&quot;&gt;SSL証明書”発行”の違い&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#e-mail検証は手間がかかる&quot; id=&quot;markdown-toc-e-mail検証は手間がかかる&quot;&gt;E-mail検証は手間がかかる&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#dns検証によって検証ステップが格段に簡素になる&quot; id=&quot;markdown-toc-dns検証によって検証ステップが格段に簡素になる&quot;&gt;DNS検証によって検証ステップが格段に簡素になる&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ssl証明書更新の違い&quot; id=&quot;markdown-toc-ssl証明書更新の違い&quot;&gt;SSL証明書”更新”の違い&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#acmのssl証明書有効期限は13ヶ月&quot; id=&quot;markdown-toc-acmのssl証明書有効期限は13ヶ月&quot;&gt;ACMのSSL証明書有効期限は13ヶ月&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#acm更新のプロセス&quot; id=&quot;markdown-toc-acm更新のプロセス&quot;&gt;ACM更新のプロセス&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#aws側によるacmの自動検証と自動更新&quot; id=&quot;markdown-toc-aws側によるacmの自動検証と自動更新&quot;&gt;①AWS側によるACMの自動検証と自動更新&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#ドメイン管理者に催促メールを通知&quot; id=&quot;markdown-toc-ドメイン管理者に催促メールを通知&quot;&gt;②ドメイン管理者に催促メールを通知&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#awsアカウントに催促メールを通知&quot; id=&quot;markdown-toc-awsアカウントに催促メールを通知&quot;&gt;③AWSアカウントに催促メールを通知&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#手動でのacm検証作業&quot; id=&quot;markdown-toc-手動でのacm検証作業&quot;&gt;④手動でのACM検証作業&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#e-mail検証の自動更新条件は複雑&quot; id=&quot;markdown-toc-e-mail検証の自動更新条件は複雑&quot;&gt;E-mail検証の自動更新条件は複雑&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#dns検証の自動更新条件は単純&quot; id=&quot;markdown-toc-dns検証の自動更新条件は単純&quot;&gt;DNS検証の自動更新条件は単純&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考にさせていただいたページ&quot; id=&quot;markdown-toc-参考にさせていただいたページ&quot;&gt;参考にさせていただいたページ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;route53でcertification-managerのドメイン検証ができるようになった&quot;&gt;Route53でCertification Managerのドメイン検証ができるようになった&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180131/acm_validate.png&quot; alt=&quot;acm_validate&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/jp/blogs/news/easier-certificate-validation-using-dns-with-aws-certificate-manager/&quot;&gt;DNS を使って AWS Certificate Manager の検証を簡単に&lt;/a&gt;
の記事にも記載があるように、2017/11に &lt;code class=&quot;highlighter-rouge&quot;&gt;AWS Certification Manager(以下ACM)&lt;/code&gt; のSSL証明書取得の際の検証手順に &lt;em&gt;Route53のDNS検証&lt;/em&gt; が追加されました。実はこれは、ACMで取得したSSL証明書の &lt;em&gt;取得&lt;/em&gt; だけではなく &lt;em&gt;更新&lt;/em&gt; においてもとても大きな利点があるので、今回はそれを紹介します。&lt;/p&gt;

&lt;h2 id=&quot;ssl証明書発行の違い&quot;&gt;SSL証明書”発行”の違い&lt;/h2&gt;
&lt;h3 id=&quot;e-mail検証は手間がかかる&quot;&gt;E-mail検証は手間がかかる&lt;/h3&gt;
&lt;p&gt;従来、ACMにてSSL証明書を取得する際のドメイン検証の方法は、Certificatioin Managerで証明書発行依頼を出した後、受信したE-mailの本文に記載されている一時リンクを踏んで承認ボタンを押す、という手続きを踏んでいました。&lt;/p&gt;

&lt;p&gt;その際の注意点は、&lt;em&gt;AWSからの検証確認メールを受信できるメール受信箱が必要になる&lt;/em&gt; ことでした。
私の場合、会社が取得しているドメインのサブドメインを委譲してもらい新規プロダクトを実装することが多いため、
身近にいないドメイン管理者(別部署や別会社)の受信箱にのみメールが届いてしまい、
自分のタイミングで承認ボタンを押すことができませんでした。
そのため、私の場合は自分のAWSアカウント内にE-mail検証のためのメール受信箱を作成していました。&lt;/p&gt;

&lt;p&gt;自前のAWSアカウント内で検証を完結させるためには、&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;受信ボックス代わりになるS3バケットを作成し&lt;/li&gt;
  &lt;li&gt;Route53にTXTレコードやMXレコードを作成し&lt;/li&gt;
  &lt;li&gt;SNSで受けたメールをS3に振り分け、&lt;/li&gt;
  &lt;li&gt;S3バケットで受け取ったメール本文をダウンロードして、リンクを踏む&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という手順を踏まなくてはいけません。&lt;/p&gt;

&lt;p&gt;こちらの設定の手順はクラスメソッドさんのブログ「 &lt;a href=&quot;https://dev.classmethod.jp/cloud/aws/acm-verifydomain-ses/&quot;&gt;[ACM] SSL証明書発行時のドメイン認証メールをSESで受け取ってみた&lt;/a&gt; 」に掲載されておりますので、
興味のある方はご参照ください。&lt;/p&gt;

&lt;h3 id=&quot;dns検証によって検証ステップが格段に簡素になる&quot;&gt;DNS検証によって検証ステップが格段に簡素になる&lt;/h3&gt;
&lt;p&gt;DNS検証ではRoute53に追加されたCNAMEレコードを用いてドメインの有効性を確認します。
そのため&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;「Create record in Route 53」 でCNAMEレコードを作成し&lt;/li&gt;
  &lt;li&gt;少し待つ(10分くらい?)
で検証が終了します。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ね、簡単でしょう？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20180131/add_record.png&quot; alt=&quot;add_cname_records&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ssl証明書更新の違い&quot;&gt;SSL証明書”更新”の違い&lt;/h2&gt;
&lt;h3 id=&quot;acmのssl証明書有効期限は13ヶ月&quot;&gt;ACMのSSL証明書有効期限は13ヶ月&lt;/h3&gt;
&lt;p&gt;ACMで発行したSSL証明書の有効期限は13ヶ月です。そのため、1年程経過したらSSL証明書の更新作業が発生します。
これはSSL証明書を運用されている人でしたら毎度のことなのですが、 &lt;em&gt;証明書の更新時期を忘れないよう&lt;/em&gt; に通知の仕組みを入れたり、
引き継ぎをしたり様々な工夫をされていることかと思います。&lt;/p&gt;

&lt;h3 id=&quot;acm更新のプロセス&quot;&gt;ACM更新のプロセス&lt;/h3&gt;
&lt;p&gt;まず、ACMのSSL証明書更新の全体の流れを抑えましょう。&lt;/p&gt;

&lt;h4 id=&quot;aws側によるacmの自動検証と自動更新&quot;&gt;①AWS側によるACMの自動検証と自動更新&lt;/h4&gt;
&lt;p&gt;ACM期限切れの60日前に自動更新可能なものかAWS側で検証し、検証に成功した場合には自動更新を実施してくれます。(自動更新の条件は後述します)&lt;/p&gt;

&lt;h4 id=&quot;ドメイン管理者に催促メールを通知&quot;&gt;②ドメイン管理者に催促メールを通知&lt;/h4&gt;
&lt;p&gt;①の自動更新に失敗した場合には、証明書に記載されているドメインの管理者に対してメールが通知されます。(WHOISに記載されているメールアドレスもしくは、ドメイン名の前にadmin@を付加したメールアドレスになります)&lt;/p&gt;

&lt;h4 id=&quot;awsアカウントに催促メールを通知&quot;&gt;③AWSアカウントに催促メールを通知&lt;/h4&gt;
&lt;p&gt;②のメールからも検証が確認されない場合、AWSアカウントに登録されているメールアドレスに対して通知されます。&lt;/p&gt;

&lt;h4 id=&quot;手動でのacm検証作業&quot;&gt;④手動でのACM検証作業&lt;/h4&gt;
&lt;p&gt;メールに記載されたURLにアクセスし、承認ボタンを押すことでACMの検証が完了します。
ただし、実際にACMが更新されるまでに数時間程度のタイムラグが発生することをAWSでは謳っています。&lt;/p&gt;

&lt;p&gt;①にも記載の通り、素晴らしいことにACMはSSL証明書を自動更新することができます。
ただし、自動更新するためには条件がありますので、以下に説明します。&lt;/p&gt;

&lt;h3 id=&quot;e-mail検証の自動更新条件は複雑&quot;&gt;E-mail検証の自動更新条件は複雑&lt;/h3&gt;
&lt;p&gt;E-mailで検証したSSL証明書の自動更新の条件は以下になります。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;発行したSSL証明書がAWSリソースでを使用されていること&lt;/li&gt;
  &lt;li&gt;インターネットからのHTTPSリクエストを許可すること&lt;/li&gt;
  &lt;li&gt;証明書記載のFQDNが名前解決できること&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt; に関して言えば、Public ELBでもSecurityGroupでアクセス制限を施しているケースや、
Internal ELBを使っている場合には適用されません。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt; に関して言えば、ワイルドカードドメインの場合では、ゾーンAPEX、wwwドメインで名前解決できる必要があります。
例えば、 「*.soudegesu.com」の場合には「soudegesu.com」と「www.soudegesu.com」での解決が必要です。&lt;/p&gt;

&lt;p&gt;加えて、仮に3つの条件を満たしていても、複数のリージョンで同一ドメイン名を使用している場合には、正しく名前解決できずにNGとなってしまうそうです。&lt;/p&gt;

&lt;p&gt;つまり、E-mail検証での証明書自動更新は仕様上、適用条件が限定的なのです。&lt;/p&gt;

&lt;h3 id=&quot;dns検証の自動更新条件は単純&quot;&gt;DNS検証の自動更新条件は単純&lt;/h3&gt;

&lt;p&gt;DNS検証で作成したSSL証明書の自動更新のルールはどうでしょうか。
AWSのドキュメントをパッと漁れなかったので、サポートに問い合わせてみたところ、以下のような回答をいただきました。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;発行したSSL証明書がAWSリソースでを使用されていること&lt;/li&gt;
  &lt;li&gt;証明書発行の際に設定された &lt;code class=&quot;highlighter-rouge&quot;&gt;CNAME&lt;/code&gt; レコードが残っていること&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;こちらの方が適用条件が単純明快です。
インターネット経由の通信要件やプロトコル、ドメインの縛りがありません。
証明書リクエスト時に追加するCNAMEレコードを消さないように死守するだけでよいのです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.terraform.io/&quot;&gt;Terraform&lt;/a&gt; や &lt;a href=&quot;https://github.com/codenize-tools/roadworker&quot;&gt;roadworker&lt;/a&gt; といったコード化ツールを使っていればなおのこと敷居は下がりますね。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;今回は2種類の検証方法を比較しながらDNS検証の優位性を説明しました。&lt;/p&gt;

&lt;p&gt;DNS検証は事前準備の手間を省略でき、発行時のステップも少ないです。&lt;/p&gt;

&lt;p&gt;また、証明書の自動更新の適用条件も広いため、オススメです。&lt;/p&gt;

&lt;p&gt;稼働中のサービスがいきなりSSL証明書の期限切れでエラーを吐き続けるといったリスクを緩和するためにも、DNS検証のSSL証明書に切り替えていく価値はあると思います。(一応Route53はSLA100%ですし)&lt;/p&gt;

&lt;h2 id=&quot;参考にさせていただいたページ&quot;&gt;参考にさせていただいたページ&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/jp/blogs/news/easier-certificate-validation-using-dns-with-aws-certificate-manager/&quot;&gt;DNS を使って AWS Certificate Manager の検証を簡単に&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dev.classmethod.jp/cloud/aws/acm-verifydomain-ses/&quot;&gt;[ACM] SSL証明書発行時のドメイン認証メールをSESで受け取ってみた&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>soudegesu</name></author><category term="AWS" /><category term="ACM" /><category term="route53" /><category term="ssl" /><category term="validate" /><summary type="html"></summary></entry><entry xml:lang="ja"><title type="html">ブログ(静的サイト)をHUGOを使って作成する</title><link href="https://www.soudegesu.com/blog/hugo/" rel="alternate" type="text/html" title="ブログ(静的サイト)をHUGOを使って作成する" /><published>2017-05-05T21:58:00+09:00</published><updated>2017-05-05T21:58:00+09:00</updated><id>https://www.soudegesu.com/blog/hugo</id><content type="html" xml:base="https://www.soudegesu.com/blog/hugo/">&lt;p&gt;本サイトでは &lt;a href=&quot;https://jekyllrb-ja.github.io/&quot;&gt;jekyll&lt;/a&gt; を使用してブログを作成しているのですが、他にも &lt;a href=&quot;https://gohugo.io/&quot;&gt;HUGO&lt;/a&gt; や &lt;a href=&quot;https://hexo.io/&quot;&gt;hexo&lt;/a&gt; を使用されている方も多くいらっしゃるようなので、今回はHUGOを使用してブログコンテンツを作成する方法を紹介したいと思います。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ゴール&quot; id=&quot;markdown-toc-ゴール&quot;&gt;ゴール&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#事前準備&quot; id=&quot;markdown-toc-事前準備&quot;&gt;事前準備&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#hugoをインストールする前に&quot; id=&quot;markdown-toc-hugoをインストールする前に&quot;&gt;HUGOをインストールする前に…&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#hugoのインストールmacosの場合&quot; id=&quot;markdown-toc-hugoのインストールmacosの場合&quot;&gt;HUGOのインストール(MacOSの場合)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#hugoを使ってコンテンツを作成する&quot; id=&quot;markdown-toc-hugoを使ってコンテンツを作成する&quot;&gt;HUGOを使ってコンテンツを作成する&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#hugoテンプレートで生成する&quot; id=&quot;markdown-toc-hugoテンプレートで生成する&quot;&gt;HUGOテンプレートで生成する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#サイトのデザインthemeを設定する&quot; id=&quot;markdown-toc-サイトのデザインthemeを設定する&quot;&gt;サイトのデザイン(theme)を設定する&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#themeを探す&quot; id=&quot;markdown-toc-themeを探す&quot;&gt;themeを探す&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#themeをインストールする&quot; id=&quot;markdown-toc-themeをインストールする&quot;&gt;themeをインストールする&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#themeを設定する&quot; id=&quot;markdown-toc-themeを設定する&quot;&gt;themeを設定する&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#記事を作成する&quot; id=&quot;markdown-toc-記事を作成する&quot;&gt;記事を作成する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#余談archetypesdefaultsmd-を利用して手間を減らす&quot; id=&quot;markdown-toc-余談archetypesdefaultsmd-を利用して手間を減らす&quot;&gt;(余談)archetypes/defaults.md を利用して手間を減らす&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#コンテンツの出来栄えをローカル環境で確認する&quot; id=&quot;markdown-toc-コンテンツの出来栄えをローカル環境で確認する&quot;&gt;コンテンツの出来栄えをローカル環境で確認する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#コンテンツをビルドする&quot; id=&quot;markdown-toc-コンテンツをビルドする&quot;&gt;コンテンツをビルドする&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ゴール&quot;&gt;ゴール&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;HUGOで静的サイトの作成ができるようになる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;事前準備&quot;&gt;事前準備&lt;/h2&gt;
&lt;h3 id=&quot;hugoをインストールする前に&quot;&gt;HUGOをインストールする前に…&lt;/h3&gt;
&lt;p&gt;以下がローカルマシン上にインストールされていると以降の手順が捗ります。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Homebrew&lt;/li&gt;
  &lt;li&gt;git&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hugoのインストールmacosの場合&quot;&gt;HUGOのインストール(MacOSの場合)&lt;/h2&gt;
&lt;p&gt;Homebrewを使用するとHUGOを簡単にインストールできます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#brew install hugo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;HUGOのバージョンを確認してみましょう。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#hugo version
Hugo Static Site Generator v0.20.7 darwin/amd64 BuildDate: 2017-05-05T22:14:37+09:00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;v0.20.7(2017/05時点で最新)がインストールされていることがわかります。&lt;/p&gt;

&lt;h2 id=&quot;hugoを使ってコンテンツを作成する&quot;&gt;HUGOを使ってコンテンツを作成する&lt;/h2&gt;
&lt;h3 id=&quot;hugoテンプレートで生成する&quot;&gt;HUGOテンプレートで生成する&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hugo new site&lt;/code&gt;のサブコマンドを実行するだけで静的サイトのテンプレートをgenerateしてくれます。今回は &lt;code class=&quot;highlighter-rouge&quot;&gt;hoge&lt;/code&gt; というディレクトリ配下に作成します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#hugo new site hoge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hoge&lt;/code&gt; 配下で &lt;code class=&quot;highlighter-rouge&quot;&gt;tree&lt;/code&gt; コマンドを実行すると以下のようなファイルレイアウトが生成されていることがわかります。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#cd hoge
#tree -L 1                                                          .
├── archetypes
├── config.toml
├── content
├── data
├── layouts
├── static
└── themes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;ディレクトリ or ファイル&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;用途&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;archetypes&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hugo new&lt;/code&gt; コマンドを実行した場合に使用されるデフォルトの雛形の定義ファイルを配備しておくディレクトリ&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;config.toml&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;サイト全体の設定を記述する設定ファイル。&lt;code class=&quot;highlighter-rouge&quot;&gt;yaml&lt;/code&gt; や &lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt; 形式もサポートしている&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;content&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;記事そのものを配備するディレクトリ&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;data&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;特定のデータファイルを置くディレクトリ。&lt;code class=&quot;highlighter-rouge&quot;&gt;yaml&lt;/code&gt; や &lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt; や &lt;code class=&quot;highlighter-rouge&quot;&gt;toml&lt;/code&gt; をサポート。 layoutsディレクトリ内のテンプレートに依存する。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;layouts&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;サイトレイアウトを配備するディレクトリ。UIパーツ毎のHTMLテンプレートを置くようなイメージ&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;static&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CSSやjavascript、画像ファイルといった静的ファイルを格納するディレクトリ&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;themes&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;サイトのテーマを配置するディレクトリ&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;サイトのデザインthemeを設定する&quot;&gt;サイトのデザイン(theme)を設定する&lt;/h3&gt;

&lt;h4 id=&quot;themeを探す&quot;&gt;themeを探す&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://themes.gohugo.io/&quot;&gt;HUGOのthemeサイト&lt;/a&gt; から好みのサイトデザインを選びます。今回は &lt;a href=&quot;https://themes.gohugo.io/hugo-hello-programmer-theme/&quot;&gt;Hello Programerのテーマ&lt;/a&gt; にしてみましょう。HUGOの場合、Jekyllと比較してthemeの数が少ないように感じられますが、1つ1つが個性的なので、概ね自身の用途に応じたthemeが見つかるのではないでしょうか。本家サイトにて &lt;code class=&quot;highlighter-rouge&quot;&gt;layouts&lt;/code&gt; をどう作成すればよいか説明がありますので、気に入るものがない場合にはそちらを参照してください。&lt;/p&gt;

&lt;h4 id=&quot;themeをインストールする&quot;&gt;themeをインストールする&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;themes&lt;/code&gt; ディレクトリに移動し、直接themeを &lt;code class=&quot;highlighter-rouge&quot;&gt;git clone&lt;/code&gt; します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#cd themes
#git clone https://github.com/lubang/hugo-hello-programmer-theme
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;themeを設定する&quot;&gt;themeを設定する&lt;/h4&gt;
&lt;p&gt;設定ファイル(config.toml)を開いて、以下のように編集をします。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#vi config.toml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;baseurl = &quot;https://www.soudegesu.com/diary&quot;
title = &quot;そうでげす diary&quot;
DefaultContentLanguage = &quot;ja&quot;
languageCode = &quot;ja-JP&quot;

contentDir = &quot;content/ja&quot;
publishDir = &quot;public/ja&quot;

theme = &quot;hugo-hello-programmer-theme&quot;

paginate = 2

disqusShortname = &quot;XXXX&quot;
googleAnalytics = &quot;UA-XXXXXXXX-X&quot;

[author]
    name = &quot;soudegesu&quot;

[permalinks]
  post = &quot;/blog/:year/:month/:day/:slug/&quot;
  page = &quot;/:slug/&quot;

[taxonomies]
  tag = &quot;tags&quot;
  category = &quot;categories&quot;

[indexes]
    category = &quot;categories&quot;
    tag = &quot;tags&quot;

[params]
    locale = &quot;ja-JP&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;theme&lt;/code&gt; の項目には &lt;code class=&quot;highlighter-rouge&quot;&gt;themes&lt;/code&gt; ディレクトリ配下にある適用したいthemeのディレクトリ名を指定する必要があります。&lt;/p&gt;

&lt;h3 id=&quot;記事を作成する&quot;&gt;記事を作成する&lt;/h3&gt;
&lt;p&gt;プロジェクトルートにて &lt;code class=&quot;highlighter-rouge&quot;&gt;hugo new&lt;/code&gt; のサブコマンドを実行すると記事のファイルを生成することができます。
今回は &lt;code class=&quot;highlighter-rouge&quot;&gt;sample.md&lt;/code&gt; を作成してみます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hugo new (ファイル名)&lt;/code&gt; でファイルを生成する&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#hugo new post/sample.md                                            
/絶対パス/post/sample.md created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;ファイルが生成されたことを &lt;code class=&quot;highlighter-rouge&quot;&gt;tree&lt;/code&gt; コマンドにて確認&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#tree -a content                                                                       
content
└── ja
    └── post
        └── sample.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;date と title のみ記載がされているファイルが生成されたことを確認&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#cat content/ja/post/sample.md
+++
date = &quot;2017-05-06T11:11:46+09:00&quot;
title = &quot;sample&quot;

+++
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;余談archetypesdefaultsmd-を利用して手間を減らす&quot;&gt;(余談)archetypes/defaults.md を利用して手間を減らす&lt;/h3&gt;
&lt;p&gt;HUGOをインストールした直後に&lt;code class=&quot;highlighter-rouge&quot;&gt;hugo new (ファイル名)&lt;/code&gt; コマンドで記事ファイルを作成すると、&lt;code class=&quot;highlighter-rouge&quot;&gt;date&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;しか埋め込まれていません。
&lt;code class=&quot;highlighter-rouge&quot;&gt;archetypes/defaults.md&lt;/code&gt; を以下のように予め作成しておくことで、&lt;code class=&quot;highlighter-rouge&quot;&gt;hugo new&lt;/code&gt; した際に、定義されている内容を雛形として、新規ファイルを作成してくれるようになります。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+++
draft = true
slug = &quot;&quot;
tags = [&quot;&quot;, &quot;&quot;]
categories = [&quot;&quot;, &quot;&quot;]

+++
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;最新バージョンでは &lt;code class=&quot;highlighter-rouge&quot;&gt;date&lt;/code&gt; や &lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt; を default.md に記載する必要はなくなりました。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;コンテンツの出来栄えをローカル環境で確認する&quot;&gt;コンテンツの出来栄えをローカル環境で確認する&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hugo serve&lt;/code&gt; のサブコマンドを実行すると、ローカル環境で内容の確認ができます。
ブラウザから &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:1313/&lt;/code&gt; を入力してビルドされたコンテンツにアクセスできるようになります。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#hugo serve -D
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;なお、&lt;code class=&quot;highlighter-rouge&quot;&gt;-D&lt;/code&gt; オプションを付けることで、下書き扱いのコンテンツもページ出力対象にすることができます。&lt;/p&gt;

&lt;h3 id=&quot;コンテンツをビルドする&quot;&gt;コンテンツをビルドする&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hugo&lt;/code&gt; コマンドを実行することで、コンテンツのビルドが行われます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#hugo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; ディレクトリが生成され、その中に静的ファイルが生成されていることを確認できます。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;今回は &lt;code class=&quot;highlighter-rouge&quot;&gt;HUGO&lt;/code&gt; を使って静的サイトの生成ができました。
使ってみた感想として、&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;導入までの敷居が低い(Jekyllが高すぎる)&lt;/li&gt;
  &lt;li&gt;本家サイトの出来が良く、とりあえず読めば理解できる&lt;/li&gt;
  &lt;li&gt;ローカルビルドの体感が早く感じる
といった印象を持ちました。
今後JekyllとHUGOを併用してみて、良し悪しを判断できればと思います。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>soudegesu</name></author><category term="hugo" /><category term="blog" /><category term="site" /><summary type="html">本サイトでは jekyll を使用してブログを作成しているのですが、他にも HUGO や hexo を使用されている方も多くいらっしゃるようなので、今回はHUGOを使用してブログコンテンツを作成する方法を紹介したいと思います。</summary></entry></feed>